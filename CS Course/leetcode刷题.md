# 开篇

- 刻意练习 一道题刷一遍不够 建议3-5遍。
- 自己的弱项要多练，不要逃避。

**反馈**

- 看自己写的，是否还可以优化
- 看别人的代码，学习他们的优秀题解，解题思路

**刷题**

- 分类 ----> 解题 ----> 多种思路 ----> 最优解
- 5-10分钟无思路 直接看题解，不要浪费时间
- 有思路就写，写完后看能否优化，然后看他人题解，然后背诵默写优秀题解。
- 写代码时不要纠结，先给出主干逻辑，再填充细节（自顶向下写代码，避免被无水平的繁琐细节打扰）
- 解题常见思路：升维，空间换时间
- 先理清思路，考虑好边界问题，临时变量问题。

# 基本数据结构回顾

# 常见解题思路

## 链表解题思路

-  设置哑结点简化操作。
-  如链表元素的删除，如果有哑结点，那么删除第一个和第k个元素的操作就是一样的。
-  双指针 三指针 快慢指针
-  双指针找倒数第k个结点
-  三指针删除链表中重复过的所有元素
-  快慢指针判断链表有无换
-  合理使用数据结构：栈，队列，优先队列[堆]等。
-  利用栈找链表公共结点。
-  利用优先队列找出k个最小（大）的元素
-  注意常见的边界问题。
-  如是否为空
-  next是否存在等
-  链表的插入删除操作要熟练书写。

# 陌生算法概念

## 递归

### 经典汉诺塔问题

把A的盘子 移到B上。下面盘大，下面盘小

```c
void hanoi(int n, int A, int B, int C){
       if (n > 0){
          hanoi(n-1, A, C, B); // 把 1-n-1的盘子放在从A移到C
          move(n,a,b); // 把第n个盘子移到 b上
          hanoi(n-1, C, B, A); // 把C上的重新移到A上
       }
}
```

## 动态规划

**闫式DP值得拥有**

> **基本要素：最优子结构性质与重叠子问题性质**

将复杂问题分解为若干子问题，通过综合子问题的最优解得到原问题的最优解【DP会记录每个子问题的解，避免重复计算，从而提高效率】递归的子问题可能相关，并不独立。

简单说就是：将问题分成小问题，并先着手解决这些小问题.

适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式。

## DP常见问题

**0 1 背包问题**。画表格

**最长公共子串**。画表格，如果两个字母相同，值为左上角邻居的值加1。最后结果遍历一遍 `A [i] [i]`即可

**最长公共子序列**。画表格，如果两个字母相同，则值为为上方或左边邻居的最大值+1，不相同，则为上方或左边邻居的最大值。

## 总结：运筹学

**动态规划常用来解决：**最短路径问题，资源分配问题，设备更新问题等。

**动态规划的不足在于：**

- 没有统一的标准模型可以用，建模时需要具体问题具体分析
- 应用的局限性，实际问题中很多能够设置的状态变量无法满足无后效性，使得动态规划的思想应用受到限制
- 存在的维数限制：但维数过大时虽然可以解决，但是求解很困难！，一般超过三维的问题不采用动态规划思想求解。

## 贪心算法

- 学习如何处理不可能完成的任务
- 没有快速算法的问题（NP完全问题）
-  学习识别NP完全问题，以免浪费时间去寻找解决它们的快速算法
- 学习近似算法，使用它们可快速找到NP完全问题的近似解
- 学习贪婪策略——一种非常简单的问题解决策略。

### 贪心思想

每次都找局部最优解，从而找到全局最优解【需要严格的数学证明是否可以找到全局最优解】

如果不求最优解，只要找个一个差不多的解就可以的话，可以考虑采用贪心做，找到一个和最优解近似的解。

### P问题，NP问题

**P类问题**：能在多项式时间内可解的问题。==【或：一个问题可以在多项式（O(n^k)）的时间复杂度内解决。】==

**NP类问题**：在多项式时间内“可验证”的问题。==【或：一个问题的解可以在多项式的时间内被验证】==也就是说，不能判定这个问题到底有没有解，而是猜出一个解来在多项式时间内证明这个解是否正确。即该问题的猜测过程是不确定的，而对其某一个解的验证则能够在多项式时间内完成。P类问题属于NP问题，但NP类问题不一定属于P类问题。

**`NPC`问题**：存在这样一个NP问题，所有的NP问题都可以约化成它。换句话说，只要解决了这个问题，那么所有的NP问题都解决了。其定义要满足2个条件：

### 如何识别NP完全问题

- 元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢。
- 涉及“所有组合”的问题通常是NP完全问题。 
- 不能将问题分成小问题，必须考虑各种可能的情况。这可能是NP完全问题。 
- 如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是NP完全问题。 
- 如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题。 
- 如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题。

----

- 8.6 有个邮递员负责给20个家庭送信，需要找出经过这20个家庭的最短路径。请问这是一 个NP完全问题吗？ ==是==【指定一定要经过几个点的最短路径是NP问题】
- 8.7 在一堆人中找出最大的朋友圈（即其中任何两个人都相识）是NP完全问题吗？ ==是==
- 8.8 你要制作美国地图，需要用不同的颜色标出相邻的州。为此，你需要确定最少需要使 用多少种颜色，才能确保任何两个相邻州的颜色都不同。请问这是NP完全问题吗？ ==是==

## 并行算法

### 并行算法介绍

可并行执行的算法有：归并排序【有相关论文】；快速排序。

快排并行版的时间复杂度为O(N).

并行带来的速度提升并非线性的。因为除开计算，并行性管理也有开销。分别排序后，还需要进行合并操作。

负载均衡：分配给不同内核的计算任务难度可能不一样，各自完成的时间差距大，很难均匀地分配工作，需要均衡各个内核的计算任务。

## 负载均衡策略介绍

### 介绍

> **并发术语介绍**

TPS=transactions per second  == **tps**是每秒内的事务数，比如执行了dml操作，那么相应的tps会增加；
QPS=queries per second == **qps**是指每秒内查询次数，比如执行了select操作，相应的qps会增加。
RPS=requests per second
一般生产环境单机所能承受的QPS压力为2w左右。但是一般不会让机器满负载运行，会预留一些空间。当并发量过大时就会考虑分布式集群。而分布式集群有一个问题需要解决**负载均衡**

负载均衡通常在传输层或应用层实现

很多专用的硬件负载均衡器都支持在TCP层实现负载均衡，效率高。当然TCP层实现负载均衡有它的缺点，如无法保存长连接等。

一般纯软件实现的通常在应用层来实现，这也是应用比较多的一种实现方式。目前比较流行的实现有Nginx

### 策略

> **轮询(Round Robin)**

轮询是一种很简单的实现，依次将请求分配给后端服务器。一个一个找

- 优点：实现简单，请求均匀分配。
- 缺点：请求均匀分配，因为后端服务器通常性能会有差异，所以希望性能好的服务器能够多承担一部分。也不适合对长连接和命中率有要求的场景。

> **加权轮询(Weighted Round Robin)**

加权本质是一种带优先级的方式，加权轮询就是一种改进的轮询算法，轮询算法是权值相同的加权轮询。需要给后端每个服务器设置不同的权值，决定分配的请求数比例。这个算法应用就相当广泛了，对于无状态的负载场景，非常适合。

- 优点：解决了服务器性能不一的情况
- 缺点：权值需要静态配置，无法自动调节。也不适合对长连接和命中率有要求的场景。

> **随机Random**

随机把请求分配给后端服务器。请求分配的均匀程度依赖于随机算法了，因为实现简单，常常用于配合处理一些极端的情况，如出现热点请求，这个时候就可以random到任意一台后端，以分散热点。当然缺点也不言而喻。

> **一致性hash算法**

