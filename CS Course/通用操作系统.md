# 操作系统概述

考研时考到了操作系统，这是当时记的笔记。

## 操作系统的概念
### 操作系统
* 控制和管理整个计算机系统的硬件和软件资源
* 并合理地组织调度计算机地工作和资源地分配，
* 以提供给用户和其他软件方便的接口和环境，
* 是计算机系统中最基本的系统软件
### 操作系统的功能和目标：
* 作为系统资源的管理者：
    * 提供的功能：
        * 处理机管理
        * 存储器管理
        * 文件管理
        * 设备管理
    * 目标：
        * 安全、高效
* 作为用户和计算机硬件之间的接口：
    * 命令接口：
        * 允许用户直接使用
        * 分类：
            * 联机命令接口
            * 脱机命令接口
    * 程序接口：
        * 允许用户通过程序间接使用
        * 由一组系统调用组成
    * GUI：
        * 现代操作系统中最流行的图形用户接口
* 作为最接近硬件的层次：
* 对硬件机器的扩展：
* 方便用户使用：
## 操作系统的特征
### 并发
* 两个或多个事件在同一时间间隔内发生
* 宏观上同时发生，微观上交替发生
* 并发与并行的区分
    * 并发是一个时间段内交替执行
    * 并行是一个时间点内同时执行
* 扩展：
    * OS和程序并发是一起诞生的
### 共享
* 定义：
    * 共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用
* 两种资源共享方式：
    * 互斥共享方式：
        * 一段时间只允许一个进程访问，该进程访问完后才许下一个访问。
        * 与进程同步互斥PV那块做比较
    * 同时访问方式：
        * 宏观上同时，微观上交替执行
### 考点：并发和共享的关系
* 没有程序的并发执行，一次只能执行一个程序，也就没有必要共享资源了。反正一次就一个程序，可以随意独占资源
* 没有资源的共享，程序的并发也很难进行。不能共享CPU，程序无法执行，不能共享需要的必要资源，程序无法正常运行。
* 没有离开共享的并发，也没有无并发的共享
### 虚拟：
* 定义：
    * 把通过某种技术将一个物理实体变成为若干个逻辑上对应物。
* 两种实现方式：
    * 时分复用：
        * 利用某设备为一用户服务的空闲时间，转去为其他用户服务
        * 尽量不让设备空闲？
    * 空分复用：
        * 利用存储器的空闲空间分区域存放和运行其他多道程序，以此提高内存的利用率
        * 尽量不然空间空闲？
    * 在何处有体现？
        * 多道程序CPU的使用
        * 虚拟内存，内存的换入换出
### 异步：
* 异步性的定义：
    * 以人们不可预知的速度向前推进
* 只要同步机制完善，运行环境系统，可获得完全相同的结果
### 总结：
* 并发和共享是最基本的特征
### 重要考点：
* 理解并发和并行的区别
* 并发和共享互为存在条件
* 没有并发和共享，就谈不上虚拟和异步，因此并发和共享是OS的两个最基本的特征
## 操作系统发展与分类
### 手工阶段：
* 无OS，所有工作要人干预，用户独占全机。人机矛盾（速度和资源利用率）越来越大
### 批处理阶段：
* 出现的目的：
    * 为解决人机矛盾及cpu和IO设备之间的速度不匹配问题
* 单道批处理：
    * 目的：
        * 缓解人机矛盾
    * 优点：
        * 缓解了一定程度的人机速度矛盾，资源利用率有所提升
    * 缺点：
        * 内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序。CPU有大量的时间是在空闲等待IO完成，资源利用率依然很低
* 多道批处理：
    * 目的：
        * 为进一步提高资源的利用率和系统吞吐量
    * 优点：
        * 多道程序并发执行，共享计算机资源。资源利用率大幅提升
        * CPU和其他资源保持忙碌状态，系统吞吐量增大。
    * 缺点：
        * 用户响应时间过长，不提供人机交互能力
    * 需要解决的问题
        * 处理机争用问题
        * 内存分配和保护问题
        * IO设备分配问题
        * 文件的组织和管理问题
        * 用户与系统接口问题
### 分时操作系统：
* 目的：
    * 提供人机交互
* 技术：
    * 采用的分时技术：时间片
* 缺点：
    * 不能优先处理一些紧急任务。
* 特征：同时性，交互性，独立性，及时性
### 实时操作系统：
* 目的：
    * 为了能在某个时间限制内完成某些紧急任务而不需要时间片排队（十分注重及时性）
* 可分为软硬两种
    * 软实时操作系统
        * 允许偶尔错过任务截至时间
    * 硬实时操作系统
        * 不允许错过任务截至时间
* 如：飞行自动控制系统；飞机订票系统；银行管理系统
### 网络操作系统：
* 网络中各种资源共享，各台计算机之间的通信
### 分布式操作系统：
* 分布式和并行，若干台计算机相互协同完成某一任务
### 个人计算机操作系统：
* 单用户单任务操作系统
* 单用户多任务操作系统
    * 只允许一个用户上机，但允许用户把程序分为若干个任务并发执行
* 多用户多任务操作系统
    * 允许多个用户通过终端共享资源，每个用户程序又可进一步分为多个任务，增加系统吞吐量。
## 操作系统的运行机制体系结构
### 预备知识：什么是指令
* 指令就是CPU能识别、执行的最基本命令
### 运行机制：
* 两种指令：
    * 特权指令：
        * 如内存清零指令
        * 如果指令会严重干扰到其他程序的执行，则一定是特权指令
    * 非特权指令：
        * 如普通的运算指令
    * PS：访管指令是在用户态下运行的，请求OS服务用的。
* 两种处理器状态：
    * 核心态【管态】
    * 用户态【目态】
* 两种程序：
    * 内核程序
        * 内核程序是系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态
    * 应用程序
        * 为保证系统能安全运行，普通应用程序只能执行非特权指令，运行在用户态
### OS内核：
* 时钟管理
    * 实现计时功能
* 中断处理
    * 负责实现中断机制
* 原语
    * 是一种特殊的程序
    * 处于OS最底层，是最接近硬件的部分
    * 这种程序的运行具有原子性————其运行只能一起喝茶，不可中断
    * 运行时间较短，调用频繁
* 对系统资源进程管理的功能：
    * 进程管理：
        * PS：有的OS把这部分功能归为内核功能
        * PS：也就是说，不公的OS对内核功能的划分可能不一样
    * 存储器管理
    * 设备管理
### OS的体系结构：
* 大内核：
    * 将OS的主要功能模块都作为系统内核，运行在核心态
    * 优点：高性能
    * 缺点：内核代码庞大，结构混乱，难以维护
* 微内核：
    * 只把最基本的功能保留在内核
    * 优点：内核功能少，结构清晰，方便维护
    * 缺点：需要频繁地在核心态和用户态之间切换，性能低
* 考点：
    * 特权指令只能在核心态下执行
    * 内核程序只能在核心态下执行
    * 核心态、用户态之间地切换
* 
## 中断和异常
### 中断机制的诞生目的：
* 为了实现多道程序并发执行
### 中断的概念和作用：
* 1、当中断发生时，CPU立即进入核心态
* 2、当中断发生后，当前运行的进程暂停运行，并由OS内核对中断进行处理
* 3、对于不同的中断信号，会进行不同的处理
### 中断的分类：
* 内中断【也称为异常、例外、陷入】
* > 信号的来源：CPU内部与当前执行的指令有关。
* > 信号来自于CPU内部。

    * 自愿中断————指令中断
        * 如：系统调用时使用的访管指令【又叫陷入指令、trap指令】
    * 强迫中断
        * 硬件故障
            * 如：缺页
        * 软件中断
            * 如：整数除0
* 外中断【中断】
* > 信号来源：CPU外部与当前执行的指令无关
* > 信号来源于CPU外部

    * 外设请求
        * 如：IO操作完成，发出的中断信号
    * 人工干预
        * 如：用户强行终止一个进程
### 补充：内中断的另一种分类方式
* 陷阱、陷入【trap】
* 故障【fault】
* 终止【abort】
### 外中断的处理过程：
* 每条指令执行结束后，CPU检查是否有外部中断信号
* 若有外部中断信号，则需要保护被中断进程的CPU环境
* 根据中断信号类型转入相应的中断处理程序
* 恢复原进程的CPU环境并退出中断，返回原进程继续往下执行
## 系统调用
### 什么是系统调用，有何作用？
* 操作系统提供给应用程序使用的接口
* 可理解为一种可供应用程序调用的特殊函数
* 应用程序通过系统调用请求来获得OS的服务
* 系统调用【按功能分类】:
    * 设备管理
        * 完成设备的请求、释放、启动等功能
    * 文件管理
        * 完成文件的读、写、创建、删除等功能
    * 进程控制
        * 完成进程的创建、撤销、阻塞、唤醒等功能
    * 进程通信
        * 完成进程之间的消息传递、信号传递等功能
    * 内存管理
        * 完成内存的分配、回收等功能
### 系统调用和库函数的区别：
* 系统调用是OS向上层提供的接口
* 有的库函数是对系统调用的进一步封装
* 当今编写的应用程序大多是通过高级语言提供的库函数间接地进行系统调用
### 系统调用背后的过程：
> 系统调用发生在用户态。是用户向系统请求调用，所以是发生在用户态。
>
> 对系统调用的处理发生在核心态。是OS对调用进行处理，分配资源balabala。
>
> 执行陷入指令会产生内中断，使处理器从用户态进入核心态。

* 传递系统调用参数
* 执行陷入指令
* 执行系统调用相应服务程序
* 返回用户程序

# 进程管理
## 引言及常见问题
### 为什么要引入进程？
* 为了更好地描述控制程序的并发执行，实现操作系统的并发性和共享性
### 进程控制块PCB用来做什么的？
* 描述进程的基本情况和运行状态，进而控制和管理进程
### 进程映像是静态的，进程是动态的
### 进程映像的组成：程序段，相关数据，PCB三部分
### 创建进程实质上是创建进程映像中的PCB
### 撤销进程实质上是撤销进程的PCB
### PCB是进程存在的唯一标志
### 进程是：系统进行资源分配的独立单位（非基本单位）
## 进程的定义
### 进程的典型定义：
* ①进程是程序的一次执行过程
* ②进程是一个程序及其数据在处理机上顺序执行时所发生的活动
* ③进程是具有独立功能的程序在一个数据集合上运行的过程，是系统进行资源分配和调度的一个基本单位
    * 这里的系统资源是指处理机、存储器、和其他设备服务于某进程的“时间”。
## 进程的组成
### 进程控制块（PCB）：
* PCB常见考题
    * 常驻内存，是进程实体的一部分，进程存在的唯一标志
    * 创建进程实际上就是创建PCB
* PCB的组成
    * 进程描述信息
        * 进程标识符PID
        * 用户标识符UID
    * 进程控制和管理信息
        * 进程当前在状态
        * 进程优先级
    * 资源分配清单
        * 程序段指针
        * 数阶段指针
        * 键盘
        * 鼠标
    * 处理机相关信息
        * 各种寄存器
### 程序段：
* 常见考点
    * 能被进程调度程序调度到CPU执行的程序代码
    * 可被多个进程共享，即多个进程可运行同一个程序
* 程序段是存放要执行的代码
### 数据段：
* 进程对应的程序加工处理的原始数据
* 也可以是程序执行时产生的中间结果或最终结果
## 进程的组织
### 链接方式：
* 按照进程状态将PCB分为多个队列
* 操作系统持有指向各个队列的指针
### 索引方式：
* 根据进程状态的不同，建立几张索引表
* 操作系统持有指向各个索引表的指针
## 进程的特征
### 动态性：
* 进程是程序的一次执行过程，是动态地产生、变化和消亡地
### 并发性：
* 内存中有多个进程实体，各进程可并发执行
### 独立性：
* 进程是能独立运行、独立获得资源、独立接受调度的基本单位
### 异步性：
* 各进程按各自独立的、不可预知的速度向前推进，操作系统要提供进程同步机制来解决异步问题
### 结构性：
* 每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成
## 进程的状态==三种基本状态
### 运行态：
* 占有CPU，并在CPU上运行
### 就绪态：
* 已经具备运行条件，但是缺少CPU资源
### 阻塞态【又称等待态】：
* 因等待某一事件而暂停不能运行
* 如等待IO
### 进程状态的转换：
* 
## 进程控制
### 什么是进程控制？
* 就是实现进程状态转换
### 基本概念：
* 进程控制就是要实现进程状态的转换
* 进程控制用原语实现：
    * 原语用关/开中断来实现
        * 关中断，让它不可中断，执行可以一气呵成
        * 开中断，让它可以被中断
    * 原语是一种特殊的程序
    * 原语的执行必须一气呵成，不可中断
### 相关原语：
* 进程的创建：
    * 终端用户登录系统，作业调度，系统提供服务，用户查询的应用请求可引起进程创建
    * 创建新进程的过程（创建原语）：
        * 为进程分配一个唯一标识符，并申请一个空白PCB
        * 为进程分配资源，为新进程的程序和数据及用户栈分配必要的内存空间
        * 初始化PCB
        * 进程就绪队列接纳新进程，就将其插入到就绪队列，等待被调度
* 进程的终止：
    * 正常结束
    * 异常结束：
        * 存储区越界，保护错，非法指令，特权指令，I/O故障
    * 撤销原语：
        * 根据终止的进程标识符，检索PCB，读取进程状态
        * 进程若处于执行就立马终止，将处理机资源分配给其他进程
        * 若还有子进程则终止子进程
        * 将该进程所拥有的所有资源归还给父进程或OS
        * 将PCB从所在队列（链表）中删除
* 进程的阻塞：
    * 引起的原因：
        * 正在执行的进程，由于期待某些事件未发生
        * 请求系统服务
        * 等待某种操作完成
        * 新数据尚未达到
    * 阻塞原语（Block）：
        * 找到要被阻塞进程的标识号对应的PCB
        * 若进程为运行，则保护现场，将状态转为阻塞，停止运行
        * 把该PCB插入等待队列中
* 进程的唤醒：
    * 引起的原因：
        * 等待的资源以到达可以调用
    * 唤醒原语（Wakeup）：
        * 在该等待队列中找到对应的PCB
        * 从等待队列中移除，状态置为就绪
        * 把PCB插入就绪队列中
* 进程切换：
    * 保存处理机上下文
    * 更新PCB信息
    * 把PCB移入相应队列
    * 选择另一个PCB，更新这个PCB的信息
    * 更新内存管理的数据结构
    * 恢复处理机上下文
* 调度是决策行为，切换时执行行为
## 进程通信
### 定义：
* 进程之间的信息交互
### 疑问？
* 为什么会有进程通信，不能直接访问吗？
* 进程是分配系统资源的单位（包括内存地址空间）因此各进程拥有内存地址空间相互独立。
* 为保证安全，一个进程不能直接访问另一个进程的地址空间
* 但是为了让他们可以安全通信，OS提供了一些方法
### 低级通信：
* PV操作
* 基于数据结构的共享
### 高级通信：
* 共享存储
* 消息传递
    * 传递结构化的消息（消息头、消息体）
    * 系统提供“发送、接受原语”
    * 两种方式：
        * 直接通信：
            * 消息直接挂到接收方的消息队列里
        * 间接通信【信箱通信方式】：
            * 消息先发到中间体（信箱）
* 管道通信：
    * 设置一个特殊的共享文件（管道），其实就是一个缓冲区
    * 一个管道只能实现半双共通信
    * 实现双向同时通信要建立两个管道
    * 各进程要互斥访问管道
    * 写满时，不能再写，读空时，不能再读。
    * 没写满，不能读，没读空，不能写
    * 必须提供的协调能力
        * 互斥，同步和确定对方存在
## 线程：轻量级进程
### 什么是线程，为什么要引入线程？
* 可把线程理解为轻量级进程
* 线程是一个基本的CPU执行单元，也是程序执行流的最小单位
* 好处：
    * 引入线程后，进程之间可并发，进程内的各线程之间也可以并发，提升了系统的并发度
    * 而且线程与线程的切换不一定发生资源调度，平均开销小。
    * 被系统独立调度和分派的基本单位，不拥有自己的资源（只有一点在运行中必不可少的资源）
    * 若线程也有自己的资源那么线程间的切换也需要较大的时空开销，提出来的意义就不大
### 线程的属性：
* 线程是处理机调度的单位
* 多CPU计算机中，各个线程可占用不同的CPU
* 每个线程都有一个线程ID，线程控制块（TCP）
* 线程也有就绪、阻塞、运行三种基本状态
* 线程几乎不拥有系统资源，仅有少数运行中必不可少的资源
* 由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预
* 一个基本的cpu执行单元
### 进程与线程的比较：
* 线程是独立调度的基本单位；进程是拥有资源的基本单位
### 线程的优势：
* 使操作系统具有更好的并发性，提供系统吞吐量
* 同一进程中的线程切换，不会引起进程切换，系统开销小
### 实现方式：
* 用户级线程：
    * 所有工作都由应用程序完成，内核意识不到线程的存在
* 内核级线程：
    * 所有工作由内核完成，应用程序没有进行线程管理的代码
* 多线程模型：
    * 多对一模型：
        * 特点：
            * 多个用户级线程映射到一个内核级线程
        * 优点：
            * 优点：线程管理在用户空间进行，不需要切换到核心态，线程管理的系统开销小，效率高。
        * 缺点：
            * 当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并发运行【一个线程被阻塞，其余的也被阻塞了】
    * 一对一模型：
        * 特点：
            * 每个用户级线程映射到一个内核级线程
        * 优点：
            * 并发能力强
        * 缺点：
            * 创建线程开销大，影响性能
    * 多对多模型：
        * 特点：
            * 集二者之长，n个用户级映射到m个内核级（n>m）
        * 优点：
            * 克服了多对一模型并发度不高的缺点
            * 克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。
## 调度的基本概念
### 目的：
* 合理处理计算机软硬件资源
### 调度概念：
* 对处理机进行分配，从就绪队列中，按一定的算法（公平，高效）选择一个进程将处理机分配给它，实现进程并发执行
* 三级调度的联系
    * 作业调度是为进程活动做准备，进程调度使进程正常活动起来，中级调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间
### 调度的三个层次：
* 作业（高级）调度
    * 内存与辅存之间的调度，频率低
* 中级（内存）调度
    * 为了提高内存利用率，将暂时不用运行的从内存中调出，将需要运行调入内存。
* 进程（低级）调度
    * OS中最基本的调度，调度频率很高
### 三层调度的联系，对比：
* 高级调度：
    * 外存--->内存【面向作业】
    * 发生频率：最低
* 中级调度：
    * 外存--->内存【面向进程】
    * 发生频率：中等
* 低级调度：
    * 内存--->CPU
    * 发生频率：最高
### 补充知识：
* 为减轻系统负载，提高资源利用率，暂时不执行的进程会被调到外存从而变成“挂起态”
* 七状态模型：在五状态模型的基础上加入了“就绪挂起”和“阻塞挂起”两种状态
### 调度时机、切换与过程
* 不能进行调度与切换的情况
    * 在处理中断的过程中
    * 进程在操作系统内核程序临界区中
    * 其他需要完全屏蔽中断的原子操作过程中
* 应当进行调度和切换的情况
    * P52
    * 进程的正常、非正常终止
    * 时间片用完，使用权被高优先级的紧急进程抢走。
* 考点：
    * 进程在操作系统内核程序临界区中不能进行调度与切换
        * 这里特指内核xxx
    * 进程处于临界区时可以进行处理机调度
        * 这里时一般情况，如打印机一直处于xx，不进行处理机调度不是浪费了吗，所以可以的
### 进程调度方式
* 剥夺调度方式（抢占式）
    * 有更重要或更紧迫的进程需要使用处理机时，则立即停止当前执行的进程
* 非剥夺调度方式（非抢制式）
    * 只允许进程主动放弃处理机
    * 优先权、短进程优先、时间片原则
    * 对提高系统吞吐率和响应效率都有明显的好处
## 调度基本准则\度量单位
### 确保cup繁忙：
* cpu利用率      =
    * 忙碌时间/总时间
### 系统吞吐量：
* 单位时间内完成作业的数量
* 系统吞吐量=总共完成了多少道作业/总共花了多少时间
### 周转时间：
* 周转时间、平均周转时间
    * 周转时间
        * 作业提交给系统开始到作业完成为止的这段时间间隔
    * 平均周转时间
        * 各个作业周转时间之和/作业数
* 带权周转时间、平均带权周转时间
    * 带权周转时间
        * （作业提交给系统开始➖作业完成）/作业实际运行的时间
    * 平均带权周转时间
        * 各个作业带权周转时间之和/作业数
### 等待时间：
* 进程处于等待处理机状态时间之和
### 响应时间：
* 从用户提交请求到系统首次产生响应所用的时间
## 调度算法
### 先来先服务（FCFS）：
* 利于CPU繁忙，不利于I/O繁忙【不懂！！！】
    * 不利于IO繁忙的解释：
        * IO繁忙的作业，在等待CPU。突然IO请求可以进行了，进行IO请求，放弃了等待CPU。
        * 下一次它就要重新排队了，前面白排队了。
        * 如果反复这样，非常不利于它获得CPU资源
    * 利于cpu繁忙的解释：
        * CPU等待谁谁就上
* 算法规则：
    * 按照作业/进程到达的先后顺序进行服务
* 用于作业/进程调度：
    * 作业调度：考虑的是谁先到到达后备队列
    * 进程调度：考虑的是谁先到达就绪队列
* 是否可抢占：
    * 非抢占式
* 优缺点：
    * 优点：
        * 公平、算法实现简单
    * 缺点：
        * 排在长作业后面的短作业需要等很久，带权周转时间大，对短作业用户体验不好。
        * 简而言之：对长作业有利，对短作业不利
* 是否会导致饥饿：
    * 不会
### 短作业（SJF）优先
* 算法思想：
    * 追求最少的平均等待时间，最少平均周转时间，最少的平均平均带权周转时间
* 算法规则：
    * 最短的作业/进程优先得到服务【所谓最短是指要求的服务时间最短】
* 用于作业/进程调度：
    * 即可用于作业调度，也可用于进程调度，用于进程调度时称为短进程优先算法
* 是否可抢占：
    * 是非抢占式，但是也有抢占式的版本----最短剩余时间优先算法【SRTN】
* 优缺点：
    * 优点：
        * 最短的平均等待时间、平均周转时间
            * 如果进程是几乎同时到达的话就对。
            * 王道书上写的不准确
    * 缺点：
        * 不公平。对短作业有利，对长作业不利。可能产生饥饿现象。
        * 另外作业/进程的运行时间由用户提供的，并不一定真实，不一定能做到真正的短作业优先
* 是否会导致饥饿：
    * 会。如果有源源不断地短作业/进程来到，可能使长作业/进程长时间得不到服务，导致饥饿
### 高响应比（FCFS和SJF的综合）：
* 算法思想：
    * 综合考虑作业/进程的等待时间和要求服务的时间
* 算法规则：
    * 在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务
    * 响应比=（等待时间+要求服务时间）/（要求服务时间）
    * 这里的等待时间，是当前等待cpu权限的时间。【它是进程运行完毕后再释放资源的，所以之前没有获得CPU的使用权】
* 用于作业/进程调度：
    * 即可用于作业调度，也可用于进程调度
* 是否可抢占：
    * 非抢占式算法，当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比
* 优缺点：
    * 综合考虑了等待时间和运行时间【要求服务时间】
* 是否会导致饥饿：
    * 不会
### 优先级调度：
* 选优先级最高的
* 静态优先级：
    * 创建进程时确定优先级，运行期间不变
* 动态优先级：
    * 进程运行时，根据进程情况动态挑战
### 时间片轮转调度：
* 算法思想：
    * 公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应
* 算法规则：
    * 按照各进程到达就绪队列地顺序，轮流让各个进程执行一个时间片。时间片执行完毕，剥夺处理机，将进程重新放到就绪队列队尾重新排队
* 用于作业/进程调度：
    * 只用于进程调度
    * 你想一下，进入了内存，才可以为你分配处理机时间片呀
* 是否可抢占：
    * 抢占式，由时钟装置发出时钟中断来通知CPU时间片已到
* 优缺点：
    * 优点：公平、响应快、适用于分时操作系统
    * 缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度
* 时间片的长短由以下因素确定：
    * 系统的响应时间
    * 就绪队列中的进程数目
    * 系统的处理能力
* 是否会导致饥饿：
    * 不会
### 优先级调度算法：
* 算法思想：
    * 根据任务的紧急程度来决定处理顺序
* 算法规则：
    * 调度时选择优先级最高的作业/进程
* 用于什么调度：
    * 可用于作业调度、可用于进程调度、可用户IO调度
* 是否可抢占：
    * 抢占式、非抢占式都有
* 优缺点：
    * 优点：用优先级来区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程地偏好程度
    * 缺点：若源源不断的高优先进程来到，可能会导致饥饿
* 如何设置优先级？
    * 通常：
        * 系统进程优先级高于用户进程
        * 前台进程优先级高于后台进程
        * OS更偏好IO型进程
### 多级反馈队列
* 算法思想：
    * 时间片轮转和优先级调度的综合
* 算法规则：
    * 设置多个就绪队列，不同优先级，第一级优先级最高。每次进程执行完后就挂到下一级的队尾
    * 各个队列的时间片也不同。第一级最短，第二级是第一级的2倍依此类推
* 用于作业/进程调度：
    * 用于进程调度
* 是否可抢占：
    * 抢占式
* 优缺点：
    * 对各类型进程相对公平
    * 每个新到达的进程都可以很快就得到响应，短进程只用较少的时间就可以完成
    * 不必事先估计进程的运行时间【避免用户作假】
    * 可灵活地调整对各类进程地偏好程度：
        * 如CPU密集型进程、IO密集型进程
        * 可以将因IO而阻塞地进程重新放回原队列，这样IO型进程就可以保持较高优先级
* 优势：
    * 终端型作业，短作业优先
    * 短批处理作业，周转时间短
    * 长批处理作业：经过前面几级得到了部分执行，不会长期得不到执行
* 
### 总结：
* 优先级调度适合实时操作系统
* 高响应比，时间片轮转，多级反馈队列适合分时操作系统
## 进程同步
### 为协调进程之间的相互制约关系，引入进程同步的概念
### 临界资源：
> 为保证临界区的正确使用，可把临界资源的访问过程分成四个部分：

> 		do{

> 				entry section 			//进入区

> 				critical section		//临界区

> 				exit section			//退出区

> 				remainder section	//剩余区

> 		}while(true)

* 概念：把一次仅允许一个进程使用的资源称为临界资源
* 许多物理设备都属于临界资源
* 对临界资源都必须互斥进行，访问临界资源的那段代码叫临界区
### 同步：
> 描述进程间的关系？

> 

* 也叫直接制约关系，源于进程间的相互合作
### 互斥：
> 描述资源的使用？

> 

* 也叫间接制约关系（对资源的使用）

# 信号量机制
## 信号量机制
### 信号量机制实现进程互斥：
* 分析并发进程的关键活动，划定临界区
* 设置互斥信号量mutex，初值为1
* 在临界区之前执行P(mutex)
* 在临界区之后执行V(mutex)
* 对不同的临界资源要设置不同的信号量
### 信号量机制实现进程同步：
* 分析什么地方需要实现同步关系，即必须保证“一前一后”执行的两个操作
* 设置同步信号量S，初始为0
    * semaphore S = 0
* 在必须要执行的之前的操作完成之后执行V(S)
    * 进程A和B需要同步，A要在B之前执行。A执行后进行V操作，释放xx，告诉B可以执行了
    * B在执行之前看A是不是完成了，申请xx，如果A完成了，会提供一个xx，xx从0变成了1，B看到xx是可以申请到了，知道A完成了，B可以正常执行。
    * 即使是B先执行，B会因为P操作申请不到xx，而阻塞，无法推进。
* 在必须要执行的之后的操作完成之前执行P(S)
### 信号量机制实现前驱关系：
* 为每一对前驱关系设置一个同步变量
* 执行所需的PV操作
* 
## 进程互斥同步问题
### 生产者消费者问题：
* 问题描述：
    * 有一组生产者和一组消费者，共享一个初始为空，大小为n的缓冲区，生产者消费者互斥访问，balabala
* 我的疑问：
    * 他的变量为什么这么定义？我有点不太理解
    * 还有，这个互斥资源什么时候PV比较好？
* 疑问回答：
    * 生产者需要消耗缓冲区数量，消费者需要拿产品，都用同一个变量不好用信号量操作。用两个变量，信号量好操作。如果代码实现，一个变量也行？加锁就可以？
    * 进程同步要在互斥之前。如果先执行互斥，会导致我拿到了权限却没有资源拿，一直阻塞。
* 解题思路：
    * 分析关系，找出同步互斥关系
* 解答过程：
    * 消费者、生产者互斥访问
    * 消费者拿东西，生产者生产，同步关系
* 注意点：
    * 实现互斥的P操作一定要在同步的P操作之后，否则可能发生死锁。
### 多生产者，多消费者：
* 理清复杂的同步关系
* 把一前一后发生的事情看做是两种事情的前后关系
* 女儿、儿子拿的行为会触发父母放东西的行为
* 抽象成盘子变空触发放入水果事件
* 放入水果事件触发那水果的事件
* 
### 吸烟者问题：
* 可以生产多个产品的单生产者问题
* 用变量i实现轮流吸烟
* 若同步信号量至多只有一个的值为1，那么可以不设置互斥变量
### 读写者问题：
* 读者写者操作是互斥的
* 写者和写者是互斥的
* 读者与读者可同时访问
* 问题：
    * 如何保证多个读者可同时读文件？
        * 设置一个count记录有几个读进程。让第一个访问文件的读进程加锁。让读进程与写进程互斥访问。
        * count变量需要保证互斥访问
    * 如何思考解答：
        * 从事件的角度。什么事件触发了什么事件
        * 同步关系：
            * 写进程的完成会触发读进程。
            * 读进程都读取完毕了会触发写进程
            * 是写者优先还是读者优先？
                * 写者优先，让读进程不能源源不断地进来
                    * 核心是卡住读者进入，有写者想写东西时，不让读者进来。
                * 读者优先，只要有读者就不让写者进来
* 复杂互斥问题：
    * 核心思想在于设置了一个计数器count
    * 如果需要一气呵成，要想到互斥信号量
    * 如何解决写进程饥饿问题
    * 当遇到读者写者需要互斥，但是读者与读者不需要互斥时要想到读写者问题！
### 哲学家进餐问题：
* 每个进程需要持有两个及两个以上地临界资源
## 管程
### 为什么要引入管程？
* 解决信号量机制编程麻烦、易出错的问题
### 组成：
* 共享数据结构
* 对数据结构初始化的语句
* 一组可以用来访问数据结果的过程(函数)
### 基本特征：
* 各外部进程\线程只能通过管程提供的特点入口才能访问共享数据
* 每次仅允许一个进程在管程内执行某个内部过程
### 补充：
* 管程必须互斥访问管程的特性是由编译器实现的
* 可在管程种设置条件变量及等待、唤醒操作以解决同步问题
## 死锁的概念
### 什么是死锁：
* 在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。
### 进程死锁、饥饿、死循环的区别：
* 
### 死锁产生的必要条件：
* 互斥条件
    * 资源需要互斥使用
* 不剥夺条件
    * 进程所获得的资源在未使用完之前不能由其他进程强行夺走，只能主动释放
* 请求和保持条件
    * 进程已经保持了至少一个资源，但又提出了新的资源请求，对自己的资源又不释放。
* 循环等待条件
    * 注意：发生死锁时一定有循环等待，但是发生循环等待时未必有死锁
### 什么时候会发生死锁：
* 对系统资源的进程
* 进程推进顺序非法
* 信号量的使用不当
* 总结：对不可剥夺资源的不合理分配可能导致死锁
### 死锁的处理策略：
* 预防死锁：
    * 破坏死锁产生的四个必要条件
* 避免死锁：
    * 避免系统进入不安全状态【银行家算法】
* 死锁的检测和解除：
    * 允许死锁发生，系统负责检测出死锁并解除
## 死锁的处理
### 不允许死锁发生：
* 静态策略：
    * 破坏互斥条件：
        * 允许互斥资源可以共享，如共享打印机
        * 缺点：不是所有的资源都可以改造成共享的，有些资源必须保护这种互斥性
    * 破坏不可剥夺条件：
        * 进程的资源可被剥夺：
            * 方案一：进程申请新的资源得不到满足，则释放保持的所有资源
            * 方案二：某个进程需要的资源被其他进程占有时，操作系统选择好进程进行资源剥夺。
        * 缺点：
            * 实现起来比较复杂
            * 释放资源会导致进程前面的工作无效
            * 反复申请和释放资源会增加系统开销，降低系统吞吐量
            * 采用方案一可能导致进程饥饿，一直被剥夺资源，得不到执行
    * 破坏请求和保持条件：
        * 采用静态分配方法
            * 进程在运行前一次申请完他所需要的全部资源，资源未得到满足时不让它投入运行。
        * 缺点：
            * 可能会导致某些进程饥饿
            * 某些资源进程只需要使用很少的时间，整个运行期间却一直保持，资源利用率极低。
    * 破坏循环等待条件：
        * 给资源编号，必须按编号从小到大的顺序申请资源
        * 缺点
            * 不方便增加新设备；会导致资源浪费；用户编程麻烦
        * 
* 动态策略：避免死锁：
    * 安全序列：
        * 系统按照这种序列分配资源，则每个进程都能顺利完成。
    * 银行家算法：
        * 
### 允许死锁发生：
* 死锁的检测和解除：
    * 死锁的检测：
        * 死锁检测算法：
            * 用于检测系统状态，以确定系统中是否发生了死锁
        * 如何进行死锁检测？
            * ①用某种数据结构来保存资源的请求和分配信息
            * ②提供一种算法，利用上述信息来检测系统是否已进入死锁状态
            * 数据结构资源分配图：
                * 两种结点：
                    * 进程结点：对应一个进程
                    * 资源结点：对应一类资源，一类资源可能有多个
                * 两种边：
                    * 进程结点-->资源结点：表示进程想申请几个资源【每条边代表一个】
                    * 资源结点-->进程结点：表示已经为进程分配了几个资源【每条边代表一个】
                * 
    * 死锁的解除：
        * 死锁解除算法：
            * 当认定系统中已经发生了死锁，利用该算法可将系统从死锁中解脱出来
        * 用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程
        * 解除死锁的主要方法：
            * 资源剥夺法
            * 撤销进程法
            * 进程回退法

# 文件管理
## 概念
### 定义、属性、基本操作、打开与关闭
## 文件逻辑结构
### 无结构文件，又称流式文件
### 有结构文件：
* 各个记录应该如何组织起来：
    * 应该顺序存放
    * 还是用索引表来表示记录间的顺序
* 顺序文件：
    * 特点：逻辑上一个一个顺序排列【物理上就不知道了，可以顺序存储也可以链式存储】
    * 串结构：
        * 记录之间的顺序与关键字无关
            * 通常按记录存入的时间决定顺序
    * 顺序结构：
        * 记录之间的顺序按关键字顺序排列
    * 链式存储：
        * 无论是定长、可变长记录都无法实现随机存取，每次只能从第一个记录开始依次往后查找
    * 顺序存储：
        * 可变长记录：
            * 无法实现随机存取，只能从第一个开始向后找
        * 定长记录：
            * 可实现随机存取，记录长度位L，则第i个记录存放的相对位置是L*i
            * 若采用串结构，无法快速找到某关键字对应的记录
            * 若采用顺序结构，按关键字进行了排序，可快速找到（折半查找）
    * 最大缺点：不方便增加删除记录
* 索引文件：
    * 索引表中包含索引号，记录长度，记录所在磁盘的首地址
    * 可直接通过指针找到对应的数据，通过长度，找到结束位置。
    * 文件中的记录可以是离散存储的，因为我指针可以直接指向他们。每个记录抱持连续即可。
    * 若索引表按关键字排序，则可支持快速检索（二分查找）
    * 解决了顺序文件不方便增删记录的问题，同时让不定长记录的文件实现了随机存储，但是索引表可能占用很多空间
* 索引顺序文件：
    * 
    * 为文件建立索引表，但是是一组记录对应一个索引表项
        * 
        * 真题中设计逻辑结构、物理结构。逻辑结构上，按姓名建立索引顺序文件
        * 索引表中顺序查找，逻辑文件中顺序查找。10000的分成两个100的
        * 查找从（1+10000）/2变到了（1+100）/2 * 2
    * 如果文件数目过大，可以采用多级索引顺序文件，减少查找次数
        * 
    * 检索记录时先顺序查找索引表、找到分组、再顺序查找分组。
## 目录结构
### 文件控制块【实现文件目录的关键数据结构】
* 实现按名存取
### 目录结构：
* 单级：
    * 整个系统中只建立一张目录表，每个文件占一个目录项
    * 实现了按名存取，但是不允许重命名
* 两级：
    * 分为主目录和用户目录
    * 允许不同用户目录重命名
* 多级（树形目录结构）：
    * 每次从根目录开始查找效率很低
    * 设置当前目录，想要访问文件时从当前目录出发
    * 特点：方便分类，层次清晰，能有效地进行文件管理和保护
    * 缺点：不便于实现文件共享
* 无环图：
    * 用不同地文件名指向同一个文件【甚至是目录，共享同一目录下的所有内容】
    * 为每个共享结点设置一个共享计数器，计数器减为0时才删除结点
### 索引结点【对文件控制块的优化】:
* 减少FCB中不必要的信息，让一个磁盘块可存放更多的FCB
* 这样找按名称找文件的地址时要访问的磁盘块就少了
* 索引结点分类:
    * 存放在外存中的被称为外存索引结点
    * 调入内存后称为内存索引结点
        * 需要增加文件是否被更改，几个进程在访问等信息
## 文件系统的实现
### 层次结构：
* 用户结构
* 文件目录系统
* 存取控制模块
* 逻辑文件系统与文件信息缓冲区
* 物理文件系统
* 
### 目录实现：
* 目录的实现就是为了查找
* 基本实现方法：
    * 线性列表：
        * 对应线性查找
        * 采用链表结构可以减少删除文件的时间
    * 哈希表：
        * 对应哈希查找
        * 查找速度快，插入删除简单
### 文件实现：
* 文件分配：
* > 研究文件的物理结构，文件的数据如何在物理存储设备上分布的。

    * 连续分配：
        * 要求每个文件在磁盘上占有一组连续的块
        * 支持顺序访问和直接访问，连续分配的文件在顺序访问时速度最快
        * 不方便文件扩展；存储空间利用率低，反复增删会产生外部碎片
         * > 连续分配，只有连续的空间足够放下需要写入磁盘的文件时时，才会被分配出去。

        * FCB中包含文件的起始块号和长度
    * 链接分配：
        * 链接分配采取离散分配的方式，可以为文件分配离散的磁盘块。
        * 分类：
            * 隐式链接：
                * 指向下一个磁盘的指针存在磁盘块中。
                * 方便文件扩展，所有的空闲盘块都可以被利用，不会有碎片问题，外存利用率高
                * FCB中记录了起始块号和结束块号
            * 显示链接：
                * 链接各物理块的指针显式地存放在一张表中。文件分配表FAT。
                * FCB中只需记录起始块号，根据起始块号，去FAT表中查找下一块的地址
                    * 
                * 优点：方便文件拓展，不会有碎片问题，外存利用率高，且地址转换时不需要访问磁盘，因此文件的访问效率更高
                * 缺点：文件分配表要占用一定的存储空间
                * 注意一个磁盘仅设置一个FAT表
                * 开机时会将FAT读入内存并常驻内存
                * FAT的各个表项在物理上连续存储，且一个表项长度相同，因此物理块号字段可以是隐含的。
    * 索引分配：
        * 索引表存放的磁盘块叫索引块，文件数据存放的磁盘块叫数据块
        * FCB中存放的是索引块的地址，找到索引块读取出对应的索引表出来
        * 每个文件都会有自己的索引表。比起之前的FAT，所有盘块都加载进内存，不论是内存消耗还是表内查找都快了很多！
        * 索引链接：
            * 逻辑块号可以是隐含的，因为每个索引表项的大小是一样的，知道一个表项的长度就可以直接算出来第N各逻辑块号的地址！
            * 若文件太大，所需要的物理块多，一个磁盘放不下那么多的索引表项，就需要多个磁盘，磁盘的管理又是一个问题。
            * 
        * 多层索引：
            * 一级索引表、二级索引表xxxx
            * 缺点：即使是小文件，访问一个一个数据块依旧需要读多次IO
        * 混合索引：
            * 多种索引分配方式结合
        * 做题时注意顶级索引块是否调入了内存
* 文件存储空间管理：
    * 存储空间的划分与初始化：
        * 文件卷（逻辑卷）的概念
            * 为磁盘分区（C盘、D盘）
        * 目录区与文件区：
            * 目录区主要存放目录信息FCB、用于磁盘存储空间管理的信息
            * 文件区用于存放文件数据
        * 存储空间初始化将各个文件卷划分为目录区、文件区
    * 几种管理方法：
        * 空闲表法：
            * 有一个空闲盘块表，每个表项记录第一个空闲盘块号和空闲盘块数
            * 适用于连续分配方式
            * 分配连续的存储空间可以采用首次适应、最佳适应、最坏适应等算法
            * 回收时要注意表项的合并问题，相邻的空闲表合并
            * 
        * 空闲链表法：
            * 空闲盘块链：
                * 以盘块为单位组成一条空闲链
                * 系统保存链头、链尾指针
                * 分配时从链头开始一次摘下K个盘块分配，并修改空闲链的链头指针
                * 回收的盘块依次挂到链尾，并修改空闲链的链尾指针
            * 空闲盘区链：
                * 以盘区为单位组成一条空闲链
                * 系统保存链头、链尾指针
                * 找到合适的盘区分配或把几个盘区分配出去
                * 回收时，有相邻的空闲盘区就合并起来。
                * 可以一次摘一大片，效率高一些
            * 
        * 位示图法：
            * 二进制位对应一个盘块号
            * 字号位号的推导
            * 注意字号位号的开始
        * 成组链接法：
            * 一个磁盘块作为超级块
                * 超级块中记录了下一组空闲盘块数，和空闲块号
            * 
## 文件共享
### 基于索引结点（硬链接）：
* 各用户目录项指向同一个索引结点
* 索引结点中需要有链接计数count
* 某用户想删除文件时，只是删除该用户的目录项，且count--
* 只有count==0时才能真正删除文件数据和索引结点，否则会导致指针悬空
### 利用符号链实现（软链接）：
* 在一个Link型的文件记录中共享文件的存放路径
* 操作系统根据路径一层一层查找目录，最终找到共享文件
* 即使软链接指向的共享文件被删除，Link文件依然在，通过Link中的路径去查找共享文件会失败
* 访问共享文件时需要查询多级目录，会有多次磁盘IO，速度比硬链接慢。【硬链接直接找到对应物理块？】
## 文件保护
### 口令保护：
* 为文件设置一个口令，用户想要访问文件时需要提供口令，由系统验证口令是否正确
* 实现开销小，但口令一般存放在FCB或索引结点中（也就是存放在系统中）不太安全
### 加密保护：
* 用一个密码对文件加密，访问时需要解密
* 安全性高，但加密解密需要耗费时间【Eg异或加密】
### 访问控制：
* 用一个访问控制表（ACL）记录用户对文件的访问权
* 对文件的访问类型可分为：读、写、执行、删除等
* 实现灵活，可实现复杂的文件保护功能
* 即便ACL太大也可以进行缩减
    * 
## 磁盘
### 一次磁盘读/写操作所需要的时间：
* 寻找时间（寻道时间）：
    * 启动磁头臂--耗时s
    * 移动磁头--跨越一条磁道耗时m，共要跨n条
* 延迟时间：
    * 旋转磁盘，使磁头移动到指定扇区所需要的时间。--转速r，平均所需的延迟时间Tr = 1/2r。转半圈的时间。平摊分析
* 传输时间：
    * 从磁盘读出或写入数据所需的时间
    * 假设磁盘转速为r，此次读写字节数为b，每个磁道上的字节数为N
    * Tr = b/rN
        * b个字节存储在b/N个磁道上
        * 每读写一个磁道所需的时间刚好是转一圈所需的时间1/r
### 磁盘调度算法：
* 磁盘调度算法：
    * 先来先服务FCFS：
        * 先请求的先访问
        * 访问的磁道比较分散时，寻道时间长，性能差。
    * 最短寻找时间优先SSTF：
        * 优先处理离磁头最近的磁道，只选眼前最优
        * 可能会产饥饿
    * 扫描算法SCAN：
        * 算法描述：
            * 类似于电梯。只向一头移动，要移动到最外侧，即便是没有要处理的磁道请求，也要移动到最边上。
        * 改进：
            * 1、假设磁道从0-200，处理完184后没有更大的要处理，掉头就是，不用到最外侧
            * 2、从最左边到最右边的移动过程中，还处理了其他的磁道请求，导致掉头的过程慢。
        * LOOK调度算法（SCAN的改进）
            * 没有请求了，就直接掉头
    * 循环扫描算法C-SCAN：
        * 算法描述
            * SCAN算法的改进，掉头过程中不进行磁道处理（也是没有请求了直接掉头）
        * C-LOOK算法（循环C-SCAN的改进）
            * 循环C-SCAN的改进，掉头时不必到另一侧的最边上，到最边上的第一个需要处理的磁道即可
* 题目未指明算法：
    * SCAN算法就是LOOK算法：
        * 不会移动到最外面，直接掉头。掉头过程中会处理需要处理的磁道
    * C-SCAN算法就是C-LOOK算法：
        * 没有请求了，直接掉头到另一侧最靠近外边的需要访问的磁道，移动过程中不处理请求磁道
### 磁盘结构：
* 磁盘、磁道、扇区的概念：
    * 磁盘？
    * 磁道：一圈一圈的跑道
    * 扇区：磁道上的一部分
    * 越靠内的磁道存储密度越大
* 如何在磁盘中读写数据：
    * 磁头一道想要读写的扇区的磁道
    * 让目标扇区从磁头下面划过，完成读写操作
* 盘面、柱面的概念：
    * 一个盘片可能有两个盘面
    * 所有的磁头在一个磁头臂上，共进退
    * 柱面号（磁道）定位磁道。各个盘面的相同的磁道构成了柱面
    * 如何读取一个块的?
        * 先根据柱面号移动磁臂。
        * 激活指定盘面对应的磁头
        * 磁盘旋转过程中划过指定的磁道完成读写操作
* 磁盘的物理地址：
    * 柱面号、盘面号、扇区号
* 磁盘的分类：
    * 活动头磁盘：
        * 读写数据时要移动磁头，有寻道时间
    * 固定头磁盘：
        * 每个磁道都有一个磁头，无需移动磁头
### 减少延迟时间的方法：
* 如果磁盘连续编号。我们又要读取连续的磁盘的2、3号扇区
    * 磁盘需要一定的时间处理一块内容，不能连续不断的处理数据
    * 读完2号后，需要一定的时间处理数据，会错过读取3号扇区（磁头转过去了）
* 交替编号（逻辑相邻，物理不相邻）
    * 在物理上有一定的间隔，给予处理数据的时间
* 磁盘地址结构的设计
    * 思考？为什么磁盘的物理地址时（柱面号、盘面号、扇区号）而不是（盘面号、柱面号、扇区号）
    * 可以减少磁头移动，不同盘面的同一扇区记录文件，找下一个扇区时就不用移动磁头臂了，只要激活对应的磁头即可。
* 错位命名（减少延迟时间）
    * 就是给予充分的时间处理数据，不错过下一个扇区（即便是不同盘块也一样）
### 磁盘管理：
* 磁盘初始化：
    * 低级格式化
        * 将磁盘的磁道划分为扇区。采用特殊的数据结构，包括校验码
    * 磁盘分区
        * C、D、E盘
    * 逻辑格式化
        * 建立文件系统（建立根目录文件，建立用于存储空间管理的数据结构）
* 引导块：
    * 计算机启动时需要运行初始化程序（自举程序）来完成初始化
    * ROM中存放很小的自举程序
    * 完整的自举程序放在初始块（引导块）中
* 坏块：
    * 简单的磁盘
        * 逻辑格式化时将坏块标记出来
    * 复杂的磁盘
        * 磁盘控制器维护一个坏块链，并管理备用扇区
    * 对坏块处理的实质是使系统不去使用坏块

# 输入输出IO管理
## IO设备的基本概念与分类
### 什么是IO设备
* 将数据输入输出到计算机的设备
* UNIX系统将外部设备抽象为一种特殊的文件
### 按使用特性分类
* 人机交互类外部设备
    * 数据传输速度慢
* 存储设备
    * 数据传输速度快
* 网络通信设备
### 按传输速率分类
* 低速
    * 每秒几个-几百字节
* 中速
    * 每秒数千-上万字节
* 高速
    * 每秒数千字节-千兆字节
* 无明确的划分
### 按信息交换的单位分类
* 块设备
    * 传输速率较高，可寻址
* 字符设备
    * 传输速率慢，不可寻址，输入输出常采用中断驱动方式
    * 鼠标、键盘的向计算机输入数据，最先获得数据的是中断程序。【王道选择题】
## IO控制器
> 是CPU和设备的机械部件的中介关系

### 机械部件
### 电子部件（IO控制器、设备控制器）
### 
### 
### 功能：
* 接受和识别CPU发出的命令
    * 会有相应的控制寄存器来存放命令和参数
* 向CPU报告设备状态
    * 会设置状态寄存器判断IO设备当前的状态
* 数据交换：
    * 会设置相应的数据寄存器
    * 程序轮询方式和中断方式数据要从外存到CPU再从CPU到外存
* 地址识别
### 组成：
* CPU与控制器的接口
    * 实现控制器与CPU之间的通信
* IO逻辑
    * 负责接收和识别CPU的命令，并负责对设备发出命令
* 控制器与设备的接口
    * 实现控制器与设备之间的通信
### 值得注意的小细节：
* 一个IO控制器可能会对应多个设备
* 数据寄存器、控制寄存器、状态寄存器可能有多个。每个寄存器对应一个具体的设备。
### 两种寄存器编址方式：
* 内存映像I/O：
    * 寄存器的地址顺着内存的地址进行编址
    * 可以采用对内存进行操作的指令来对控制器进行操作
    * 
* 寄存器独立编址：
    * 控制器中的寄存器使用单独的地址
    * 需要设置专门的指令来操作控制器
    * 
## IO控制方式
### 
### 程序直接控制方式：
* 步骤
    * 1、CPU向控制器发出读指令，设备启动，状态寄存器设为未就绪
    * 2、轮询检查控制器的状态
    * 3、输入设备准备好数据后将数据传给控制器，并报告自身状态
    * 4、控制器将输入数据放到数据寄存器中，并将状态改为以就绪
    * 5、CPU发现设备已就绪，将数据寄存器中的数据读入CPU的寄存器中，再把CPU寄存器中的数据放入到内存
    * 6、继续读的话重复上面的步骤
* CPU干预频率太高了
* 
* CPU利用率低，CPU进行其他操作时，IO设备也不能做其他事，只能等CPU过来拿数据，利用率也低。
### 中断驱动方式：
* 引入中断机制
    * CPU不用一直轮询，发出指令后可以做其他事情。
    * IO设备准备好数据后，控制器向CPU发出中断信号，告诉CPU过来拿数据。
* 注意
    * CPU会在每个指令周期的末尾检查中断。
    * 中断处理过程需要保存、恢复进程的运行环境，这个过程是需要一定时间开销的。
    * 中断发生的频率太高也会减低系统性能。
* 
### DMA方式（直接存储器存取）：
* 数据传送单位是块
* 数据流向不经过CPU，不需要CPU作为快递小哥
* 仅在传送一个或多个数据块开始和结束时才需要CPU干预
* 也是一种IO控制器
    * DR、MAR、DC、CR
    * 
* 读入数据也是一个字一个字的读出写入哦！
* 
### 通道控制方式：
* 一种硬件，可理解为弱鸡版的CPU，在CPU坏了时，通道可暂为管理电脑【计组】
* 
* 
### 总结：
* 
## IO软件层次结构
### 用户层软件：
* 实现了与用户交互的结构、用户可直接使用该层提供的库函数
* 提供库函数
### 设备独立性软件【内核部分】：
* 提供系统调用接口
* 又称为设备无关性软件：
    * 与设备的硬件特性无关的功能几乎都在这一层实现
    * 选择题考点
* 主要实现的功能：
    * 向上层提供统一的调用接口
    * 实现设备的保护【访问权限】
    * 差错处理【对设备的错误进行处理】
    * 设备的分配与回收【多属于临界资源】
    * 数据缓冲区管理【解决传输速度的差异】
    * 建立逻辑设备名到物理设备名的映射关系【逻辑设备表】
        * 逻辑设备表【LUT】
            * 整个系统只设置一张，只适用于单用户OS
            * 为每个用户设置一张
            * 回忆单级目录和两级目录
### 设备驱动程序【内核部分】：
* 主要负责对硬件设备的具体控制
* 不同设备的硬件实现不一样，所以驱动程序也不一样
* 驱动程序一般会以一个独立进程的方式存在
* 设置设备寄存器，检查设备状态
### 中断处理程序【内核部分】：
* 进行中断处理
### 硬件：
* 执行IO操作，有机械部件、电子部件组成
### 设备驱动程序和中断处理程序都会直接和硬件打交道
### 
## IO调度
### 用某种算法确定一个好的顺序来处理各个IO请求
### 如磁盘调度
### 同理，打印机等设备也可以用先来先服务、优先级算法、短作业优先等算法来确定IO调度顺序
## SPOOLing系统【虚拟设备技术】
### 脱机：脱离主机控制进行的输入输出操作
### 脱机技术：
* 外围控制机+更高速的设备----磁带
* 作用：缓解设备与CPU的速度矛盾，实现预输入、缓输出
### 假脱机技术：
* 又叫SPOOLing技术，用软件的方式模拟脱机技术
* 输入井和输出井----模拟脱机输入输出时的磁带
* 输入进程和输出进程----模拟脱机输入/输出时的外围控制机
* 输入缓冲区和输出缓冲区----内存中的缓冲区，输入、输出时的中转站
### 共享打印机原理：
* 多个用户进程提出输出打印请求时，系统会接受他们的请求，但是并不是真正把打印机分配给他们，而是由假脱机管理进程，为每个进程做两件事。
* 在磁盘输出井中为进程申请一个空闲缓冲区，并将要打印的数据送入其中
    * 缓冲区是在磁盘上的
* 为用户进程申请一张空白的打印请求表，并将用户的打印请求填入表中，再将该表挂到假脱机文件队列上
* 当打印机空闲时，输出进程会从文件队列的队头取出一张打印请求表，并根据表中的要求将要打印的数据从输出井传送到输出缓冲区，再输出到打印机进行打印。
* 简而言之，设置缓冲区，暂存数据，之后直接从缓冲区中取数据。
## 缓冲区
### 缓冲区是一个存储区域，可由专门的硬件寄存器组成，也可利用内存作为缓冲区。
### 硬件寄存器成本太高，一般用内存作为缓冲区
### 缓冲区的作用：
* 缓和CPU与IO设备之间的速度不匹配问题。
    * 多数缓冲区好像都是缓解速度不匹配问题
* 减少对CPU的中断频率，放宽对CPU中断相应时间的限制
* 解决数据粒度不匹配的问题
* 提高CPU与IO设备之间的并行性
* 
### 单缓冲：
* 数据传输规则：
    * 缓冲区空时才可以向里面传输数据。
    * 缓冲区满时才可以把数据传出去。
* 计算处理一块数据要的时间：
    * 甘特图
    * 假定一个初始状态，分析下次达到相同状态需要多少时间。
    * 假设初始工作区满，缓冲区空
    * 
    * 
### 双缓存：
* 操作系统在主存中为其分配两个缓冲区【无特别说明都是一个缓冲区的大小就是一个块】
* 假设初始状态：工作区空，一个缓冲区满，一个缓冲区空
* 
* 
* 开始有一块数据，实在不行就画甘特图
### 使用单、双缓冲区在通信时的区别：
* 单缓冲区只能单向传输数据
* 若两个相互通信的机器设置双缓冲区，则统一时刻可以实现双向的数据传输
* 
### 循环缓冲区：
* 
### 缓冲池：
* 
* 三个队列：
    * 空缓冲队列、输入队列、输出队列
* 四种工作缓冲区：
    * 用于收容输入数据的工作缓冲区、用于提取输入数据的工作缓冲区
    * 用户收容输出数据的工作缓冲区、用于提取输出数据的工作缓冲区
## 设备分配
### 设备分配时应考虑的因素：
* 设备的固有属性：
    * 独占设备
        * 一个时间段只能分配给一个进程（如打印机）
    * 共享设备
        * 可同时分配给多个进程使用（如磁盘）
    * 虚拟设备
        * 采用SPOOLing技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用（如采用SPOOLing技术实现的共享打印机）
* 设备分配中的安全性：
    * 安全分配方式
        * 一个时间段内每个进程只能使用一个设备
            * 优点：破化了请求和保持条件，不会发生死锁
            * 缺点：对于一个进程来说，CPU和IO设备只能串行工作
    * 不安全分配方式
        * 一个进程可以同时使用多个设备
            * 优点：进程的计算任务和IO任务可以并行处理，使进程迅速推进
            * 缺点：有可能发生死锁
* 设备分配算法：
    * 静态分配
        * 运行前分配好所有需要的资源，运行结束后归还资源
    * 动态分配
        * 运行过程中动态申请设备资源
### 设备分配管理中的数据结构：
* 
* 设备控制表（DCT）
    * 
* 控制器控制表（COCT）
    * 
* 通道控制表（CHCT）
    * 
* 系统设备表（SDT）
    * 
### 设备分配的步骤：
* 系统设备表找设备控制表
* 设备控制表找到设备控制器表
* 设备控制器表找到通道
* 都是空闲分配，忙碌则挂到等待队列中
* 
* 缺点：
    * 用户编程时必须使用物理设备名，底层细节对用户不透明，不方便编程
    * 若换了一个物理设备，则程序无法运行
    * 若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待！
* 改进：
    * 具体步骤：
        * 根据进程请求的逻辑设备名查找SDT
        * 查找SDT，找到用户指定类型的、且空闲的设备，分配给该进程。
        * 在系统中设置一张逻辑设备表LUT，将逻辑设备转化为物理设备。
            * 
    * 用户编程使用逻辑设备名申请设备，操作系统负责实现从逻辑设备名到物理设备名的映射（通过LUT）
    * 逻辑设备表的设置问题：
        * 整个系统只有一张LUT：各用户的逻辑设备名不允许重复
        * 每个用户一张LUT：各个用户的逻辑设备名可重复
