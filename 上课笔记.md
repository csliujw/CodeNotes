# 学会查 API 使用类库

API：Application Program Implements 应用程序接口

- 一般学这个类怎么用（比如学习Scanner怎么用），是先百度查博客，或者看视频，看书，大致了解后，在考虑查官方文档。
- 查文档的步骤
    - 在索引里查询要用的类，如 Scanner
    - 查看这个类的说明
    - 如果都是静态方法则可以直接通过 **类名.方法名** 调用
    - 如果有非静态方法则需要实例化对象 `（类名 duix = new 类名）` 后，用实例对象调用方法（`对象.方法名()`）
        - new 对象的话，需要了解它的构造方法，
        - 然后决定，我们使用有参数的构造方法实例化对象呢，还是用没有参数的实例化对象呢？区别又在哪里。如果文档说的不清楚就百度，文档说的清楚就按文档说的做。

# String 习题

```java
/**
 * 通过查询 API 学会 String 类的使用
 * - 查 API ，先看类的介绍，看类的构造方法，从构造方法学习如何使用
 * - 查看方法，看那些方法可以完成我们的需求。
 * <p>
 * String 類主要用于串内容不可改变的字符串对象，即串一旦创建就不可改变（只读）
 * - 定义一个内容为 "hello world" 的字符串，打印出每个单词。
 */
public class _01_String {
    public static void main(String[] args) {
        _01_String string = new _01_String();
        string.other();
    }

    /**
     * * 需求：
     * * - 定义一个内容为 "hello world" 的字符串，打印出每个字符。
     * * ----h e l l o w o r l d
     * * <p>
     */
    public void fun1() {
        String str = "hello world";
        for (int i = 0; i < str.length(); i++) {
            if (str.charAt(i) != ' ') { // 为了输出好看点
                System.out.print(str.charAt(i));
            }
        }
    }

    /**
     * * - 定义一个内容为 "hello" 的字符串，和一个内容为 "Hello" 的字符串 比较这两个是否相等。
     * * ---- 直接 == 比较
     * * ---- 自己写代码进行比较
     * * ---- 查阅 API 找下比较的方法
     * * <p>
     */
    public void fun2() {
        String str1 = "hello";
        String str2 = "Hello";
        for (int i = 0; i < str1.length(); i++) {
            if (str1.charAt(i) != str2.charAt(i)) {
                System.out.println("不相等");
            }
        }

        // 直接调用 API 实现
        System.out.println("直接调用API实现字符串的比较 " + str1.equals(str2));
    }

    /**
     * * ---- hello world
     * * - 比较字符串大小（字典顺序）提一下
     * * ---- 比较 abc 和 abb 谁大
     * 我们规定后面的字母更大，即 b>c
     */
    public void fun3() {
        String str1 = "abc";
        String str2 = "abb";
        // a-a=0,  b-b=0, c-b=1 所以輸出1
//        System.out.println(str1.compareTo(str2));
        if (str1.compareTo(str2) > 0) {
            System.out.println(str1 + " 大");
        } else if (str1.compareTo(str2) < 0) {
            System.out.println(str2 + " 大");
        } else {
            System.out.println(str1 + "==" + str2);
        }
    }

    /**
     * String [] split()
     * int  indexOf(String str)
     */
    public void other() {
        String str = "hello world";
        String[] s = str.split(" ");// 按空格进行切分
        for (int i = 0; i < s.length; i++) {
            System.out.println(s[i]);
        }
        System.out.println("============================");
        System.out.println(str.indexOf('o')); // 从0开始数的
    }
}
```
# 继承
>继承的语法
extends 关键字
```java
class A{}
class B extends A{} // B 继承了 A，（A是B的父亲（父类或者说超类））
```
继承可以提高代码的复用性，原来同样的代码要写两次，用了继承后只需要写一次了。
```java
// 同样的方法写了两次，代码复用性不好。考虑用继承进行修改。
class Student {
    void eat() {
        System.out.println("eat");
    }


    void sleeps() {
        System.out.println("sleeps");
    }
}

class Teacher {
    void eat() {
        System.out.println("eat");
    }


    void sleeps() {
        System.out.println("sleeps");
    }
}
```

## 继承好处

- 提高了代码的复用性：多个类相同的成员可以放到同一个类中
- 提高了diamagnetic的维护性：如果功能需要修改，修改一处即可
- 让类与类直接产生了关系，是多态的前提
```java
public class _03_Extends {
    public static void main(String[] args) {
        Student student = new Student();
        student.eat();
        student.sleeps();
    }
}

// 继承实现代码复用
class Person {
    void eat() {
        System.out.println("eat");
    }


    void sleeps() {
        System.out.println("sleeps");
    }
}

// 子承父业，子类可以继承到父亲的所有非私有的成员变量和非私有的成员方法
class Student extends Person {

}

class Teacher extends Person {

}
```

## 特点

- 一个类只能有一个父类，不可以有多个父类
- Java 支持多层继承

```java
class A {
}

class B extends A {
}

class C extends B {
}
```

## 注意事项

- 子类只能继承父类所有非私有的成员（方法、变量）
- 子类不能继承弗雷的构造方法，但是可以通过 super 关键字访问父类的构造方法
- 不要为了功能而继承
- 注意：一般不使用继承，一般优先使用接口（interface）

## 注意
一般我们是能不用继承就不用继承，应为继承的耦合性太强；（讲到多态我再举例），一般我们是用组合（组合大于继承，就是优先使用组合）
>一个组合的案例
说白了，组合就是，比如有两个对象 Student 和 Person。我们把 Person 作为 Student 的成员变量，这就叫组合。两个类组合（把Person当作Student的组件）在一起使用
```java
public class _03_Extends {
    public static void main(String[] args) {
        Student student = new Student();
        student.person.sleeps();
        Teacher teacher = new Teacher();
        teacher.person.eat();
    }
}

// 组合的方式实现代码复用
class Person {
    void eat() {
        System.out.println("eat");
    }


    void sleeps() {
        System.out.println("sleeps");
    }
}

class Student {
    // Person 对象作为 Student 的成员变量，供 Student 使用
    Person person = new Person();
}

class Teacher {
    // Person 对象作为 Teacher 的成员变量，供 Teacher 使用
    Person person = new Person();
}
```

## 继承中成员变量的关系

- 子类父类同名和不同名的成员变量
- 结论：就近原则。
    - 现在子类局部访问找
    - 然后在子类成员范围找
    - 最后在父类成员范围找
    - 还没有就再向上一级找，知道不能找为止。

```java
class Zi extends Fu {
    public void say() {
        System.out.println(this.a1);
    }

    public static void main(String[] args) {
        Zi zi = new Zi();
        zi.say();
    }
}

class Fu extends Ye {
}

class Ye {
    int a1 = 100;
}
```

## super 关键字

- super的用法和this很像
    - this代表本类对应的引用。
    - super代表父类存储空间的标识(可以理解为父类引用)
- 用法(this和super均可如下使用)
    - 访问成员变量
        - this.成员变量 super.成员变量
    - 访问构造方法(子父类的构造方法问题讲)
        - this(…)        super(…)
    - 访问成员方法(子父类的成员方法问题讲)
        - his.成员方法()    super.成员方法()

```java
class Son extends Father {
    public static void main(String[] args) {
        Son son = new Son();
        System.out.println(son.fatherName);
        son.fatherSay();
    }
}

class Father {
    String fatherName = "father";

    public void fatherSay() {
        System.out.println("I am fa");
    }
}
```

## 继承中的关系

### 构造方法

* 子类中所有的构造方法默认都会访问父类中空参数的构造方法
* 为什么呢?
    * 因为子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化。
    * 每一个构造方法的第一条语句默认都是：super()
* 如何父类中没有构造方法，该怎么办呢?
    * 子类通过super去显示调用父类其他的带参的构造方法
    * 子类通过this去调用本类的其他构造方法
        * 本类其他构造也必须首先访问了父类构造
    * 一定要注意：
        * super(…)或者this(….)必须出现在第一条语句上
        * 否则，就会有父类数据的多次初始化，不合理（个人觉得比较合理的解释）

### 成员方法

* 方法重写概述
    * 子类中出现了和父类中一模一样的方法声明，也被称为方法覆盖，方法复写。
    * 使用特点：
        * 如果方法名不同，就调用对应的方法
        * 如果方法名相同，最终使用的是子类自己的
* 方法重写的应用：
    * 当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，又定义了子类特有的内容。
* 方法重写的注意事项
    * 父类中私有方法不能被重写
    * 子类重写父类方法时，访问权限不能更低
    * 父类静态方法，子类也必须通过静态方法进行重写。

## final 关键字

* final关键字是最终的意思，即赋值一次后，值不能再被修改。可以修饰类，成员变量，成员方法。
    * 修饰类，类不能被继承
    * 修饰变量，变量就变成了常量，只能被赋值一次
    * 修饰方法，方法不能被重写
* final关键字面试题
    * final修饰局部变量
        * 在方法内部，该变量不可以被改变
        * 在方法声明上，分别演示基本类型和引用类型作为参数的情况
            * 基本类型，是值不能被改变
            * 引用类型，是地址值不能被改变
    * final修饰变量的初始化时机
        * 在对象构造完毕前即可

# 多态

## 多态概述

> 某一个事物，在不同时刻表现出来的不同状态。

* 举例：
    * 猫可以是猫的类型。猫 m = new 猫();
    * 同时猫也是动物的一种，也可以把猫称为动物。
    * 动物 d = new 猫();
* 在举一个例子：水在不同时刻的状态

## 多态前提和体现

* 有继承关系
* 有方法重写
* 有父类引用指向子类对象

## 多态案例

* 按照前提写一个多态的案例

## 成员访问特点

* 成员变量
    * 编译看左边，运行看左边
* 成员方法
    * 编译看左边，运行看右边
* 静态方法
    * 编译看左边，运行看左边

## 多态的优缺点

> 优点

* 提高了程序的维护性(由继承保证)
* 提高了程序的扩展性(由多态保证)

> 缺点

* 不能访问子类特有功能
* 那么我们如何才能访问子类的特有功能呢?
    * 多态中的转型

## 转型

回忆数据的强制类型转换。

* 向上转型
    * 从子到父
    * 父类引用指向子类对象
* 向下转型
    * 从父到子
    * 父类引用转为子类对象
* 多态成员访问及转型的理解

## 猫狗案例练习多态版

* 不同地方饮食文化不同的案例
* Person
    * eat()
* SouthPerson
    * eat()
* NorthPerson
    * eat()

# 提一下抽象类、接口、匿名内部类

> 抽象类 有一些方法子类可以继承，但是有些方法只给方法名，没有具体的实现，要等子类自己去实现。（有些方法子类和父类一定不同，那这些方法就没必要在父类实现了）

```java
abstract class Demo {
    public abstract void say();
}
```

> 接口

- 为了能够向上转型为多个父类（代码更加灵活）
- 防止客户端程序员创建该类的对象，确保这仅仅是建立一个接口。
- 定义规则

```java
interface Demo2 {
    public abstract void say();
}
```

> 匿名内部类

```java
interface Int {
    void print();
}

class Demo {
    public static void main(String[] args) {
        new Int() {
            void print() {
                System.out.println("Int");
            }
        };
    }
}
```