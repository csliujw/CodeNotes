# 引言

## 学什么？

<b>思想/架构</b>（抽象、全局的思考）

- 操作系统为什么这么设计
- 多线程为什么这么设计

<b>实现/算法</b>

- 并发算法/相关数据结构
- 文件系统如何实现？内存回收如何处理？

<b>底层</b>（知其所以然，滴水不漏）

- 内核是怎么工作的？
- 进程/线程/程序在操作系统里是什么？

## 如何学？

- 理解作者的设计意图
  - 为什么要设计它，为什么这样设计，是为了解决什么问题？
- 理解实现方式
  - 如何实现的？
  - 瓶颈在哪里？
  - 如何优化？
- 理解底层算法和数据结构
- 理解更底层对硬件的管理和控制

##  资料

- 《操作系统》 --- 汤子赢、汤小丹
- 《现代操作系统》 -- Andrew S Tanenbaum
- 《操作系统概念》

# OS概述

## 什么是OS

操作系统是管理计算机软硬件资源的系统软件。它负责分配系统资源，对进程/线程进行调度，管理 OS 中的文件，管理内存等等。OS 的出现就是为了合理管理，分配计算机软硬件资源的。将这些资源抽象成服务，供程序使用。

- 管理硬件设备、资源以及应用程序（<b>管理能力</b>）
- 将硬件能力、资源抽象成服务让应用程序使用（<b>抽象能力</b>）

<b>开机-->BOIS-->引导程序-->操作系统</b>

<img src="os/os_abstract_01.png">



## OS的作用

### 发送/接收 硬件消息

如：键盘缓冲区【类似于环形队列】

### 管理、调度应用

应用之间保持隔离，互不干扰。

软件崩溃了，操作系统不应该崩溃。

交互式的 OS 需要可以与用户进行交换。

## 内核/内核设计

为什么要抽象出内核这么一个概念？

内核的概念：内核是连接操作系统和硬件、软件的桥梁，掌控着计算机中的一切资源。

<img src="os/os_infrastructure.png">

## 权限思考

### 没有权限控制

- 用户执行 `rm -rf /`
- 打印驱动程序改写中断向量表
- `QQ` 程序帮你关机

### 解决方案

- 权限拆分（端口权限、文件权限、操作权限）
  - 这对设计应用系统有所提示！
- 一个过程多态----区分【内核态】【用户态】

## 单内核VS微内核

<img src="os/single_vs_multicore.png">

## 内核的设计：B/S结构设计

<img src="os/core_bs.png">

##  微内核的优势

- 内核管的少，其他内容的自由性就强---即扩展性强。如调度算法、文件系统的扩展性

# 进程和多线程

## 基本概念

程序是数据，进程是运行的数据。

<img src="os/process01.png">

虚拟机与 OS：虚拟机也是在模拟 OS，不过 VM 模拟的范围更大

<img src="os/OS_VM.png">

## 进程的三态&中断响应

###  三态

- 阻塞：进程在等待某个外部信号（等待资源）
- 运行：正在执行的程序
- 就绪：进程在排队等待执行

### 中断响应

- ①保存当前状态，保证下次可继续执行
- ②跳转到操作系统处理中断响应的程序
- ③保存当前寄存器
  - 保存寄存器
  - 中断响应程序
  - 恢复寄存器
- ④设置新的栈指针
- ⑤执行中断服务程序（比如，申请了一个 IO 读取，则执行这个读取服务）
  - 决定下一次进程
- ⑥恢复 SP 和寄存器
- ⑦执行下一个进程

**总结：**

在切换前需要保存好状态，以便将来恢复。

无法指定马上执行那个进程，需要进行排队。

## CPU利用率

CPU 工作类别，处理 IO & 计算

<img src="os/mul_porcess.png">

这里他说的有问题，不是很对。如果都是计算型的程序，那么多道程序无法提高 CPU 的利用率，如果是 IO 程序+计算型程序，则可以提高 CPU 利用率。这部分的内容看看书。

## 线程的概念

进程之间的切换开销太大，如何解决？

引入线程。

一个进程可拥有多个线程，同一个进程中的线程之间共享进程的大部分信息。线程拥有自己的程序指针、堆栈、寄存器、状态字。

- 谁创建了线程
- 谁销毁了线程
- 谁调度线程

## 并发问题

### 基本概念

**竞争条件和临界区**

- 临界区：
  - 访问共享资源的程序片段
  - 且资源不能被同时使用（如打印机）
- 竞争条件
  - 程序的执行结果取决于临界区的精准时序

### 互斥

让程序不会同时进入临界区

<img src="os/mutual.png">

## 经典算法

### 互斥算法-严格轮换法

```c
// 初始化
int turn = 0;
// 进程1
while(true){
    while(turn != 0); // 死循环
    // 临界区
    turn = 1;
	// 非临界区
}

// 进程2
while(true){
    while(turn != 1); // 死循环
    // 临界区
    turn = 0;
    // 非临界区
}
```

这块讲的也很不好，还是得自己看书，讲的不清不楚。

# 调度算法

## 概述

多个线程竞争 CPU，【需要进行调度】

调度关心什么？

- 被调度任务的特征（计算密集型 VS IO 密集型）
- 执行时机
  - 新任务何时执行
  - 如何选择下一个任务，正常执行选择下一个/非正常执行选择下一个【顺序选择还是按优先级进行选择】
  - 发生中断时如何响应
- 调度算法（抢占式、非抢占式）

调度的通用目标

- “公平”
- 按规定策略强制执行
- 平衡：保持系统尽可能忙碌，充分利用计算机的资源（这块废话太多了）

不同系统的不同目标

- 批处理系统（吞吐量、周转时间、CPU 利用率）
- 交互式系统（响应性、体验）
- 实时系统（精准、稳定）

## 优先队列

又很多实现方式。数据结构课本中常用堆来实现。

自行看数据结构的书。

##   调度算法选讲

讲的很一般，不如直接看书。

# 内存管理

## 导学

### 分层存储体系

分层存储体系（Memory Hierarchy）

为了解决各级的速度不匹配问题，增加各种缓存。

<img src="os/memory.png">

### 存储器抽象模型

- 本质原因：资源的稀缺
- 解决方案：基地址 + 界限寄存器、交换技术、虚拟化技术
- 学习重点：学习别人是如何思考的

###  垃圾回收

- 引用计数垃圾回收
  - 普通引用计数法
  - 基于图的引用计数方法
- 跟踪垃圾回收
  - mark-sweep 算法
  - 三色标记法
- **重点**：理解主流语言（V8，Java，go）为何这样选择

### 需要学好什么

- 深层次理解性能和优化
- 数据结构和算法的运用
- 更好的理解平时用的计算机语言

## 地址空间

### 概述

Address Space

进程内存需要隔离（为了防止互相影响，导致无法正常执行）

- 物理隔离
- 逻辑隔离

为什么不允许应用接触物理内存？

- 防止应用破坏 OS
- 防止程序直接互相干扰

内存保护的方式

- 在 CPU 中设置一对上、下限寄存器，存放用户作业在主存中的下限和上限地址，每当 CPU 要访问一个地址时，先同他的两个寄存器对比，看是否越界。

- 采用重定位寄存器（基地址寄存器）

  <img src="os/memory_protect.png" style="width:50%">

存在的缺点

- 每次都需要做一次加法（+ 基地址寄存器）和一次比较（界限寄存器）
- 进程太多内存不够分怎么办（交换或虚拟内存）
- 如何优化

<span style="color:red">他这块说的又有问题。</span>“如果每个线程都有一个核还写什么并发程序”。并发编程是为了高效运行+数据安全，并不只是只有高效这一个点，还要考虑数据的安全性。

### 交换

- 概念：把不在执行的进程存回磁盘，腾出空间给其他进程。
- 问题：占用大量内存的进程如何高效的写入磁盘，高效的从磁盘复原进程？

## 虚拟内存

### 虚拟地址空间

如：将 `32kb` 的物理内存抽象为 `64kb`

页表（虚拟内存）表示 `64kb`，页表中的页表项指向物理内存（页框）。

页表是被加载到了物理内存中。我们用一小部分的物理内存存放页表。

<img  src="os/virtual_address.png">

page table 是虚拟地址

page frame 是物理地址

table --> frame 

- page 与 frame 的转换可以通过取余
- offset 直接表示偏移量，可以直接累加

页表项的结构

<img  src="os/page.png">

<b>举例</b>

<img src="os/page_example.png">

### 内存管理单元

内存管理单元 Memory Management Unit

通过 MMU 可以把虚拟内存映射到物理内存，那么每次都需要把虚拟内存映射到物理内存，性能如何保证？

`MMU` 位于 CPU 内部，可以通过硬件电路完成内存映射。

<img src="os/mmu.png">

### 缺页中断

<img src="os/miss_page.png">

### 多级页表更省空间

虚拟内存 32 位 4GB（每页 4KB）

一级页表 4GB/4KB  = 1M 个页表项

每个页表项 32位 = 32/8 = 4bit

一级页表占用内存 4bit*1M = 4MB

二级页表 10 10 12

每个页表项 32位 = 32/8 = 4bit

二级页表占用内存 

但是进程大小只有 40MB 的话，一级页表需要 4MB，二级页表可以只用其中的一部分，不用全部加载，所以用不了 4MB，大概是这个意思。

# 文件管理

## 文件系统和磁盘

### 常见的文件系统

FAT（File Allocate Table，文件分配表）

- FAT16、FAT32

Ext2（second extended file system）

NTFS（NT File System）日志文件系统，记录发生什么，而不是结果

### 文件和目录

目录是一种特殊的文件，它是用来对文件进行分类的。

- 目录中会有对一个或多个文件的引用。

### 磁盘

- 机械硬盘
- 固态硬盘

### 空闲物理块

基于链表的空闲管理（类比基于链表的内存管理）

基于位图的空闲块管理

### 魔数

用来区分文件类型的。

如 Java.class 文件，开头四个字节是 ： 0xCAFEBABE

DOS 可执行文件开头 0x00004550

## 文件和文件的表示

### 文件

磁盘上信息的一种抽象，把信息抽象成拥有名字的一个集合。

不同文件系统对文件的表示方法不同，但提供相似的操作接口（POSIX标准，Portable Operating System Interface）

### 文件的实现方式

- 连续分配：文件被分成若干个块，在磁盘上连续分配
  - 存在碎片化问题。需要碎片整理
- 链表分配：文件分成多个节点，用链表串起来
  - 节点尾部要存储下一个节点的位置。（这种叫隐式链接吗？）
- 内存中的链表分配（FAT），应该是按 FAT 32 进行计算的
  - 把节点的位置和下一个节点的位置存储在内存中。（这种叫显式链接吗？）
  - 内存中有一个FAT表，类似于数据结构中的静态链表。
  - 1T的硬盘，每个块 4K 需要多大的 FAT 表？
    - $1T = 2^{30} k$
    - 1T / 4k \* FAT32 = 1G 内存。需要的内存太大了。
    - $1T/4k = 表项数$  $表项数*每个表项占的大小（此处为FAT32） = 32MB*32=1024MB=1G$
- index-node（会有文件打开数量限制）
  - 一级索引，二级索引，三级索引，最后指向磁盘块。

## 共享文件和目录

目录也是文件！目录记录了文件的一些信息！

如：目录中记录了 文件的长度，属性，文件名，inode 指针。

文件共享

- 单级目录
- 多级目录

- 链接
  - 硬链接：存指针
  - 软链接：存路径，有寻址过程，效率较低。 