# 概述

实现基本的数据结构并掌握常用套路。

# 基础知识

## 时间复杂度

`O` \=\=\> 最坏情况的时间复杂度
`Θ`\=\=> 平均时间复杂度
`Ω`\=\=> 最好情况的时间复杂度

## 二分查找

### 时间复杂度

一次砍一半。$log_2N$。

### 二分的详细与扩展

- 在一个有序数组中查找某个数是否存在。
- 在一个有序数组中，找>=某个数最左侧的位置。
    - 1 2 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 6 7 7  找>=3最左侧的位置。依旧是可以二分。二分到某一个范围没有数了，就停。最左侧的就是我们要的。
- 局部最小值问题。
    - arr 无序，相邻的数一定不相等。求局部最小。局部最小：位置n的数，n-1>n; n+1>n
    - 先判断 start 和 end 位置的数据。如果 start 和 end 不是局部最小。意味着 start> start+1  end>end-1。（画一条数据高低的走向箭头）
    - 看那个区域存在局部最小，对这个区域进行二分。

## 位运算

得到二进制的最低位吧。

- 如何用位运算得到最低位：x & ((~x)+1) = x 的最低位

    ```shell
    # 假设x是 0111
    ~x = 1000
    ~x + 1 = 1001
    x&(~x)+1 = 1000 & 1001 = 0001 # 与操作，相同才为1
    ```

- 如何用位运算得到最低位：x & (-x) = x 的最低位

    - -x = ~x + 1

- 数状数组

    ```shell
            o
        o    o
    o   o  o  o
    1 2 3 4 5 6 7 8
    ```

    [树状数组详解 - Xenny - 博客园 (cnblogs.com)](https://www.cnblogs.com/xenny/p/9739600.html

## 异或

### 用法

满足交换律结合律。相同为0，不同为1。
<b>eg：a ， b 得在不同的内存空间。</b>
int a = 甲
int b = 乙
a = a ^ b ==> a = 甲^乙
b = a ^ b ==> b = 甲\^乙\^乙 = 甲^0 = 甲
a = a ^ b ==> a = 甲\^乙\^甲 = 乙^0 = 乙

### 习题

一种数出现了奇数次，其他的都出现了偶数次，如何找出这个出现奇数次的数。

`1^2^3^3^4^4^4^3^3^4` 就可以了。可以把异或当成无进位加法。

数组中两种数出现了奇数次，其他的都出现了偶数次，如何找出这个两种数。（ 时间复杂度 O(n) ）

一个数与上自己取反加 1，就可以把最右侧的 1（二进制表示）拿到了。

## 排序

<b>选择排序：</b>从无序序列中选择一个最小（大）的确定它的位置，缩小无序数组的范围。

<b>冒泡排序：</b>两两交换，将无序数组中，最小（大）的放到有序序列中。

<b>插入排序：</b>0\~0范围有序，0\~1范围有序，0\~2范围有序 ... etc。类似于打扑克，给自己的扑克从大到小排好序。

- 想在 0~i上有序 for循环
- 在 0~i 上实现有序 for循环

<b>归并排序：</b>整体就是一个简单递归，左边排好序，右边排好序，再让整体有序

```java
public static void mergeSort(int[] arr){
    if(arr==null || arr.length<2){
        return;
    }
    process(arr,0,arr.length-1);
}

public static void process(int[] arr,int L, int R){
    if(L==R) return;
    int mid = L + ((R-L)>>1);
    process(arr,L,mid);
    process(arr,mid+1,R);
    merge(arr,L,mid,R);
}

public static void merge(int[]arr, int L, int M, int R){
    int[]help = new int[R-L+1];
    int i=0;
    int p1 = L;
    int p2 = M + 1;
    while(p1<=M && p2<=R){
        help[i++] = arr[p1]<=arr[p2]?arr[p1++]:arr[p2++];
    }
    while(p2<=R){
        help[i++] = arr[p2++];
    }
    for(i=0;i<help.length;i++){
        arr[L+i] = help[i];
    }
}
```

## 对数器

- 有想测试的方法
- 实现一个复杂度不好，但是容易写出来的方法。
- 实现一个随机样本生成器
- 把方法 a 和方法 b 跑同样的随机样本，看结果是不是一样。
- 如果结果不一样，就打印数据，看看哪里出错了。
- 若样本数很多时，对比测试仍然正确，则可以确定方法 a 是正确的。

# 递归

## 求最大值例题【7.09】

数值溢出。L+（(R-L)>>1） 或者 ((L+R)>>>1) Java 无符号右移。

## 剖析递归行为

用递归方法找一个数组中的最大值，系统上到底怎么做？[17.04]

> master 公式的使用：$T(N) = a*T(N/b) + O(N^d)$

$log(b,a) > d$  复杂度为$N^{log(b,a)}$

# 数组

## 数组基础

- 优点：查询快。scores[2]
- 最好应用于“索引有语意”的情况。
- 但并非所有语义的索引都适用于数组。

## 实现数组

实现一个动态数组，有基本的增删改查功能。

## leetcode

### 剑指offer 03. 数组中重复的数字

在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

<b>示例 1：</b>

```
输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 
```

<b>限制：</b>

```
2 <= n <= 100000
```

> 解法

- 法一：先排序，再顺序遍历，看当前元素和下一个元素是否重复；O(NlogN)
- 法二：哈希表判重；O(N)
- 法三：利用题目的特点，数字都在 0~(n-1) 范围内
    - 把 0 放到 0 位置，1 放到 1 位置，如果在把 n 放到 n 位置上时发现 n ==arr[n] 说明元素重复了

> 法一：排序+遍历

```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        Arrays.sort(nums);
        for(int i=0;i<nums.length-1;i++){
            if(nums[i]==nums[i+1]){
                return nums[i];
            }
        }
        return -1;
    }   
}
```

> 法二：hash 判重

```java
public int useMap(int[] nums) {
    HashSet<Integer> set = new HashSet<>(); // HashSet 判重更方便
    for (int i = 0; i < nums.length; i++) {
        if (!set.add(i)) {
            return nums[i];
        }
    }
    return -1;
}

// 也可以自己开个大数组当 Map
public int map(int[] nums) {
    int[] map = new int[nums.length + 1];
    for (int i = 0; i < nums.length; i++) {
        if (++map[nums[i]] > 1) return nums[i];
    }
    return -1;
}
```

> 法三：利用题目特点，数据的范围都在 0~index 之间

[0,2,1,3,1]  --> [0,2,1,3,1] --> [0,1,2,3,1] -->[0,1,2,3,1] --> [0,1,2,3,1] 1 和 num[1] 发现 1 重复了。

```java
public int findRepeatNumber(int[] nums) {
    // 遍历，把数据放到合适的位置
    for (int i = 0; i < nums.length; i++) {
        while (nums[i] != i) { // 数据和索引对不少号，则进行交换
            // 拿到数组中的元素i，把这个元素i放到索引i处
            if (nums[i] == nums[nums[i]]) return nums[i];
            else swap(nums, i, nums[i]);
        }
    }
    return -1;
}

private static void swap(int[] x, int a, int b) {
    int t = x[a];
    x[a] = x[b];
    x[b] = t;
}
```

### 03.不修改数组找出重复数字

在一个长度为 n+1 的数组里所有数字都在 1~n 范围内，不修改数组找出重复的数字。

> 思路

- Set 判重
- 开辟新数组，在新数组中进行查找
- 二分查找
    - 数字范围在 1~n 之间，那么重复的数字要么在 1~m 中，要么在 m+1~n 中。
    - 统计 1~m 中 他们在数组中出现的次数，如果出现次数>m，说明 1~m 这个范围内有重复数字，继续分成1\~k, k\~m

```java
/*
 * 在一个长度为 n+1 的数组里所有数字都在 1~n 范围内，不修改数组找出重复的数字。
 */
public int getDup(int[] arr) {
    int start = 1, end = arr.length - 1;
    // 统计 start ~ end / 2 范围内数字出现的次数
    int mid = start + end >> 1;
    while (start < end) {
        // 检索的位置始终是 start 到 mid 若是这个范围，则重置
        // start mid end
        if (search(arr, start, mid) > mid - start + 1) {
            end = mid;
            mid = start + mid >> 1;
        } else {
            // 若没找到，则也重置 start mid end
            start = mid + 1;
            mid = end;
        }
    }
    return end;
}

private int search(int[] arr, int start, int end) {
    int count = 0;
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] >= start && arr[i] <= end) {
            count++;
        }
    }
    return count;
}
```

### 剑指offer 04.二维数组中的查找

在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

<b>示例：</b>

现有矩阵 matrix 如下：

```shell
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
```

给定 target = 5，返回 true。
给定 target = 20，返回 false。

<b>限制：</b>
0 <= n <= 1000
0 <= m <= 1000

# 栈 & 队列

## 栈基础

- 一种线性结构
- 只能从一端（栈顶）添加元素，也只能从一端（栈顶）取出元素
- 后进先出 Last In First Out（LIFO）

> 应用

- Undo 操作（撤销）
- 程序调用的系统栈
- 括号匹配

## 队列基础

- 队列是一种先进先出的数据结构
- First In First Out（FIFO）

> 循环队列

- front == tail 的话，队列就为空。
- （tail + 1）% length == front 的话就队满了。
- 空出一个空间用来区分队空和队满。

```java
public class LoopQueue<E>{
    private E[] data;
    private int front,tail;
    private int size;
    
    // some code.
}
```

# 链表 & 递归

## 链表介绍

- 动态数据结构 
- 具有递归机制
- 辅助组成其他数据结构
- 数据存储在`节点（Node）`中

```java
class Node{
    E e;
    Node next;
}
```

```mermaid
graph LR
1-->2-->3-->null

```

- 优点：真正的动态，不需要处理固定容量的问题。
- 缺点：丧失了随机访问的能力。

## 数组与链表的对比

- 数组最好用于有索引有语意的情况
- 最大优点：支持快速查询
- 链表不适合用于索引有语意的情况
- 最大优点：动态

## 链表的操作

> 插入元素

head 指向当前链表的第一个节点（元素）

<img src="ds_img\20210419195432.png" width="60%">

`node.next = head`

`head = node`

> 中间插入元素

- 找到待插入索引的前一个结点。
- 如，你要在索引为 2 的位置插入元素，则你只需要从 head 走 1 步，则当前点的 next 就是索引为 2 的点。

<img src="ds_img/20210419201028.png" width="60%">

> 引入虚拟头节点进行操作更方便。

```java
package ds.list;

// 这个链表的实现 无虚拟头节点。
public class LinkedList<E> {
    private int size;
    // 指向链表的第一个元素
    private Node dummy;

    // 开始没有元素，所以是null。
    public LinkedList() {
        dummy = new Node();
        size = 0;
    }

    public int getSize() {
        return size;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public void addFirst(E e) {
        /<b>
         Node node = new Node(e);
         node.next = head;
         head = node;
         <b>/
        add(0, e);
        size++;
    }

    public void add(int index, E element) {
        if (index < 0 || index > this.size) throw new IllegalArgumentException("index should xx");
        // 如果是索引0插入的话。

        Node prev = dummy;
        for (int i = 0; i < index; i++) {
            prev = prev.next;
        }

        prev.next = new Node(element, prev.next);
        size++;
    }

    public void print() {
        Node tmp = dummy;
        while (tmp != null) {
            System.out.format("%d\t", tmp.element);
            tmp = tmp.next;
        }
    }

    public static void main(String[] args) {
        LinkedList<Integer> list = new LinkedList<>();
        list.addFirst(1);
        list.addFirst(2);
        list.add(2, 5);
        list.add(0, -1);
        list.print();
    }

    private class Node {
        public E element;
        public Node next;

        public Node(E element, Node next) {
            this.element = element;
            this.next = next;
        }

        public Node(E e) { this(e, null); }

        public Node() { this(null, null); }

        @Override
        public String toString() {
            return "Node{ element=" + element +", next=" + next +'}';
        }
    }
}
```

## 思路

- 笔试：时间复杂度低，一切为了时间复杂度。
- 面试：时间复杂度低，空间复杂度尽可能的低。
- 额外数据结构记录：哈希表
- 快慢指针

## 水题

- 反转单链表和双链表

## 非水题

代码【4-1：32：31】

<b>打印两个有序链表的公共部分</b> 

- 链表有序，有头指针 head1 head2，打印他们的公共部分。时间复杂度 O(N) 空间复杂度 O(1)

<b>判断链表是否是回文链表（以 Node 为最小单位）</b>

- 笔试直接用 stack 解题。
- 空间尽可能低。快慢指针。只把链表的一半数据入栈。
- 只用有限的几个变量。双指针，中间 Node 的 next 指向空，后半部分的next指针指向前面的元素。遍历判断回文串的时候，在把 next 指针复原。

<b>将单链表按某值划分成左边小，中间相等，右边大的形式。</b>

- 把单链表的 Node 放到数组里去，在数组里进行操作。
- 开几个哑节点。small_start, small_end; eq_start, eq_end; big_start, big_end; 再把这三个链表连起来。注意边界问题，不一定有大于某值的。

<b>复制含义随机指针节点的链表。leetcode 138。【1：51：15】</b>

- `map<oldNode,newNode>`存起来，然后再遍历map的值，通过oldNode的指针关系设置newNode的指针关系。
- 不用额外空间呢？old-->new-->old-->new-->old-->new 然后在设置 new 节点的 random 指针。

<b>两个链表相交（共用节点）</b>

- 判断有环无环：快慢指针、哈希表
- 找出入环的第一个节点：

    - 哈希表，判重即可。第一个遇到遍历两次的点就是入口节点。
    - 快慢指针，快指针每次走两步，慢指针每次走一步，快慢指针相遇后，快指针回到开头，然后！两个指针在走！每次都只走一步！相遇的那个点就是第一个入口节点！【看过就会】
- 额外空间：两个 stack，然后出 stack 对比。

## 递归

> 递归

- 本质上，将原来的问题，转化为更小的同一问题。
- 举例：数组求和。
    - Sum( arr[0...n-1] ) = arr[0] + Sum( arr[1...n-1] ) `<--` 更小的同一问题

```java
package ds.recursion;

public class Sum {
    public static int sum(int[] arr) {
        return sum(arr, 0);
    }

    // 计算arr[1...n]这个区间的所有数组的和
    private static int sum(int[] arr, int l) {
        // 递归边界
        if (l == arr.length) return 0;
        // 递归表达式
        return arr[l] + sum(arr, l + 1);
    }

    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5, 5, 6, 7, 6, 6, 5, 5, 6};
        System.out.println(Sum.sum(arr));
    }
}
```

> 链表具有天然的递归结构

<img src="ds_img\image-20210422195126858.png" width="50%">

解决链表中删除元素的问题。

```java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if (head == null)
            return head;
        // 分为head 和 head后面两部分。
        // 链表 = head + head后面的链表，删除值为val后的链表。一直递归。
        head.next = removeElements(head.next, val);
        return head.val == val ? head.next : head;
    }
}
```

> 递归函数的"微观"解读

递归调用：函数调用 + 系统栈空间

# 二叉树

## 树结构

- 树结构，高效！
- 二分搜索树
- 平衡二叉树：AVL；红黑树
- 堆：并查集
- 线段树；Trie（字典树，前缀树）

<img src="ds_img\image-20210422201752762.png" width="50%">

## 二叉树

- 动态数据结构

```java
class Node{
    E e;
    Node left; // 左孩子
    Node right; // 右孩子
}
```

- 二叉树
    - 有唯一的根节点
    - 天然的递归结构，每个节点的左子树也是二叉树，每个节点的右子树也是二叉树
    - 二叉树不一定是满的，一个节点也是二叉树，NULL 空也是二叉树

### 二叉树的遍历

用递归序理解二叉树的前、中、后遍历。

```mermaid
graph
1---2
1---3
2---4
2---5
3---6
3---7
```

1, 2, 4, 4, 4, 2, 5, 5, 5, 2, 1, 3, 6, 6, 6, 3, 7, 7, 7, 3, 1

先序（头左右）第一次遍历到节点就打印的，叫先序遍历==>1, 2, 4, 5, 3, 6, 7

中序（左头右）第二次遍历到节点才打印的，叫中序遍历==>4, 2, 5, 1, 6, 3, 7

后序（左右头）第三次遍历到节点才打印的，叫后序遍历==>4, 5, 2, 6, 7, 3, 1

#### 递归遍历模板

```java
public static void preOrderRecur(Node head){
    if(head == null) return;
    System.out.println(head.value+" ");
    preOrderRecur(head.left);
    preOrderRecur(head.right);
}

public static void inOrderRecur(Node head){
    if(head == null) return;
    inOrderRecur(head.left);
    System.out.println(head.value+" ");
    inOrderRecur(head.right);
}

public static void posOrderRecur(Node head){
    if(head == null) return;
    afterOrderRecur(head.left);
    afterOrderRecur(head.right);
    System.out.println(head.value+" ");
}

// 层序遍历
// 结点入队，判断其有无左右子树，有则左右子树入队。
// 层序遍历的题一般是从每层数据的输出下手。如打印之字型。
// 要熟悉常用的数据结构。 stack queue hash tree 并查集
public static void levelOrder(TreeNode root){
    if (root == null) return null;
    Queue<TreeNode> queue = new LinkedList();
    queue.offer(root);
    while (!queue.isEmpty()) {
        TreeNode tree = queue.remove();
        System.out.println(tree.val);
        if (tree.left != null) queue.add(tree.left);
        if (tree.right != null) queue.add(tree.right);
    }
}
```

#### 非递归遍历模板

前序遍历

- 先把一个节点压栈
- 从栈中弹出一个节点 cur
- 打印（处理）cur
- 先压右再压左（如果有）==>为什么是先右再左呢？因为是头左右。先压入右，再压入左，那么就是左先遍历。
- 周而复始


中序遍历（中序 ：头右左）

- 每棵子树整棵树左边界入栈
- 依次弹出的过程中，打印节点并对弹出节点右子树周而复始。
- 为什么这样就是中序呢？
    - 按左边界对数进行了分解。左头右（左头右（左头右））

后序遍历

- 有两个 stack，一个 stackA，一个 stackB（收集栈）。
- 从 stackA 中弹出 cur（当前节点）
- 把 cur 放入 stackB 中，并且，按先左再右的顺序把 cur 的left 和right 压入 stackA
    - 从 stackA 弹出来的时候，把弹出来的元素放入 stackB，然后把弹出元素的 left，right 放入 stackA 中。
    - 第二次会先拿到 right ，把 right 放入 stackB,.... 后才会把 left 放入 stackB。
    - 最后 cur、left、right 的遍历顺序是 left-->right-->cur ( 左右根 )
    - 后序遍历

> 代码模板

```java
public void preOrder(Node head){
    if(head!=null){
        Stack<Node> stack = new Stack<Node>();
        stack.push(head);
        while(!stack.isEmpty()){
            cur = stack.pop();
            System.out.println(cur.value);
            if(cur.right != null){
                stack.push(cur.right);
            }
            if(cur.left != null){
                stack.push(cur.left);
            }
        }
    }
}

public void posOrder(Node head){
    if(head!=null){
		Stack<Node> stack1 = new Stack<Node>();
		Stack<Node> stack2 = new Stack<Node>();
        stack1.push(head);
        while(!s1.isEmpty()){
            Node cur = stack1.pop();
        	stack2.push(cur);
            if(cur.left!=null) stack1.push(cur.left);
            if(cur.right!=null) stack1.push(cur.right);
        }
        while(!stack2.isEmpty()){
            System.out.println(stack2.pop().value+" ");
        }
    }
}

public void inOrder(Node head){
    if(head!=null){
        Stack<Node> stack = new Stack<Node>();
    	while(!stack.isEmpty() || head !=null){
            if(head!=null){
                stack.push(head);
                head = head.left;
            }else{
                head = stack.pop();
                System.out.print(head.value+" ");
            	head = head.rigth;
            }
        }
    }
}
```

### 水题

二叉树的前、中、后、层序遍历

- [x] 求二叉树的宽度
- 用队列，先放左再放右，弹出就打印。下面这棵二叉树最大宽度为3。

- 记录每层的节点数目即可。

    - 法一：哈希表记录节点属于第几层。
    - 自己想，也挺简单的。为 Node 添加一个 level 属性即可。再加点逻辑。


```mermaid
graph
1---2
1---3
2---4
2---5
3---6
3---null
5---7
```



## 二分搜索树

- 二分搜索树
    - 二分搜索树的每个节点的值大于左子树的所有节点的值，小于其右子树的所有节点的值。【<b>左边值小，右边值大</b>】
    - 每一颗子树也是二分搜索树。
    - 存储的元素必须有可比较性。‘
- 代码方面，以递归写法为主，非递归写法自行书写。
- BST 的递归比非递归实现简单。

<img src="ds_img\image-20211117181903310.png" width="60%">

### 插入

- 默认不包含重复元素！
- 如果想包含重复元素的话，只需要定义：
    - 左子树小于等于节点；或者右子树大于等于节点
    - 注意：之前讲的数组和链表是可以有重复元素的

```java
public void add(E e) {
    root = add(root, e);
}

// 为空时，才创建。这样递归条件就少了。
private Node add(Node node, E e) {
    if (node == null) {
        size++;
        return new Node(e);
    }
    if (e.compareTo(node.e) < 0) {
        node.left = add(node.left, e);
    } else if (e.compareTo(node.e) > 0) {
        node.right = add(node.right, e);
    }
    return node;
}
```

### 查找

```java
public boolean contains(E e) {
    return contains(root, e);
}

private boolean contains(Node node, E e) {
    if (node == null) return false;
    if (e.compareTo(node.e) == 0) return true;
    else if (e.compareTo(node.e) < 0) {
        return contains(node.left, e);
    } else {
        return contains(node.left, e);
    }
}
```

### 遍历

```java
// 二叉树的前序遍历
public void preOrder(Node node) {
    if (node == null) return;
    if (node != null) {
        System.out.println(node.e);
        preOrder(node.left);
        preOrder(node.right);
    }
}

// 二叉树的中序遍历
public void midOrder(Node node) {
    if (node != null) {
        midOrder(node.left);
        System.out.println(node.e);
        midOrder(node.right);
    }
}

// 二叉树的中序遍历
public void afterOrder(Node node) {
    if (node != null) {
        afterOrder(node.left);
        afterOrder(node.right);
        System.out.println(node.e);
    }
}
```

> 遍历图解

每个点都会被访问三次！前序是第一次就遍历！中序是第二次才遍历！后续是第三次才遍历！

<img src="ds_img\image-20210422210646650.png" width="50%">

前序遍历，第一次访问点时就遍历。中后同理。

<img src="ds_img\image-20210422210738450.png" width="50%">

# 图

内容：

- DFS 与 BFS
- 树与图的遍历，拓扑排序
- 最短路
- 最小生成树
- 二分图：染色法、匈牙利算法

## DFS & BFS

| -                   | 辅助数据结构 | 空间     | 特点                               |
| ------------------- | ------------ | -------- | ---------------------------------- |
| DFS（深度优先遍历） | stack        | O(h)     |                                    |
| BFS（宽度优先遍历） | queue        | $O(2^h)$ | 每次遍历一层，有一个最短路的概念。 |

如果需要在数据中找上下左右，那么可以用向量表示。注意：数组的坐标和数学上的坐标不一样。

```shell
# 上右下左
x = [-1,0,1, 0 ]
y = [ 0,1,0,-1]
# 每次用 for 枚举下四个方向
------------->y
|
|
↓
x
```

### DFS 深度优先

DFS 涉及到回溯和剪枝。DFS 用搜索树来理解。<b>回溯的时候要恢复现场。</b>

> 例题

给定一个整数 n，将数字 1∼n 排成一排，将会有很多种排列方法。现在，请你按照字典序将所有的排列方法输出。

输入格式：共一行，包含一个整数 n。

输出格式：按字典序输出所有排列方案，每个方案占一行。

数据范围：$1≤n≤7$

输入样例：

```
3
```

输出样例：

```
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```

思想很简单，画出一个搜索树：

```mermaid
graph 
root-->1_,_
root-->2_,_
root-->3_,_
1_,_-->1,2_
1_,_-->1,3_
1,2_-->1,2,3
1,3_-->1,3,2
2_,_-->2,1,_
2_,_-->2,3,_
2,1,_-->2,1,3
2,3,_-->2,3,1
3_,_-->3,1,_
3_,_-->3,2,_
3,1,_-->3,1,2
3,2,_-->3,2,1
```

开始在 index = 0 处放一个数据，然后在 index = 1 处放一个数据。回溯上去的时候，还原状态。

```java
import java.util.*;

public class Main{
    static int []marked = null;
    static int []path = null;
    
    public static void main(String[]args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        marked = new int[n+1]; path = new int[n];
        dfs(n,0);
    }
    
    private static void dfs(int n,int cur){
        if(cur == n){
            for(int i: path){ System.out.print(i+" ");}
            System.out.println();
            return;
        }
        // 枚举 1~n
        for(int i=1;i<=n;i++){
            if(marked[i]==0){//未被使用过
                marked[i] = 1;
                path[cur] = i; // 当前位置填上数字
                dfs(n,cur+1);
                marked[i] = 0;
            }
        }
    }
}
```

> n 皇后问题

n−皇后问题是指将 $n*n$ 个皇后放在 $n*n$ 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。

<img src="https://cdn.acwing.com/media/article/image/2019/06/08/19_860e00c489-1_597ec77c49-8-queens.png">

现在给定整数 n，请你输出所有的满足条件的棋子摆法。

输入格式：共一行，包含整数 n。

输出格式：每个解决方案占 n 行，每行输出一个长度为 n 的字符串，用来表示完整的棋盘状态。其中 `.` 表示某一个位置的方格状态为空，`Q` 表示某一个位置的方格上摆着皇后。

每个方案输出完成后，输出一个空行。

<b>注意：行末不能有多余空格。</b>

输出方案的顺序任意，只要不重复且没有遗漏即可。

数据范围： $1≤n≤9$

输入样例：

```
4
```

输出样例：

```
.Q..
...Q
Q...
..Q.

..Q.
Q...
...Q
.Q..
```

枚举每一行，皇后可以放到哪里，放之前判断下是不是可以放。

```java

```

### BFS 宽度优先

一般，边权是 1 时可以用 BFS。BFS 基本模板

```c
queue <- 初始数据入队
while queue 不空
    t <- 队头元素
    拓展 t
```

> 走迷宫

给定一个 n×m 的二维整数数组，用来表示一个迷宫，数组中只包含 0      或 1，其中 0 表示可以走的路，1 表示不可通过的墙壁。

最初，有一个人位于左上角 (1,1) 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。

请问，该人从左上角移动至右下角 (n,m) 处，至少需要移动多少次。

数据保证 (1,1) 处和 (n,m) 处的数字为 0，且一定至少存在一条通路。

输入格式：第一行包含两个整数 n 和 m。接下来 n 行，每行包含 m 个整数（0 或 1），表示完整的二维数组迷宫。

输出格式：输出一个整数，表示从左上角移动至右下角的最少移动次数。

数据范围：$1≤n,m≤10$

输入样例：

```
5 5
0 1 0 0 0
0 1 0 1 0
0 0 0 0 0
0 1 1 1 0
0 0 0 1 0
```

输出样例：

```
8
```

## 存储

邻接表，数组存链表，链表存储相邻节点。

邻接矩阵，用矩阵存储点与点之间的距离（边集）。

用熟悉的结构，把图的算法实现一遍。然后刷题遇到图的题时，把题目中的存储方式转换为自己经常用的。

```java
public class Graph{
    public HashMap<Integer,Node> nodes; // key 表示点的编号，Node 表示实际的点。
    public HashSet<Edge> edges;
    
    public Graph(){
        nodes = new HashMap<>();
        edges = new HashSet<>();
    }
}

public class Node{
    public int value;
    public int in; // 点的入度
    public int out; // 点的出度
    public ArrayList<Node> nexts; // 该 Node 的直接邻居有那些点
    public ArrayList<Edge> edges; // 属于 Node 的边。就是 A-->B 那么这条边就属于A，不属于B
    
    public Node(int value){
        this.value = value;
        in = 0;
        out = 0;
        nexts = new ArrayList<>();
        edges = new ArrayList<>();
    }
}

public class Edge{
    public int weight;
    public Node from;
    public Node to;
    
    public Edge(int weight, Node from, Node to){
        this.weight = weight;
        this.from = from;
        this.to = to;
    }
}

public static Graph createGraph(Integer[][] matrix){
    Graph graph = new Graph();
    for(int i=0;i<matrix.length;i++){
        Integer from = matrix[i][0];
        Integer to = matrix[i][1];
        Integer weight = matrix[i][2];
        if(!graph.nodes.containsKey(from)){
            graph.nodes.put(from,new Node(from));
        }
        if(!graph.nodes.containsKey(to)){
            graph.nodes.put(to,new Node(to));
        }
        Node fromNode = graph.nodes.get(from);
        Node toNode = graph.nodes.get(from);
        Edge newEdge  = new Edge(from,to,weight);
        fromNode.nexts.add(toNode);
        fromNode.out++;
        toNode.in++;
        fromNode.edges.add(newEdge);
        graph.edges.add(newEdge);
    }
    return graph;
}
```

## 遍历

图的宽度优先遍历，一个点出来的时候处理。

- 利用队列实现
- 从源节点开始依次按照宽度进队列，然后弹出
- 每弹出一个节点，把该节点所有没有进入队列的邻接点放入队列
- 直到队列变空

```java
public void BFS(Node node){
    if(node==null) break;
    HashSet<Node> marked = new HashSet<>();
    Queue<Node> queue = new LinkedList<>();
   	queue.add(node);
    marked.add(node);
    while(!queue.isEmpty()){
        Node cur = queue.poll();
        System.out.println(cur.value);
        for(Node next : cur.nexts){
            if(!marked.contains(next)){
                set.add(next);
                queue.add(next);
            }
        }
    }
}
```

深度优先遍历，一个点进出的时候处理。

- 利用栈实现
- 从源节点开始把节点按照深度放入栈，然后弹出
- 每弹出一个节点，把该节点下一个没有进过栈的邻接点放入栈
- 直到栈变空

```java
public void DFS(Node node){
    HashSet<Node> marked = new HashSet<>();
    Stack<Node> stack = new Stack<>();
    stack.add(node);
    marked.add(node);
    System.out.println(node.value);
    while(!stack.isEmpty()){
        Node cur = stack.pop();
        for(Node next:cur.nexts){
            if(!marked.containsKey(t)){
                stack.push(cur); // 重新把A压回去，因为A可能还存在其他邻居。（后面A没有邻居了，A就被直接pop，不会做任何操作）
                stack.push(next); // 再把邻居压入
                set.add(next);
                System.out.println(next.value); // 处理邻居
                break;
            }
        }
    }
}
```

## 拓扑排序

适用于：要求有向图，且入度为0的节点，且没有环。

具体应用：编译顺序。避免循环依赖/引用。

先看那个点是入度为 0 的点。把入读为 0 的点 A，及它的影响擦掉。这样就会有下一个入度为 0 的点。继续擦掉这个点和它的影响。

```java
public static List<Node> srotedTopology(Graph graph){
    // key: 某一个node
    // value：剩余的入度
    HashMap<Node,Integer> inMap = new HashMap<>();
    // 入度为0的点，才能进这个队列
    Queue<Node> zeroInQueue = new LinkedList<>();
    for(Node node:graph.nodes.values()){
        inMap.put(node,node.in);
        if(node.in == 0){
            zeroInQueue.add(node);
        }
    }
    // 拓扑排序的结果，依次加入result
    List<Node> result = new ArrayList<>();
    while(!zeroInQueue.isEmpty()){
        Node cur = zeroInQueue.poll();
        result.add(cur);
        for(Node next:cur.nexts){//每一个点擦除影响，后代可能会变为入度为0，可以继续擦除。
            imMap.put(next,inMap.get(next)-1); //cur邻居的入度-1
            if(inMap.get(index)==0){
                zeroInQueue.add(next);
            }
        }
    }
    return result;
}
```

## 最小生成树（无向图）

### kruskal

```shell
A-------B
|  \  / |  
|  /  \	|	 
C-------D
```

以边的角度出发，对边排序，每次找最小的边。加入边后没有形成环就加上。如果形成了环，就抛弃这个边，再看剩下的边。

- 对边排序，用堆，或直接排序。
- 判断是否形成环？用并查集。

```java
public static Set<Edge> kruskalMST(Graph graph){
    UnionFind unionFind = new UnionFind();
    unionFind.makeSets(graph.nodes.values());
    PriporityQueue<Edge> queue = new PriporityQueue<>(new EdgeComparator());
    for(Edge edge : graph.edges){ // 边入优先队列
        queue.add(edge);
    }
    Set<Edge> result = new HashSet<>();
    while(!queue.isEmpty()){
        Edge edge = quue.poll();
        if(unionFind.isSameSet(edge.from,edge.to)){
            resutl.add(edge);
            unionFind.union(edge.from,edge,to);
        }
    }
    return result;
}
```

### prim 算法

以点开始，找和这个点相邻的最短边，解锁边和边上的点。未被解锁的点和边集合 U；已被解锁的点和边 V（手动模拟下就清楚了。）

```java
public static Set<Edge> primMST(Graph graph){
    PriorityQueue<Edge> queue = new PriorityQueue<>(new EdgeComparator());
    HashSet<Node> set = new HashSet<>(); // 没有出现再这个set里面的，就是新的点
    Set<Node> result = new HashSet<>(); // 依次挑选 边再result 里
    for(Node node : graph.nodes.values()){//随便选一个点 (防止输入的图不是连通的)
        
        // node 是开始点
        if(!set.contains(node)){
            set.add(node);
            for(Edge edge : node.edges){ // 由一个点，解锁所有相连的边
                queue.add(edge);
            }
            while(!queue.isEmpty()){
                Edge edge = queue.poll();// 弹出解锁的边钟，最小的边
                Node toNode = edge.to; // 可能的一个新的点
                if(!set.contains(toNode)){ // 不含有的时候，就是新的点
                    set.add(toNode);
                    result.add(edge);
                    for(Edge nextEdge : toNode.edges){ 
                        queue.add(nextEdge)
                    }
                }
            }
        }
    }
    return result;
}
```

## 最短路

```mermaid
graph LR
最短路-->单源最短路
最短路-->多源最短路-->Floyd,n的3次方
单源最短路-->边权值都是正数
单源最短路-->存在负权边
边权值都是正数-->朴素Dijstra,n方
边权值都是正数-->堆优化版Dijstra,mlogn
存在负权边-->Bellman-Ford,nm
存在负权边-->SPFA,一般m,最坏nm
```

### Dijsktra

单源最短路径算法，即给定图 G 和七点 s，通过算法得到 S 到达其他每个顶点的最短举例。适用于没有权值为负数的环。一定要规定出发点。

Dijsktra 的基本思想：把图的点分为已访问和未访问。从未访问点中找出一个距离 S 最近的点 V，把 V 加入已访问的点集合。然后以 V 为中间点，看能不能更新 S -> other 点的距离。

```java
// 算法伪代码如下：
// g 为 图，d 为使源点到各个点的最短路径长度，start 为起点
public void dijsktra(Graph g, int[]d, int start){
    // 初始化
    for(循环n次){
        int u = min(d);
        marked[u] = true; // u已经被访问
        for(从u出发可以到达的所有顶点v){
            if(v未访问 && 以u未中介点使 s 到 v 的最短距离 d[v] 更优){
                优化d[v];
            }
        }
    }
}
```

> 代码模板，朴素 dijkstra，用邻接矩阵。

```java
public class Dijkstra {
    int N = 10086;
    int[][] graph = new int[N][N]; //
    int[] dist = new int[N]; //
    boolean[] isOk = new boolean[N];
	int max = 0x3f;
    
    int dijkstra() {
		Arrays.fill(dis,max);
        for (int i = 0; i <N-1 ; i++) {
            int t = -1;
            for (int j = 1; j <=N ; j++) {
                if(!isOk[j] &&(t == -1 || dist[t]>dist[j])) t = j;
            }
            // 用t更新其他点的距离
            for (int j = 1; j <= N; j ++ )
                dist[j] = Math.min(dist[j], dist[t] + graph[t][j]);

            isOk[t] = true;
        }
        if (dist[N] == max) return -1;
        return dist[N];
    }
}
```

ACwing 849 题

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class Main {
    static int N = 510;
    static int[][] g = new int[N][N];
    static int[] dist = new int[N];
    static boolean[] st = new boolean[N];
    static int n;
    static int max = 500000;

    static int dijkstra() {
        Arrays.fill(dist, max);
        dist[1] = 0;
        for (int i = 0; i < n - 1; i++) {
            int t = -1;
            for (int j = 1; j <= n; j++) {
                if (!st[j] && (t == -1 || dist[j] < dist[t])) t = j;
            }

            st[t] = true;
            for (int j = 1; j <= n; j++) {
                dist[j] = Math.min(dist[j], dist[t] + g[t][j]);
            }
        }
        if (dist[n] == max) return -1;
        else return dist[n];
    }

    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        String[] cur = in.readLine().split(" ");
        n = Integer.parseInt(cur[0]);
        int m = Integer.parseInt(cur[1]);

        //初始化g为正无穷，解决重边的问题
        for(int i=1; i<=n; i++) Arrays.fill(g[i], max);

        while(m-->0){
            String[] arr = in.readLine().split(" ");
            int a = Integer.parseInt(arr[0]);
            int b = Integer.parseInt(arr[1]);
            int c = Integer.parseInt(arr[2]);
			// 存在重复边，所以要 min
            g[a][b] = Math.min(c,g[a][b]);
            
        }
        System.out.println(dijkstra());
    }
}
```

> 代码模板，堆优化版 dijkstra

```cpp
typedef pair<int, int> PII;

int n;      // 点的数量
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储所有点到1号点的距离
bool st[N];     // 存储每个点的最短距离是否已确定

// 求1号点到n号点的最短距离，如果不存在，则返回-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});      // first存储距离，second存储节点编号

    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();

        int ver = t.second, distance = t.first;

        if (st[ver]) continue;
        st[ver] = true;

        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > distance + w[i])
            {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```

### Bellman-Ford & SPFA

Dijsktra 可以解决无负权图的最短路径问题，但是如果出现了负边的化就失效了。

```mermaid
graph LR
A--weight=-1-->B
A--weight=1-->C
C--weight=-5-->B
```

假设用 Dijsktra 算法求 A 到其他点的最短路径：

- A -> B 最近，于是 d[B] = -1
- 企图以 B 作为中间点到 C 的距离，但是 B 无法到达 C。A -> other 的优化更新完毕
- A -> C = 1，所有点均已经完成访问。d[C] = 1
- 但是，实际上，A->B 的最小距离是 A->C->B = 1+(-5) = -4。

我们考虑下环对最短路径的影响

- 零环：不会影响最短路径的求解。
- 正环：不会影响最短路径的求解。
- 负环：会影响最短路径的求解。

与 Dijsktra 相同， Bellman-Ford 算法设置一个数组 d，用来存放源点到各个点的最短路径距离。同事 Bellman-Ford 算法返回一个 bool 值：如果其中存在从源点可达的负环，那么函数返回 false；否则返回 true，此时数组 d 存放的就是从源点到各个点的最短路径距离。

Bellman-Ford 算法的主要思路如下：

```java
for(int i=0;i<-1;i++){ //n个顶点，执行 n-1 轮操作
    for(each edge u->v){ // 每轮操作遍历所有的边
		if(d[u] + length[u->v] < d[v]){ // 以 u 为中介点可以使 d[v] 更小
            d[v] = d[u] + length[u->v]; // 松弛操作
        }        
    }
}
// 算法复杂度 O(VE)
```

如果图中没有从源点可达的负环，则数组 d 中的所有值已经达到了最优。通过 d[u] + length[u->v] < d[v] 可以判断有从源点可达的负环。

```java
for(each edge u->v){
    if(d[u]+length[u->v] < d[v]){ // 说明还可以被更新，返回 false。
        return false;
    }
    return true; // 数组 d 的所有值都已经达到最优。 
}
```

> 代码模板

```cpp
int n, m;       // n表示点数，m表示边数
int dist[N];        // dist[x]存储1到x的最短路距离

struct Edge     // 边，a表示出点，b表示入点，w表示边的权重
{
    int a, b, w;
}edges[M];

// 求1到n的最短路距离，如果无法从1走到n，则返回-1。
int bellman_ford()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。
    for (int i = 0; i < n; i ++ )
    {
        for (int j = 0; j < m; j ++ )
        {
            int a = edges[j].a, b = edges[j].b, w = edges[j].w;
            if (dist[b] > dist[a] + w)
                dist[b] = dist[a] + w;
        }
    }

    if (dist[n] > 0x3f3f3f3f / 2) return -1;
    return dist[n];
}
```

> SPFA 模板

```cpp
int n;      // 总点数
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储每个点到1号点的最短距离
bool st[N];     // 存储每个点是否在队列中

// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1
int spfa()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    queue<int> q;
    q.push(1);
    st[1] = true;

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```



### Floyd

解决全源最短路径问题。

# 前缀树

举例：一个字符串类型的数组 arr1，另一个字符串类型的数组 arr2。
arr2 中有那些字符，是 arr1 中出现的？请打印。
arr2 中有那些字符，是作为 arr1 中某个字符串前缀出现的？请打印。
arr2 中有那些字符，是作为 arr1 中某个字符串前缀出现的？请打印 arr2 中出现次数最大的前缀。

经典的前缀树，字符是放在路上。

<img src="ds_img\image-20220118223248425.png">

> 前缀树数据结构

```java
public class TrieNode{
    public int pass;
    public int end;
    public TrieNode[] nexts; // HashMap<Char,Node> nexts;

    public TreeNode(){
        pass = 0;
        end = 0;
        /*
         nexts[0] == null 没有走向 ‘a’ 的路
         nexts[0] != null 有走向 ‘a’ 的路
         ...
         nexts[25] == null 没有走向 ‘z’ 的路
        */
        nexts = new TrieNode[26];
    }
}
```

> 前缀树代码

```java
public class Trie{
    private TrieNode root;
    public Trie(){
        root = new TrieNode();
    }
    public void insert(String word){
        if(word == null) return;
        char[]chs = word.toCharArray();
        TrieNode node = root;
        node.pass++; // 前缀为xx的字符串有多少的意思。
        int index = 0;
        for(int i=0;i<chs.length;i++){ // 从左往右遍历字符
            index = chs[i]-'a'; // 由字符，对应走向那条路
            if(node.nexts[index] == null) node.nexts[index] = new TrieNode();
            node = node.nexts[index]; // 拿到下一条路。通过这个 word 把这条路建完。
            node.pass++;
        }
        node.end++;
    }

    public void delete(String word){
		if(search(word)==0) return; // 不存在
        char[]chs = word.toCharArray();
        TrieNode node = root;
        node.pass--;
        int index = 0;
        // 遍历字符word，沿途的pass值--，最后的end值--
        for(int i=0;i<chs.length;i++){
            index = chs[i] - 'a';
            if(--node.nexts[index].pass == 0){ // pass 值为0了，意味着后面也没数据了，可以整体释放掉，设置为 null
                node.nexts[index] = null; // 直接下级节点标空。返回。
                return;
            }
            node = node.nexts[index];
        }
        node.end--;
    }
    
    // word 这个单词之前加入过几次
    public int search(String word){
        if(word==null) return 0;
        char[]chs = word.toCharArray();
        TrieNode node = root;
        int index = 0;
        for(int i=0;i<chs.length;i++){
            index = chs[i]-'a';
            if(node.nexts[index]==null) return 0; // 只存在这个的单词的一部分，return 0;
            node = node.nexts[index];
        }
        return node.end;
    }
    
    public int prefixNumber(String word){
        if(word == null) return 0;
        char[]chs = word.toCharArray();
        TrieNode node = root;
        int index = 0;
        for(int i=0;i<chs.length;i++){
            index = chs[i]-'a';
            if(node.nexts[index]==null){
                return 0;
            }
            node  = node.nexts[index];
        }
        return node.pass;
    }
}
```

# 数学知识

- 数论
- 组合计数
- 高斯消元
- 简单博弈论

## 数论

### 质数

质数：大于 1 的整数中，如果只包含 1 和本身这两个约数，就被称为质数。

质数的判定：试除法

```java
boolean isPrime(int n) {
    if (n < 2) return false;
    for (int i = 1; i < n; i++) {
        if (n % i == 0) return false;
    }
    return true;
}
```

质数的判断，优化，利用质数的性质。

````java
// 如果 d|n 则 n/d | n，只枚举 d ≤ n/d
boolean isPrime2(int n) {
    if (n < 2) return false;
    // 推荐这么写，时间复杂的 根号n。不推荐 sqrt(n)
    // 注意是 <= n/i
    for (int i = 2; i <= n / i; i++) {
        if (n % i == 0) return false;
    }
    return true;
}
````

### 分解质因数

分解质因数：试除法，从小到大枚举所有数。

[867. 分解质因数 - AcWing题库](https://www.acwing.com/problem/content/869/)

```java
static void divide(int n) {
    for (int i = 2; i <= n / i; i++) {
        if (n % i == 0) {
            int s = 0;
            while (n % i == 0) {
                s++;
                n /= i;
            }
            System.out.println(i + " " + s);
        }
    }
    if (n > 1) System.out.println(n + " " + 1);
    System.out.println();
}

public static void main(String[] args) throws IOException {
    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    int count = Integer.parseInt(reader.readLine());
    int[] nums = new int[count];
    for (int i = 0; i < count; i++) {
        nums[i] = Integer.parseInt(reader.readLine());
    }
    for (int i = 0; i < nums.length; i++) {
        divide(nums[i]);
    }
}
```

### 素数

[868. 筛质数 - AcWing题库](https://www.acwing.com/problem/content/870/)

朴素做法：打表，把 2 的倍数删除，3 的倍数删除，4 的倍数删除，n 的倍数删除。时间复杂度是调和级数。

```java
static boolean st[]; // 判断是否被筛掉了
static int[] nums; // 记录素数
static int cnt; // 记录素数的总个数

public static void get_primes(int n) {
    for (int i = 2; i <= n; i++) {
        if (!st[i]) { // 默认是 false，没有被筛掉的话
            nums[cnt++] = n;
            for (int j = i + i; j <= n; j += i) st[j] = true;
        }
    }
}
```

埃式筛法：把每个合数用它的质因子筛掉就可以了。（`O(N)loglogN`）

### 约数

试除法求约数。一个一个枚举就行。

```java
void get_divisors(int n) {
    ArrayList<Integer> list = new ArrayList<>();
    for (int i = 1; i <= n / i; i++) {
        if (n % i == 0) {
            list.add(i); // i 是一个约数，放进来。
            // n / i 可能也是一个约束，但是要判断下，避免 i * i = n 这种情况。
            if (i != n / i) list.add(n / i);
        }
    }
    list.sort(Comparator.reverseOrder());
    list.stream().forEach(System.out::println);
}
```

# 贪心算法

在某一标准下，优先考虑最满足标准的样本，最后考虑最不满足标准的样本，最终得到一个答案的算法。不从整体最优上加以考虑，所以做出的是某种意义上的局部最优解。
如何证明：局部最优 --?--> 整体最优。

## 解题套路

- 实现一个不依靠贪心策略的解法X
- 脑补出贪心策略A、B、C（可能就是重新写下比较器 + 用个堆）
- 用解法X和对数器，去验证每一个贪心策略，用实验测出来，看那个策略是对的。
- 不要纠结证明

## 贪心的证明

- 具有传递性，即
    - a. b ≤ b. a
    - b. c ≤ c.b
    - 则 a. c  ≤ c. a

## 常见习题

一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。给你每一个项目开始的时间和结束的时间，你来安排宣讲的日程，<b>要求会议室进行的宣讲的场次最多</b>。返回这个最多的宣讲场次。

```java
class BestArrange{
	static class Program{
        int start;
        int end;
    }
    public Program(int start, int end){
        this.start = start;
        this.end = end;
    }
    
    static class ProgramComparator implements Comparator<Program>{
        @Overried
        public int compare(Program o1,Program o2){
            return o1.end-o2.end;
        }
    }
    
    public static int bestArrange(Program[] programs, int timePoint){
        Arrays.sort(programs,new ProgramComparator());
        int result = 0;
        for(int i=0;i<programs.length;i++){
            if(timePoint<=programs[i].start){
                result++;
                timePoint = programs[i].end;
            }
        }
        return result;
    }
}
```

一块金条切成两半，是需要花费和长度数值一样的铜板的。比如，长度为 20 的金条，不管切成长度多大的两半，都要花费 20 个铜板。一群人想要分整块金条，怎么分最省铜板？
eg：给定数组 [10,20,30], 代表一共三个人，整块金条长度为 10 + 20 +30 = 60. 金条要分成 10，20，30三个部分。如果先把长度 60 的金条分成 10 和 50，花费 60；再把长度50的金条分成20和30，花费 50；一共花费 110 铜板。但是如果先把长度 60 的金条分成 30 和 30，花费60；再把长度 30 的金条分成 10 和 20，花费30；一共花费 90 铜板；输入一个数组，返回分割的最小代价。

【2，3，4，7，9，2】Huffman 树。【8.暴力递归1：58：00】

输入：正数数组 costs；正数数组 profits；正数数组 k；正数数组 m；
含义：

- consts[i] 表示 i 项目的花费
- profits[i] 表示 i 号项目在扣除花费之后还能挣到的钱（利润）
- k 表示你只能串行的最多做 k 个项目
- m 表示你的初始资金

说明：每做完一个项目，马上获得的收益，可以支持你去做下一个项目。
输出：你最后获得的最大利润【8.暴力递归2：14：00】

一个数据流中，随时剋取得中位数。大根堆+小根堆

N皇后问题。在 `N*N` 的棋盘上要摆 N 个皇后，要求任何两个皇后不同行、不同列，也不在同一条斜线上。给定一个整数n，返回n皇后的摆法有多少种。
n=1，返回 1
n=2 或 3，2 皇后和 3 皇后问题无论怎么摆都不行，返回 0
n=8，返回 92

```java
// 这个速度很慢
public class NQueens{
    public static int num1(int n){
        if(n<1) return 0;
        // 记录第 i 行 皇后放的位置（如：放在第i行的第j列）
        int[]record = new int[n];
        return process1(0,record,n);
    }
	
    // record[0...i-1]的皇后，任何两个皇后一定都不共行，不共列，不共斜线
    public static int process1(int i,int[]record,int n){
        if(i==n) return 1; // 找到了一种合理的摆法。即record[0...n-1]的皇后，任何两个皇后一定都不共行，不共列，不共斜线。
        int res = 0;
        for(int j=0;j<n;j++){
            // 当前 i 行的皇后，放在 j 列，会不会和之前 （0...i-1）的皇后，共行共列或共斜线。
            // 如果是，认为无效；如果不是，认为有效。
            if(isValid(record,i,j)){
                record[i] = j;
                res += process1(i+1,record,n);
            }
        }
        return res;
    }
    
    public static boolean isValid(int[] record,int i,int j){
        for(int k=0;k<i;k++){
            // 是不是共列，是不是共斜线。
            if(j==record[k] || Math.abs(record[k]-j)== Math.abs(i-k)){
                return false;
            }
        }
        return true;
    }
}
```

优化【8.暴力递归3：06：00】

# 暴力递归

暴力递归就是尝试
1、把问题转化为规模缩小了的同类问题的子问题
2、有明确的不需要继续进行递归的条件（base case）
3、有当得到了子问题的结果之后的决策过程
一定要学会如何去尝试，在局部下拆解的问题是对的就行，不要全局想怎么处理的。

## 常见习题

汉诺塔问题：打印汉诺塔从最左边移动到最右边的全部过程。
1）1~i-1  from-->other，
2）i	from --> to  先想办法把最后一个挪到 to 上去。
3）1~i-1 other-->to

```java
public static void hanoi(int n){
    if(n>0){
        func(n,"左","右","中");
    }
}

public static void func(int i.String start, String end, String other){
    if(i==1){
        System.out.println("Move 1 from"+start+" to "+end);
    }else{
        func(i-1,start,other,end);
        System.out.println("Move "+ i +" from"+start+" to "+end);
        func(i-1,other,end,start);
    }
}
```

# 动态规划

[Codeup新家 (hustoj.com)](http://codeup.hustoj.com/contest.php?cid=100000678)

参考的算法笔记动态规划部分的内容。主要介绍 DP 的经典模型。

动态规划：将一个复杂的问题分解成若干个子问题，通过综合子问题的最优解来得到原问题的最优解。DP 会将每个子问题的解记录下来，当下一次碰到通用的子问题是，可以直接用记录下的结果。

DP 可以用递归会递推的写法来做。递归的写法称为记忆化搜索。

## 递归写法

斐波那契数列为例：斐波那契数列的定义为 $F_0=1,F_1=1,F_n = F_{n-1}+F_{n-1}$

```java
public class FDemo {
    int[] dp = new int[100 + 1];

    int F(int n) {
        if (n == 0 || n == 1) return 1;
        return F(n - 1) + F(n - 2);
    }

    // 计算量明显小了很多。
    int FWithMemory(int n) {
        // 记忆化搜索
        if (n == 0 || n == 1) return 1;
        if (dp[n] != 0) return dp[n];
        else {
            dp[n] = FWithMemory(n - 1) + FWithMemory(n - 2);
            return dp[n];
        }
    }

    @Test
    public void test1() {
        long start = System.currentTimeMillis();
        System.out.println(F(70));
        long end = System.currentTimeMillis();
        System.out.println(end - start);
    }

    @Test
    public void test2() {
        long start = System.currentTimeMillis();
        System.out.println(FWithMemory(70));
        long end = System.currentTimeMillis();
        System.out.println(end - start);
    }
}
```

### 数塔问题

计算从第一层到最底层的最大距离。

<img src="img\image-20220315234815103.png">

5->8->7，然后枚举 7 到最底层的所有路径；5->3->7 又会枚举 7 到最底层的所有路径。重复枚举了。

## 阎式DP分析法

DP一般用于求某个集合的最大值、最小值、总个数

寻找某个状态，用状态表示一类东西。

- 状态表示（每个状态表示一类东西）
    - 集合是什么，即这个状态表示那一类东西。
    - 属性（状态表示这个集合的那种值、最大、最小、数量）

- 状态计算（集合的划分）

> <b>举例</b> `LeetCode` `53 Maximum Subarray`

-2  1  -3  4  -1  2  1  -5  4

- 状态表示 f[i]
    - 集合 所有以i结尾的字段
    - 属性 Max/Min/数量，`此题求的Max`
- 状态计算 -- 集合的划分 `每个f[i]如何算出来`
    - `以i结尾的最大值 = f[i-1] + nums[i]  即以i-1结尾的最大值+nums[i]`
    - `f[i] = max(f[i-1],0) + nums[i]`

```java
package leetcode;

public class _53_maxSubArray {
    public static void main(String[] args) {
        _53_maxSubArray maxSubArray = new _53_maxSubArray();
        int[] array = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
        System.out.println(maxSubArray.max(array));
    }

    public int max(int[] nums) {
        int res = Integer.MIN_VALUE;
        int last = 0;
        for (int i = 0; i < nums.length; i++) {
            int now = Math.max(last, 0) + nums[i];
            res = Math.max(res, now);
            last = now;
        }
        return res;
    }
}
```

> <b>举例</b> `LeetCode 120 Triangle`

给定一个三角形 triangle ，找出自顶向下的最小路径和。

每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。

就是只能向下直走，或者向右侧走。

- 状态表示
    - 集合 所有从起点走到第i行，第j个数的路径
    - 属性 所有路径上的数的和的最小值
- 状态计算 -- 集合的划分 
    - `类Ⅰ：最后一步从左上下来 f[i-1,j-1] + nums[i,j]`
    - `类Ⅱ：最后一步从右上下来 f[i-1,j] + nums[i,j]`
    - `两类最小值取一个min Math.min(类Ⅰ,类Ⅱ)`

直接 DP，它的空间复杂度是 $O(n^2)$，但是我们可以发现，第 i 层，只用到了 i-1 层的信息，因此可以用滚动数组来做。

```java
public int minimumTotal(List<List<Integer>> triangle) {
    int n = triangle.size();
    int[][] dp = new int[n][n];
    dp[0][0] = triangle.get(0).get(0);

    for (int i = 1; i < n; i++) {
        // <=i的原因好像是避免一个问题。当前点上方的dp[i-1][j] == 0的情况，
        for (int j = 0; j <= i; j++) {
            int nums = triangle.get(i).get(j);
            dp[i][j] = 0xfffffff;
            if (j > 0) dp[i][j] = Math.min(dp[i][j], dp[i - 1][j - 1] + nums);
            if (j < i) dp[i][j] = Math.min(dp[i][j], dp[i - 1][j] + nums);
        }
    }
    int retVal = 0xfffffff;
    for (int i = 0; i < n; i++) {
        retVal = Math.min(retVal, dp[n - 1][i]);
    }
    return retVal;
}
```

> <b>举例</b> `LeetCode unique Paths Ⅱ`

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png)


- 状态表示
    - 集合：`所有从起点走到（i，j）的路径`
    - 属性：`数目`
- 状态计算
    - `最后一步向下走：f[i-1，j]`
    - `最后一步向右走：f[i，j-1]`

# 集合和映射

## 集合

- 不能重复添加元素
- 典型应用：客户统计、词汇量统计
- 可以使用二分搜索树作为集合的底层实现。
- Java 中的 Set 底层的数据结构采用的红黑树。

> 有序集合和无序集合

- 有序集合中的元素具有顺序性，<\=\=\=\=\=基于搜索树实现
- 无序集合中的元素没有顺序性，<\=\=\=\=\=基于哈希表实现

## 映射

$f(x)=2*x+1$ 或者称为字典

- 数据库；id---->信息
- 词频统计，单词---->频率
- 存储（键，值）数据对的数据结构
- 根据 key 查找 value

