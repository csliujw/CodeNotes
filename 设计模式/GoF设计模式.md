# 学习导读

## 为什么学设计模式

> 作者的经历

但是，有一天，我的leader让我开发一个跟业务无关的比较通用的功能模块，面对这样稍微复杂的代码设计和开发，我就发现我有点力不从心，不知从何下手了。因为我知道只是完成功能、代码能用，可能并不复杂，但是要想写出易扩展、易用、易维护的代码，并不容易。

如何分层、分模块？应该怎么划分类？每个类应该具有哪些属性、方法？怎么设计类之间的 交互？该用继承还是组合？该使用接口还是抽象类？怎样做到解耦、高内聚低耦合？该用单例模式还是静态方法？用工厂模式创建对象还是直接new出来？如何避免引入设计模式提 高扩展性的同时带来的降低可读性问题？……各种问题，一下子挤到了我面前。

为什么要学习设计模式相关的知识，总结一下的话，主要有这样五点：

- 应对面试中的设计模式相关问题；
- 告别写被人吐槽的烂代码；
- 提高复杂代码的设计和开发能力； 
- 让读源码、学框架事半功倍；
- 为你的职场发展做铺垫

> 讨论题

1. 聊一聊你对设计模式相关知识的重要性的看法； 

   1）利用读懂框架源码，理解它为什么这么写，这么写的优势在哪里。

   2）增强代码的可拓展性，方便功能的扩展。

   3）其他的暂时没感觉。

2. 在你过往的项目开发中，有没有用过某种设计模式？是在什么场景下应用的？解决了什么问题？

   1）我没写过真实项目，但是用过一些设计模式

   2）工厂方法，获取对象。当时用这个设计模式是为了用而用，还是感觉很鸡肋，仔细想想没啥必要。

   3）装饰模式，当时用这个设计模式是为了增强类的方法，且不想用继承，这种做法是有必要的，可以减少耦合。

   4）动态代理，统一增强方法，当初用这个是因为会这个设计模式且不想用装饰模式。这个我是不是用复杂了？

## 评价代码质量

> 为什么评价代码质量难？

评价代码质量是很难量化。会受工程师的水平，习惯等因素的影响。即对一段代码的质量评价，常常有很强的主观性。

> 代码评价的标准这么多，常用的需要多关注的评价标准有那些？

几个最常用的、最重要的评价标准：可维护性、可读性、可扩展性、灵活性、简洁性（简单、复杂）、可复用性、可测试性。这些标准之间会存在一定的重叠~

> 可维护性

代码易维护就是指，在不破坏原有代码设计、不引入新的 bug 的情况 下，能够快速地修改或者添加代码。

那如何来判断代码可维护性的好坏呢？

如果 bug 容易修复，修改、添加功能能够轻松完成，那我 们就可以主观地认为代码对我们来说易维护。这样的评价方式很主观，正如上面所说的，对一段代码的质量评价，常常有很强的主观性。

> 可读性

可读性可简单理解为：代码是否符合编码规范、命名是否达意、注释是否详尽、函数是否长短合适、模块划分是否清晰、是否符合高内聚低耦合等等。代码的可读性好，维护起来也方便些。

> 可扩展性

代码预留了一些功能扩展点，你可以把新功能代码，直接插到 扩展点上，而不需要因为要添加一个功能而大动干戈，改动大量的原始代码。

从我学习，使用，阅读Spring源码、及源码文档上的注释的时候深有体会，Spring在这点上做的很好！

> 灵活性

很抽象，仅列举场景，请自行思考~

​	1）当我们添加一个新的功能代码的时候，原有的代码已经预留好了扩展点，我们不需要修改原有的代码，只要在扩展点上添加新的代码即可。这个时候，我们除了可以说代码易扩展，还可以说代码写得好灵活。 

​	2）当我们要实现一个功能的时候，发现原有代码中，已经抽象出了很多底层可以复用的模 块、类等代码，我们可以拿来直接使用。这个时候，我们除了可以说代码易复用之外，还可以说代码写得好灵活。 

​	3）当我们使用某组接口的时候，如果这组接口可以应对各种使用场景，满足各种不同的需求，我们除了可以说接口易用之外，还可以说这个接口设计得好灵活或者代码写得好灵活。

从刚刚举的场景来看，如果一段代码易扩展、易复用或者易用，我们都可以称这段代码写得 比较灵活。所以，灵活这个词的含义非常宽泛，很多场景下都可以使用。

> 简洁性

尽量保持代码简单，同上面的评价标准，很难量化。

> 可复用性

尽量减少重复代码的编写，复用已有的代码。继承、多态的出现很大程度上提高了代码的复用性。

> 可测试性

编写的代码很容易测试。测试很重要！具体原因在重构篇谈~

> 本节重点回顾

1. 如何评价代码质量的高低？ 

   代码质量的评价有很强的主观性，描述代码质量的词汇也有很多，比如可读性、可维护性、 灵活、优雅、简洁等，这些词汇是从不同的维度去评价代码质量的。它们之间有互相作用， 并不是独立的，比如，代码的可读性好、可扩展性好就意味着代码的可维护性好。代码质量 高低是一个综合各种因素得到的结论。我们并不能通过单一的维度去评价一段代码的好坏。 

2. 最常用的评价标准有哪几个？ 

   最常用到几个评判代码质量的标准是：可维护性、可读性、可扩展性、灵活性、简洁性、可 复用性、可测试性。其中，可维护性、可读性、可扩展性又是提到最多的、最重要的三个评 价标准。 

3. 如何才能写出高质量的代码？ 

   要写出高质量代码，我们就需要掌握一些更加细化、更加能落地的编程方法论，这就包含面 向对象设计思想、设计原则、设计模式、编码规范、重构技巧等等，这也是我们后面课程学 习的重点。 

> 讨论题

1. 你觉得还有哪些其他的代码评价标准非常重要？聊一聊你心目中的 好代码是什么样子的？

   1）重要逻辑注释要清晰，最好可用符号式的图文进行说明。Java的一些并发类这块就做的不错。

   2）容易debug，方便查错。

   3）异常处理得体，细粒化异常，抛出的异常要极可能的细，尽可能的准确，不要模棱两可。

## 关系

面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？

面向对象：面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式编码实现的基础。

设计原则：设计原则是指导我们代码设计的一些经验总结，且这些原则听起来都比较抽象，定义描述都比较模糊，不同的人会有不同的解读。我们需要掌握的式这些原则的设计初衷~

设计模式：设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思 路。大部分设计模式要解决的都是代码的可扩展性问题。我们需要学会的是了解它们都能解决哪些问题，掌握典型的应用场景，并且懂得不过度应用。

编程规范：偏向记忆，照着做即可。

代码重构：是保持代码质量不下降。重构代码的手段就是前面罗列的那些面向对象设计思想、设计原则、设计模式、编码规范。

> 总结

设计原则是指导我们代码设计的一些经验总结。

设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。

编程规范主要解决的是代码的可读性问题。

重构作为保持代码质量不下降的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论。

<img src="..\pics\geek\designPatterns\relationship.png" style="width:70%">

# 设计模式原则

## 单一职责原则

做角色访问控制的时候，动作主体（用户）与资源的行为（权限）分离。

单一职责原则的定义是：应该有且仅有一个原因引起类的变更。==通俗来说就是一个接口或类只有一个职责，它就负责一件事情。==

但是单一职责原则最难划分的就是职责，一个职责一个接口，职责该如何量化？这些都是不可度量的，因项目而异，因环境而异。

只能说这个原则尽量遵守，也最容易被打破。

## 里氏替换原则

里氏替换原则的定义是：所有引用基类的地方必须能透明地使用其子类的对象。通俗说就是，只要父类能出现的地方子类就可以出现，而替换为子类也不会产生任何错误或异常。

注意：如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系替代

## 依赖倒置原则

依赖倒置原则的定义是：

- 高层模不应该依赖低层模块，两者都应该依赖其抽象；
- 抽象不应该依赖细节；
- 细节应该依赖抽象；

在Java中的表现是：

- 模块间的依赖通过抽象发生，实现类之间不能发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。
- 接口或抽象类不依赖于实现类；
- 实现类依赖接口或抽象类
- 简而言之：面向接口编程

## 接口隔离原则

接口隔离原则的定义：客户端不应该依赖它不需要的接口。依赖它需要的接口，客户端需要什么接口就提供什么接口，把不需要的接口剔除，细化接口，保证接口的纯洁性。

注意：设计是有限度的，不能无限地考虑未来的变更情况，否则会陷入设计的泥潭中而不能自拔。

## 迪米特法则

迪米特法则的定义：一个对象应该对其他对象有最少的了解。一个类应该对自己需要耦合或调用的类直到的最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，知道它提供了多少public方法即可。

尽量不要对外公布太多的public方法和非静态的public变量，尽量内敛。

> 案例

```java
public class Wizard {
    private Random rand = new Random(System.currentTimeMillis());

    private int first() {
        System.out.println("first");
        return rand.nextInt(100);
    }

    private int second() {
        System.out.println("second");
        return rand.nextInt(100);
    }

    private int third() {
        System.out.println("third");
        return rand.nextInt(100);
    }

    public void installWizard() {
        int first = this.first();
        if (first > 50) {
            int second = this.second();
            if (second > 50) {
                int third = this.third();
                if (third > 50) {
                    System.out.println("install success");
                }
            }
        }
    }
}
```

## 开闭原则

对扩展开放，对关闭修改。是最基础的原则，前面五个原则都是开闭原则的具体形态，前5个原则是指导设计的工具和方法，开闭原则是其核心精神。

# 创建型

## 单例模式

> 定义

确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。

> 通用代码

```java
public class Singleton {
    private static final Singleton singleton = new Singleton();

    private Singleton() {
    }

    public static Singleton getInstance() {
        return singleton;
    }
}
```

---

```java
public class DCLSingleton {
    // volatile 防止指令重排序
    private volatile DCLSingleton dclSingleton = null;

    private DCLSingleton() {
    }

    public DCLSingleton getInstance() {
        if (dclSingleton == null) {
            synchronized (DCLSingleton.class) {
                if (dclSingleton == null) {
                    dclSingleton = new DCLSingleton();
                }
            }
        }
        return dclSingleton;
    }
}
```

## 工厂方法模式

定义一个用于创建对象的接口，，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类中。

工厂方法模式的变种较多，以下为一个比较实用的通用源码。

```java
public interface Human {
    void getColor();
}

class BlackHuman implements Human {

    @Override
    public void getColor() {
        System.out.println("黑人，黑色皮肤");
    }
}

class YellowHuman implements Human {

    @Override
    public void getColor() {
        System.out.println("黄种人，黄色皮肤");
    }
}
```

---

```java
public abstract class AbstractHumanFactory {
    // 泛型的继承。参数类型得是T，即参数类型要是Human的子类
    public abstract <T extends Human> T createHuman(Class<T> c);
}

public class HumanFactory extends AbstractHumanFactory {
    @Override
    public <T extends Human> T createHuman(Class<T> c) {
        Human human = null;
        try {
            human = (T) Class.forName(c.getName()).newInstance();
        } catch (Exception e) {
            System.out.println("生成 Human 子类对象失败");
        }
        return (T) human;
    }
}
```

----

```java
public class Main {
    public static void main(String[] args) {
        HumanFactory humanFactory = new HumanFactory();
        BlackHuman human = humanFactory.createHuman(BlackHuman.class);
        human.getColor();
    }
}
```



## 建造者模式

----



## 原型模式

# 结构型

## 代理模式

## 桥接模式

## 装饰者模式

## 适配器模式

---

## 门面模式

## 组合模式

## 享元模式

# 行为型

## 观察者模式

## 模板模式

## 策略模式

## 职责链模式

## 迭代器模式

## 状态模式

## 访问者模式

## 备忘录模式

## 命令模式

## 解释器模式

## 中介模式

