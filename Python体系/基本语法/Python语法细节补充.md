## Python中的深浅拷贝

### 区别赋值运算与深浅拷贝

- <span style="color:green">**赋值运算与深浅拷贝无关**</span>【l1和l2是同一个指向】

  ```python
  l1 = [1,2,3,[22,33]]
  l2 = l1
  l2.append(666)
  print(l1) # output [1,2,3,[22,33],666]
  print(l2) # output [1,2,3,[22,33],666]
  ```

### 深拷贝与浅拷贝

- <span style="color:green">**浅拷贝**</span>

  列表是一个个槽位，每个槽位存储的是该对象的内存地址。

  ```python
  l1 = [1,2,[22,33]]
  l2 = l1.copy()
  
  l1[2].append(44) 
  print(l1) # [1,2,[22,33,44]]
  print(l2) # [1,2,[22,33,44]]
  
  # python存在不可变数据类型，当不可变数据类型对应变量的值发送了改变，那么内存地址值就改变了,指向的就不是同一块内存地址空间了~。
  
  l1 = [1,2,[22,33]]
  l2 = l1.copy()
  l1[0] = 6
  # int类型是不可变的，它l1中的0位置指向的内存空间以及变了。l2还是指向原来的数据
  print(l1) # [6,2,[22,33]]
  print(l2) # [1,2,[22,33]]
  ```

- <span style="color:green">**浅拷贝小结**</span>

  浅拷贝会在内存中新开辟一个空间，存放这个copy的列表，但是列表里面的内容还是沿用之前对象的内存地址。

- <span style="color:green">**深拷贝**</span>

  全新的副本，互不影响~（可变数据类型在内存中重新创建一份，而不可变沿用之前的，为什么不可变可以沿用之前的？看Java 不可变类的源码就知道了~）

  ```python
  >>> l1 = [1,2,3,[4,4,4]]
  >>> import copy
  >>> l2 = copy.deepcopy(l1)
  >>> l2[3].append(4)
  >>> l2
  [1, 2, 3, [4, 4, 4, 4]]
  >>> l1
  [1, 2, 3, [4, 4, 4]]
  >>> l2[0] = 0
  >>> l1
  [1, 2, 3, [4, 4, 4]]
  >>> l2
  [0, 2, 3, [4, 4, 4, 4]]
  ```

- <span style="color:green">**深拷贝小结**</span>

  会在内存中开辟新空间，将原列表以及列表里面的可变数据类型重新创建一份，不可变数据类型则沿用之前的~

### Python为什么默认使用浅

- 时间角度：浅拷贝花费时间更少，不用为元素开篇新的内存空间
- 空间角度：浅拷贝花费内存更少
- 效率角度：浅拷贝只拷贝顶层数据，一般情况下比深拷贝效率高



## Python中不可变和可变

### 基本解释

- 不可变数据类型：数据的值发生改变，是开辟了一个新的地址空间，存储改变后的值，原有值还在老空间中呆着（如果没被`gc`的话）~
- 可变数据类型：数据的值发生改变，是在原有地址空间中的改变~

### 数据类型分类

- 可变
  - 集合
  - 列表
  - 字典
- 不可变
  - 整型
  - 字符串
  - 元组（比较特殊）：是元组中元素的地址值不能进行改变~ 一改变就报错了~