# 概述

## 目的

对内核各个核心子系统有个整体把握，它们提供什么样的服务，为什么要提供这样的服务，如何实现的。

调试技术，编码风格，注意事项。

本人侧重实践，有需要的话 看完此书后再看《Linux Device Drivers》

译者的学习网站 www.kerneltravel.net

我应该不会全看，只看调重点章节详细阅读。我的主力语言是Java，对内核有个大致的了解，理解部分内容就好了。

## 问题

不只是内核开发，其他开发也是，体系越来越庞大。出现了局部断层。

## 一些疑问&参考回答

### OS和内核的区别

- OS > 内核，kernel是OS的最基本部分，两者是包含关系，kernel是OS的核心
- 内核用于管理系统资源，例如提供对软件层面的抽象（例如对进程、文件系统、同步、内存、网络协议等对象的操作和权限控制），和对硬件访问的抽象（例如磁盘，显示，网络接口卡（NIC））；操作系统，在内核的基础上有延伸，包括了提供基础服务的系统组件。
- 一个内核不是一套完整的操作系统，现在默认linux为linux内核，这是由于历史源因造成的，实际上一般来讲，一个Linux发行版本出来包括Linux内核之外，还包含大量的软件（套件），比如软件开发工具，数据库，Web服务器（例如Apache），X Window，桌面环境（比如GNOME和KDE），办公套件（比如OpenOffice、org）等等。

----

# Linux内核简介

## Unix历史

Unix 系统调用少！只开放必要的调用！几乎把系统中的所有东西都当做文件对待，处理方式统一（秒啊！）。

## Linux历史

开源，它人可修改完善，是它成功的一大要素。（想想Java和C#，开源是Java胜出的一大因素？）

和Unix一样，保证了应用程序编程接口的一致。（没有直接使用Unix源码哦！）

## Linux系统的基础

- 内核
- C库
- 工具集和系统的基本工具

本书说Linux主要是值内核，特殊指代的话会进行说明。

## 单内核与微内核

| 内核   | 原理                                                         | 优势                                                         | 劣势                             |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------- |
| 单内核 | 整个内核都在一个大内核地址空间上运行。                       | 1.简单<br />2.高效。内核间的调用没什么开销                   | 一个功能的崩溃会导致系统无法使用 |
| 微内核 | 内核按功能被划分成各个独立的过程。每个过程独立的运行在自己的地址空间上。 | 1.安全，各个服务直接独立运行，互不影响<br />2.方便拓展，耦合性低 | 服务之间的通信耗时               |

Linux的内核虽然是基于单内核的，但是经过这么多年的发展，也具备微内核的一些特征。（体现了Linux实用至上的原则）

**主要有以下特征：**

1. 支持动态加载内核模块
2. 支持对称多处理（SMP）
3. 内核可以抢占（preemptive），允许内核运行的任务有优先执行的能力
4. 不区分线程和进程，所有的进场都一样----只不过是其中的一些共享资源而已。（这让我想起了设计模式，多数设计模式本质就是多态，提高代码复用性和可拓展性，不必分的太明确，不过分的明确，命名上可以讲究一下，见名知意。）

**对称多处理的解释**

**对称多处理**（英语：Symmetric multiprocessing，缩写为 SMP），也译为**均衡多处理**、**对称性多重处理**、**对称多处理机**[[1\]](https://zh.wikipedia.org/wiki/对称多处理#cite_note-1)，是一种[多处理器](https://zh.wikipedia.org/wiki/多處理器)的电脑硬件架构，在对称多处理架构下，每个处理器的地位都是平等的，对资源的使用权限相同。现代多数的[多处理器](https://zh.wikipedia.org/wiki/多處理器)系统，都采用对称多处理架构，也被称为对称多处理系统（Symmetric multiprocessing system）。在这个系统中，拥有超过一个以上的处理器，这些处理器都连接到同一个共享的主存上，并由单一操作系统来控制。在[多核心处理器](https://zh.wikipedia.org/wiki/多核心處理器)的例子中，对称多处理架构，将每一个核心都当成是独立的处理器。

在对称多处理系统上，在操作系统的支持下，无论行程是处于用户空间，或是核心空间，都可以分配到任何一个处理器上运行。因此，行程可以在不同的处理器间移动，达到负载平衡，使系统的效率提升。

## **内核版本号**

内核的版本号主要有四个数组组成。比如版本号：2.6.26.1 其中，

2 - 主版本号

6 - 从版本号或副版本号

26 - 修订版本号

1 - 稳定版本号

副版本号表示这个版本是稳定版（**偶数**）还是开发版（**奇数**），上面例子中的版本号是稳定版。

稳定的版本可用于企业级环境。

修订版本号的升级包括BUG修正，新的驱动以及新的特性的追加。

稳定版本号主要是一些关键性BUG的修改。

----

# 内核开发

获取内核源码，编译。建议用虚拟机搞，毕竟怕把系统搞崩溃了。

## 编译内核

没实践过，就不实践了，有空再说哈哈哈。

### **1. 获取内核源码**

内核是开源的，所有获取源码特别方便，参照以下的网址，可以通过git或者直接下载压缩好的源码包。

[http://www.kernel.org](http://www.kernel.org/)

### **2. 内核源码的结构**

| **目录**      | **说明**                            |
| ------------- | ----------------------------------- |
| arch          | 特定体系结构的代码                  |
| block         | 块设备I/O层                         |
| crypo         | 加密API                             |
| Documentation | 内核源码文档                        |
| drivers       | 设备驱动程序                        |
| firmware      | 使用某些驱动程序而需要的设备固件    |
| fs            | VFS和各种文件系统                   |
| include       | 内核头文件                          |
| init          | 内核引导和初始化                    |
| ipc           | 进程间通信代码                      |
| kernel        | 像调度程序这样的核心子系统          |
| lib           | 同样内核函数                        |
| mm            | 内存管理子系统和VM                  |
| net           | 网络子系统                          |
| samples       | 示例，示范代码                      |
| scripts       | 编译内核所用的脚本                  |
| security      | Linux 安全模块                      |
| sound         | 语音子系统                          |
| usr           | 早期用户空间代码（所谓的initramfs） |
| tools         | 在Linux开发中有用的工具             |
| virt          | 虚拟化基础结构                      |

## 内核开发的特点

### 特点概述

常用准则被颠覆。

- 内核编程不能访问C库和标准的C头文件
- 内核编程时必须使用GNU C
- 内核编程缺乏内存保护极值
- 难以执行浮点数运算（？？？）
- 内核给每个进程只有一个很小的定长堆栈
- 内核支持异步中断、抢占和SMP，必须时刻注意同步和并发
- 要考虑可移植性

### 无libc库或标准头文件

对内核来说，C库甚至是C库的一个子集，都太大效率太低了。

不过大部分常用的C函数，内核中都有对应的实现

### 内核编译推荐

使用GNU C，推荐用gcc 4.4或以后的版本来编译内核

因为使用GNU C，所有内核中常使用GNU C中的一些扩展：

### 内核代码中C的扩展

#### 内联函数

内联函数在编译时会在它被调用的地方展开，减少了函数调用和返回的开销（OOP语言这快非常频繁。。。），性能较好。但是，频繁的使用内联函数也会使代码变长，从而在运行时占用更多的内存。

所以内联函数使用时最好要满足以下几点：函数较小，会被反复调用，对程序的时间要求比较严格。

内联函数示例：static **inline** void sample();

内联函数在使用前要定义好，以便展开。

推荐优先使用内联函数，而非宏定义。

#### 内联汇编

内联汇编用于偏近底层或对执行时间严格要求的地方。示例如下：

```c
unsigned int low, high;
asm volatile("rdtsc" : "=a" (low), "=d" (high));
/* low 和 high 分别包含64位时间戳的低32位和高32位 时间要求严格的用汇编写*/
```

#### 分支声明

如果能事先判断一个if语句时经常为真还是经常为假，那么可以用unlikely和likely来优化这段判断的代码。（<span style="color:red">`JVM`在这块的优化有不少坑，都是来源于指令重排序</span>）

```c
/* 如果error在绝大多数情况下为0(假) */
if (unlikely(error)) {
    /* ... */
}

/* 如果success在绝大多数情况下不为0(真) */
if (likely(success)) {
    /* ... */
}
```

#### 没有内存保护

内核是最低层的程序，如果内核访问非法内存，整个系统都会挂掉！！所以内核开发的风险比用户程序开发的风险要大。

内核中的内存是不分页的，每用一个字节的内存，物理内存就少一个字节。所以内核中使用内存一定要谨慎。（**我又和OS混了。OS里不是说内存是分页或分段的吗**。）

#### 不使用浮点数

内核不能完美的支持浮点操作，使用浮点数时，需要人工保存和恢复浮点寄存器及其他一些繁琐的操作。

#### 内核栈容积小且固定

内核栈的大小有编译内核时决定的，对于不用的体系结构，内核栈的大小虽然不一样，但都是固定的。

查看内核栈大小的方法：

```
ulimit -a | grep "stack size"
```

#### 同步和并发

Linux是多用户的操作系统，所以必须处理好同步和并发操作，防止因竞争而出现死锁。

#### 可移植性

Linux内核可用于不用的体现结构，支持多种硬件。所以开发时要时刻注意可移植性，尽量使用体系结构无关的代码。

----

# 进程管理

#  系统调用

```shell
# ubuntu下查看有那些系统调用
cat /usr/src/linux-headers-5.4.0-42/arch/alpha/include/asm/unistd.h
```

讲了下系统调用的规则，有点，怎么看有那些系统调用，如何自定义系统调用。

# 内核数据结构

## 主要内容

`ubuntu`下的文件位置

- 链表----在`/usr/src/linux-headers-5.4.0-42/include/linux/list.h`
- 队列----在``
- 映射
- 红黑树













































































