# 高级工具

# 线程池

## 自定义线程池

pic

步骤1：自定义拒绝策略接口

```java
@FunctionalInterface // 拒绝策略
interface RejectPolicy<T> {
     void reject(BlockingQueue<T> queue, T task);
}
```

步骤2：自定义任务队列

```java
class BlockingQueue<T> {
 // 1. 任务队列
 private Deque<T> queue = new ArrayDeque<>();
 // 2. 锁
 private ReentrantLock lock = new ReentrantLock();
 // 3. 生产者条件变量
 private Condition fullWaitSet = lock.newCondition();
 // 4. 消费者条件变量
 private Condition emptyWaitSet = lock.newCondition();
 // 5. 容量
 private int capcity;
 public BlockingQueue(int capcity) {
 this.capcity = capcity;
 }
 // 带超时阻塞获取
 public T poll(long timeout, TimeUnit unit) {
 lock.lock();
 try {
 // 将 timeout 统一转换为 纳秒
 long nanos = unit.toNanos(timeout);
 while (queue.isEmpty()) {
 try {
 // 返回值是剩余时间
 if (nanos <= 0) {
 return null;
 }
 nanos = emptyWaitSet.awaitNanos(nanos);
 } catch (InterruptedException e) {
 e.printStackTrace();
 }
 }
 T t = queue.removeFirst();
 fullWaitSet.signal();
 return t;
 } finally {
 lock.unlock();
 }
 }
 // 阻塞获取
 public T take() {
 lock.lock();
 try {
 while (queue.isEmpty()) {
 try {
 emptyWaitSet.await();
 } catch (InterruptedException e) {
 e.printStackTrace();
 }
 }
 T t = queue.removeFirst();
 fullWaitSet.signal();
 return t;
 } finally {
 lock.unlock();
 }
 }
 // 阻塞添加
 public void put(T task) {
 lock.lock();
 try {
 while (queue.size() == capcity) {
 try {
 log.debug("等待加入任务队列 {} ...", task);
 fullWaitSet.await();
 } catch (InterruptedException e) {
 e.printStackTrace();
 }
 }
 log.debug("加入任务队列 {}", task);
 queue.addLast(task);
 emptyWaitSet.signal();
 } finally {
 lock.unlock();
 }
 }
 // 带超时时间阻塞添加
 public boolean offer(T task, long timeout, TimeUnit timeUnit) {
 lock.lock();
 try {
 long nanos = timeUnit.toNanos(timeout);
 while (queue.size() == capcity) {
 try {
 if(nanos <= 0) {
 return false;
 }
 log.debug("等待加入任务队列 {} ...", task);
 nanos = fullWaitSet.awaitNanos(nanos);
      } catch (InterruptedException e) {
 e.printStackTrace();
 }
 }
 log.debug("加入任务队列 {}", task);
 queue.addLast(task);
 emptyWaitSet.signal();
 return true;
 } finally {
 lock.unlock();
 }
 }
 public int size() {
 lock.lock();
 try {
 return queue.size();
 } finally {
 lock.unlock();
 }
 }
 public void tryPut(RejectPolicy<T> rejectPolicy, T task) {
 lock.lock();
 try {
 // 判断队列是否满
 if(queue.size() == capcity) {
 rejectPolicy.reject(this, task);
 } else { // 有空闲
 log.debug("加入任务队列 {}", task);
 queue.addLast(task);
 emptyWaitSet.signal();
 }
 } finally {
 lock.unlock();
 }
 }
}

```

步骤3：自定义线程池

```java
class ThreadPool {
 // 任务队列
 private BlockingQueue<Runnable> taskQueue;
 // 线程集合
 private HashSet<Worker> workers = new HashSet<>();
 // 核心线程数
 private int coreSize;
 // 获取任务时的超时时间
    private long timeout;
 private TimeUnit timeUnit;
 private RejectPolicy<Runnable> rejectPolicy;
 // 执行任务
 public void execute(Runnable task) {
 // 当任务数没有超过 coreSize 时，直接交给 worker 对象执行
 // 如果任务数超过 coreSize 时，加入任务队列暂存
 synchronized (workers) {
 if(workers.size() < coreSize) {
 Worker worker = new Worker(task);
 log.debug("新增 worker{}, {}", worker, task);
 workers.add(worker);
 worker.start();
 } else {
// taskQueue.put(task);
 // 1) 死等
 // 2) 带超时等待
 // 3) 让调用者放弃任务执行
 // 4) 让调用者抛出异常
 // 5) 让调用者自己执行任务
 taskQueue.tryPut(rejectPolicy, task);
 }
 }
 }
 public ThreadPool(int coreSize, long timeout, TimeUnit timeUnit, int queueCapcity, 
RejectPolicy<Runnable> rejectPolicy) {
 this.coreSize = coreSize;
 this.timeout = timeout;
 this.timeUnit = timeUnit;
 this.taskQueue = new BlockingQueue<>(queueCapcity);
 this.rejectPolicy = rejectPolicy;
 }
 class Worker extends Thread{
 private Runnable task;
 public Worker(Runnable task) {
 this.task = task;
 }
 @Override
 public void run() {
 // 执行任务
 // 1) 当 task 不为空，执行任务
 // 2) 当 task 执行完毕，再接着从任务队列获取任务并执行
// while(task != null || (task = taskQueue.take()) != null) {
 while(task != null || (task = taskQueue.poll(timeout, timeUnit)) != null) {
 try {
 log.debug("正在执行...{}", task);
      task.run();
 } catch (Exception e) {
 e.printStackTrace();
 } finally {
 task = null;
 }
 }
 synchronized (workers) {
 log.debug("worker 被移除{}", this);
 workers.remove(this);
 }
 }
 }
}
```

步骤4：测试

```java
public static void main(String[] args) {
 ThreadPool threadPool = new ThreadPool(1,
 1000, TimeUnit.MILLISECONDS, 1, (queue, task)->{
 // 1. 死等
// queue.put(task);
 // 2) 带超时等待
// queue.offer(task, 1500, TimeUnit.MILLISECONDS);
 // 3) 让调用者放弃任务执行
// log.debug("放弃{}", task);
 // 4) 让调用者抛出异常
// throw new RuntimeException("任务执行失败 " + task);
 // 5) 让调用者自己执行任务
 task.run();
 });
 for (int i = 0; i < 4; i++) {
 int j = i;
 threadPool.execute(() -> {
 try {
 Thread.sleep(1000L);
 } catch (InterruptedException e) {
 e.printStackTrace();
 }
 log.debug("{}", j);
 });
 }
 }
```

## ThreadPoolExecutor

### 1) 线程池状态

ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量

从数字上比较，TERMINATED > TIDYING > STOP > SHUTDOWN > RUNNING 

这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作 进行赋值

```java
// c 为旧值， ctlOf 返回结果为新值
ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))));
// rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们
private static int ctlOf(int rs, int wc) { return rs | wc; }
```

### 2）构造方法

```java
public ThreadPoolExecutor(int corePoolSize,
 int maximumPoolSize,
 long keepAliveTime,
 TimeUnit unit,
 BlockingQueue<Runnable> workQueue,
 ThreadFactory threadFactory,
RejectedExecutionHandler handler)
```

- corePoolSize 核心线程数目 (最多保留的线程数) 
- maximumPoolSize 最大线程数目 
- keepAliveTime 生存时间 - 针对救急线程 
- unit 时间单位 - 针对救急线程 
- workQueue 阻塞队列 
- threadFactory 线程工厂 - 可以为线程创建时起个好名字 
- handler 拒绝策略

### 3）工作方式

- 线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。 
- 当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue 队列排 队，直到有空闲的线程。 
- 如果队列选择了有界队列，那么任务超过了队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线 程来救急。 
- 如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略。拒绝策略 jdk 提供了 4 种实现，其它 著名框架也提供了实现
  - AbortPolicy 让调用者抛出 RejectedExecutionException 异常，这是默认策略
  - CallerRunsPolicy 让调用者运行任务 
  - DiscardPolicy 放弃本次任务 
  - DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之 
  - Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方 便定位问题 
  - Netty 的实现，是创建一个新线程来执行任务 
  - ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略 
  - PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略
- 当高峰过去后，超过corePoolSize 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由 keepAliveTime 和 unit 来控制。

根据这个构造方法，JDK Executors 类中提供了众多工厂方法来创建各种用途的线程池

### 4）newFixedThreadPool

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
 return new ThreadPoolExecutor(nThreads, nThreads,
 0L, TimeUnit.MILLISECONDS,
 new LinkedBlockingQueue<Runnable>());
}
```

特点：

- 核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间 
- 阻塞队列是无界的，可以放任意数量的任务

**评价 适用于任务量已知，相对耗时的任务**

### 5） newCachedThreadPool

# `J.U.C`

## `AQS` 原理

### 概述

全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架。

> 特点：

- 用 state 属性来表示资源的状态（分独占模式和共享模式，比如0代表xx，1代表oo，这都是由子类自己维护的），子类需要定义如何维护这个状态，控制如何获取 锁和释放锁 
  - `getState` - 获取 state 状态 
  - `setState` - 设置 state 状态 
  - `compareAndSetState - cas` 机制设置 state 状态。**保证 state 赋值时的原子性。**
  - 独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源 
- 提供了基于 FIFO 的等待队列，类似于 Monitor 的 `EntryList` 
- 条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 `WaitSet`

> 子类主要实现这样一些方法（默认抛出 `UnsupportedOperationException`）

- `tryAcquire` 
- `tryRelease` 
- `tryAcquireShared` 
- `tryReleaseShared` 
- `isHeldExclusively`

----

> <span style="color:red">**获取锁**</span>

```java
// 如果获取锁失败
if (!tryAcquire(arg)) {
     // 入队, 可以选择阻塞当前线程 用 park unpark 进行阻塞，恢复线程的
}
```

> <span style="color:red">**释放锁**</span>

```java
// 如果释放锁成功
if (tryRelease(arg)) {
     // 让阻塞线程恢复运行
}
```

### 实现不可重入锁

#### 自定义同步器

```java
final class MySync extends AbstractQueuedSynchronizer {
 @Override
 protected boolean tryAcquire(int acquires) {
 if (acquires == 1){
 if (compareAndSetState(0, 1)) {
 setExclusiveOwnerThread(Thread.currentThread());
 return true;
 }
 }
 return false;
 }
 @Override
 protected boolean tryRelease(int acquires) {
 if(acquires == 1) {
 if(getState() == 0) {
 throw new IllegalMonitorStateException();
 }
 setExclusiveOwnerThread(null);
 setState(0);
 return true;
 }
 return false;
 }
 protected Condition newCondition() {
 return new ConditionObject();
 }
 @Override
 protected boolean isHeldExclusively() {
 return getState() == 1;
      }
}
```

#### 自定义锁

有了自定义同步器，很容易复用 AQS ，实现一个功能完备的自定义锁

```java
class MyLock implements Lock {
 static MySync sync = new MySync();
 @Override
 // 尝试，不成功，进入等待队列
 public void lock() {
 sync.acquire(1);
 }
 @Override
 // 尝试，不成功，进入等待队列，可打断
 public void lockInterruptibly() throws InterruptedException {
 sync.acquireInterruptibly(1);
 }
 @Override
 // 尝试一次，不成功返回，不进入队列
 public boolean tryLock() {
 return sync.tryAcquire(1);
 }
 @Override
 // 尝试，不成功，进入等待队列，有时限
 public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
 return sync.tryAcquireNanos(1, unit.toNanos(time));
 }
 @Override
 // 释放锁
 public void unlock() {
 sync.release(1);
 }
 @Override
 // 生成条件变量
 public Condition newCondition() {
 return sync.newCondition();
 }
}
```

测试一下

```java
MyLock lock = new MyLock();
new Thread(() -> {
 lock.lock();
 try {
 log.debug("locking...");
 sleep(1);
 } finally {
 log.debug("unlocking...");
 lock.unlock();
 }
},"t1").start();
new Thread(() -> {
 lock.lock();
 try {
 log.debug("locking...");
 } finally {
 log.debug("unlocking...");
 lock.unlock();
 }
},"t2").start();
```

输出

```shell

```

不可重入测试 ：如果改为下面代码，会发现自己也会被挡住（只会打印一次 locking）

```java
lock.lock();
log.debug("locking...");
lock.lock();
log.debug("locking...");
```

### 心得

#### 起源

早期程序员会自己通过一种同步器去实现另一种相近的同步器，例如用可重入锁去实现信号量，或反之。这显然不 够优雅，于是在 JSR166（java 规范提案）中创建了 AQS，提供了这种通用的同步器机制。

#### 目标

AQS 要实现的功能目标 

- 阻塞版本获取锁 acquire 和非阻塞的版本尝试获取锁 tryAcquire 
- 获取锁超时机制
- 通过打断取消机制 
- 独占机制及共享机制 
- 条件不满足时的等待机制

要实现的性能目标：

Instead, the primary performance goal here is scalability: to predictably maintain efficiency even, or especially, when synchronizers are contended.

#### 设计

`AQS` 的基本思想其实很简单

```java
// 获取锁的逻辑
while(state 状态不允许获取) {
     if(队列中还没有此线程) {
     入队并阻塞
     }
}
当前线程出队
```



## `ReentrantLock` 原理

## 读写锁

### 读写锁原理

## `Semaphore`

## `Semaphore` 原理

## `CountDownLatch`

## `CyclicBarrier`

## `ConcurrentHashMap`

## `ConcurrentHashMap` 原理

## `BlockingQueue`

## `BlockingQueue` 原理

## `ConcurrentLinkedQueue`

##  `CopyOnWriteArrayList`

