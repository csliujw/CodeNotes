# 复习

## 基础知识

```java
/**
 * 基础知识回顾
 * int 占多少字节，double 占多少字节，float 占多少字节，char 占多少字节，
 * <p>
 * 数组的内容
 * int [][]arr = {{11,11,11},{0},{2,2,2,2},{3,3,3}}
 * arr.length = ?
 * arr[1].length = ?
 * <p>
 * 补充 三目运算符
 * int x = 1, x>0?x+1:x*10
 */
public class Demo1 {

}

```

## 面向对象经典习题

```java
/**
 * 面向对象经典习题
 *
 * 子了可以有多个父类吗？（我的意思是直接通过 extends 关键字继承的父类，不是间接继承）
 *
 * 静态成员变量/方法 可以怎么使用/调用 通过对象-通过类名
 */
public class Demo2 {

}

class F {
    public int n = 0;

    public void say() {
        System.out.println("F");
    }
}

class S extends F {
    public int n = 10;

    public void say() {
        System.out.println("S");
    }

    public static void main(String[] args) {
        F f = new S();
        System.out.println(f.n);
        f.say();
    }
}
```

## final关键字

```java
/**
 * final 关键字
 * 特點？
 * 变量上？方法上？类上？
 */
public class Demo3 {
}
```

## 容易晕的参数传递

```java
/**
 * 参数传递问题
 * 基本数据类型传递：swap方法举例
 * 对象类型数据传递：swap方法举例
 * （值传递和引用传递的两种不同说法）
 */
public class Demo4 {
}
```

## 类的方法有那些

```java
/**
 * 类的方法有那些？：构造方法、成员方法、静态方法
 * 从返回值类型、方法名称、作用、如何使用 来分析分析。
 * 构造方法：
 * 成员方法
 * 静态方法
 */
public class Demo5 {
}

```

## 类、抽象类、接口类

```java
/**
 * 普通类：成员变量、成员方法、构造方法
 * 抽象类：成员变量、成员方法、构造方法、抽象方法
 * 接口类：静态变量（常量）、静态方法、default 方法、抽象方法
 */
public class Demo6 {
}

```

## 经典的包装类面试题

```java
/**
 * 經典的包装类面试题
 */
public class Demo7 {
    public static void main(String[] args) {
        Long n1 = -100L;
        Long n2 = -100L;

        Long s1 = 200L;
        Long s2 = 200L;

        System.out.println(n1 == n2);
        System.out.println(s1 == s2);
        /**
         * 为什么？用到了什么设计模式
         */
    }
}
```

## ArrayList

```java
/**
 * 剖析ArrayList。
 * 扩容
 */
public class Demo8 {
}

```

## 常见设计模式简要说明

```java
/**
 * 常用設計模式简要说明
 * 只希望有一个对象？ ==> 单例模式
 * 算法流程固定，但是具体的步骤可能不一样 ==> 模板方法
 * 希望增强某个方法 ==> 装饰模式 I\O流举例
 * etc....(工厂方法、适配器模式、代理模式、策略模式、适配器模式、观察者模式.....)
 */
public class Demo9 {
}

class Single {
    final static Single INSTANCE = new Single();

    private Single() {

    }

    public static Single getInstance() {
        return INSTANCE;
    }
}

abstract class Template {
    public abstract void one();

    public abstract void two();

    public abstract void three();

    public void execute() {
        one();
        two();
        three();
    }
}
```

# 多线程

## 为什么要多线程

- 提高资源利用率，充分利用多核 CPU 的优势，提高运行效率。想象下面的场景，执行 3 个计算，最后将计算结果汇总

```shell
计算 1 花费 10 ms
计算 2 花费 11 ms
计算 3 花费 9 ms
汇总需要 1 ms
```

- 如果是串行执行，那么总共花费的时间是 10 + 11 + 9 + 1 = 31ms 
- 但如果是四核 cpu，各个核心分别使用线程 1 执行计算 1，线程 2 执行计算 2，线程 3 执行计算 3，那么 3 个 线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 11ms 最后加上汇总时间只会花费 12ms

**注意：**需要在多核 cpu 才能提高效率，单核仍然时是轮流执行

### 设计

> 多核 CPU 下总花费的时间会远低于 31 ms

```java
/**
 * 多核 CPU 多线程 提高效率。
 */
public class ThreadApplication {
    public static volatile int flag1 = 0;
    public static volatile int flag2 = 0;
    public static volatile int flag3 = 0;

    public static void main(String[] args) throws InterruptedException {
        // 3个线程，3个操作。
        Thread th1 = new Thread(() -> {
            try {
                TimeUnit.MILLISECONDS.sleep(10);
                flag1 = 1;
            } catch (InterruptedException e) {

            }
        });

        Thread th2 = new Thread(() -> {
            try {
                TimeUnit.MILLISECONDS.sleep(11);
                flag2 = 1;
            } catch (InterruptedException e) {

            }
        });
        Thread th3 = new Thread(() -> {
            try {
                TimeUnit.MILLISECONDS.sleep(9);
                flag3 = 1;
            } catch (InterruptedException e) {

            }
        });
        long start = System.currentTimeMillis();
        th1.start();
        th2.start();
        th3.start();
        th1.join();
        th2.join();
        th3.join();

        while (flag1 + flag3 + flag2 == 3) {
            TimeUnit.MILLISECONDS.sleep(1);
            System.out.println(System.currentTimeMillis() - start);
            return;
        }
    }
}
```

### 结论

- 单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活 
- 多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的 
    - 有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任 务都能拆分（参考后文的【阿姆达尔定律】） 
    - 也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义 
- IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一 直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化

## 创建一个线程

- 继承Thread
- 实现Runnable接口
- 使用JDK自带的线程池（池化思想）

```java
ExecutorService pool = Executors.newFixedThreadPool(2);
pool.submit(new Runnable() {
    @Override
    public void run() {
    }
});
```

## 线程安全

- 并发问题：多个线程对一个数据进行累加

```java
```

- 问题所在：
    - 提一下JMM内存模型。

## JMM内存模型

JMM 即 Java Memory Model，它定义了主存、工作内存抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。 

JMM 体现在以下几个方面 

- 原子性 - 保证指令不会受到线程上下文切换的影响 
- 可见性 - 保证指令不会受 cpu 缓存的影响 
- 有序性 - 保证指令不会受 cpu 指令并行优化的影响

- 解决并发问题

