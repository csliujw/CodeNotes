# 概述

应对大并发：

- 如何利用缓存
- 如何使用异步
- 优雅编写代码

> 秒杀

- 分布式会话
- 商品列表页
- 商品详情页
- 订单详情页
- 系统压测
- 缓存优化：先写数据库还是先写缓存。
- 消息队列：RabbitMQ 异步下单。
- 接口安全

## 整体流程

- Spring Boot 环境搭建
    - 继承 thymeleaf（后期改成layui），Result 结果封装
    - 继承 MyBatis + Druid
    - 继承 Jedis + Redis 安装 + 通用缓存 key 封装。
- 实现登录
    - 数据库设计
    - 明文密码两次 MD5
    - JSR303参数校验 + 全局异常处理器
    - 分布式 Session
- 实现秒杀
    - 数据库设计
    - 商品列表页
    - 商品详情页
    - 订单详情页
- JMeter 压测
    - JMeter 入门
    - 自定义变量模拟多用户
    - JMeter命令行使用
    - Spring Boot 打 war 包
- 页面优化技术
    - 页面缓存 + URL缓存 + 对象缓存（减少对数据库的访问）
    - 页面静态化，前后端分离
    - 静态资源优化
    - CDN优化
- 接口优化
    - Redis预减库存减少数据库访问
    - 内存标记减少 Redis 访问
    - RabbitMQ队列缓冲，异步下单，增强用户体验
    - 访问 Nginx 水平扩展
    - 压测
- 安全优化
    - 秒杀接口地址隐藏
    - 数学公式验证码（拉长访问时间）
    - 接口防刷

# 准备工作

## 数据库

```mysql
use miaosha;

create table users(
	id bigint primary key,
    nickname varchar(255) not null,
    password varchar(32) default null,
    salt varchar(10) default null,
    head varchar(128) default null,
    register_date datetime default null,
    last_login_date datetime default null,
    login_count int default 0
);
```



![image-20220214114241349](img\image-20220214114241349.png)

## 引入依赖

## Redis



# 登录功能

## 密码加密

- 两次 MD5 做加密。加密的大致流程如下：
    - 用户端：Pass = MD5（明文+固定salt）
    - 服务端：Pass = MD5（用户输入+随机salt），为每个用户生成一个随机 salt
- 具体做法：
    - 用户在注册时，输入自己的信息和密码。密码在传输过程中做一次加密。MD5（明文+固定salt）
    - 服务器端接收到用户注册信息后，为这个用户生成一个随机的 salt，继续做一次加密 MD5（传输过来的+随机生成的salt），然后将用户信息和 salt 一起写入数据库。
    - 后面用户登录的时候，先查询一次用户信息，查询到 salt，在服务端做个判断 MD5（密码+salt） == 数据库存储的密码。





![image-20220214115419732](img\image-20220214115419732.png)

引入MD5 依赖。

![image-20220214120511746](img\image-20220214120511746.png)

## JSR 303校验

在 Controller 里写代码校验参数太麻烦了，这里我们采用 JSR303 进行参数校验。我们希望校验下手机号是否正确，JSR303并未提供，我们可以自己定义一个校验规则。

- 定义注解。定义的方式，抄 JSR303 注解就行
-  定义一个注解解析器。也是参考 JSR303 的实现。

jsr303 校验依赖

![image-20220214130753808](img\image-20220214130753808.png)

## 全局异常处理器

- `@ControllerAdvice` 注解 + `@ResponseBody` 注解。操作出现异常的时候，直接抛出异常。抛出异常时，全局处理器会拦截这个异常。

```java
public boolean login(){
    if(xxx){
        throw new GlobalException(CodeMessage.XXX);
    }
    return true;
}
```

## 分布式Session

- 用户登录成功后，为用户生成 Session ID 标识用户，然后写入 cookie 传给客户端，并把用户信息（session id--用户信息）存入一个三方缓存中。客户端每次请求用户的信息时，携带这个UUID给服务器，服务器就可以通过这个 Session ID 查询到用户的信息。
    - 有些手机客户端，不会把 token 放到 cookie 里传过来，而是放到参数里传过来。

- 延迟 cookie 有效期，可以使用 SpringMVC 的内容协商来简化用户信息的获取和 cookie 的延长。

# 秒杀功能

- 数据库设计
- 商品列表页
- 商品详情页
- 订单详情页

正常梳理业务流程，修改&写入数据库。

## 数据库设计

- 商品表（内容稳定）、秒杀商品表（临时选择）
- 订单表、秒杀订单表

# 压测

## JMeter 压测

- 入门
    - 设置中文界面。打开[apache](https://so.csdn.net/so/search?q=apache&spm=1001.2101.3001.7020)-jmeter-5.0\bin\jmeter.properties 文件修改language=zh_CN，重新打开就是中文界面了
- 自定义变量模拟多用户
    - 测试计划 -> 添加配置元件 -> CSV Data Set Config
    - 引用变量 `${}`
- JMeter 命令行使用

> 测试结果

- User 接口 QPS 高，测试发现 redis 连接数不够，调大 redis 连接数。Goods QPS 低，因为它读了缓存和数据库；User QPS 高，因为他只读了缓存。
- 出现了超卖。并发问题。

## Redis 压测

- redis-benchmark

![image-20220215180830670](C:\development\Code\note\CodeNotes\Project\img\image-20220215180830670.png)

## 打包

![image-20220215180954494](C:\development\Code\note\CodeNotes\Project\img\image-20220215180954494.png)

![image-20220215181332400](C:\development\Code\note\CodeNotes\Project\img\image-20220215181332400.png)



# 页面优化

- 页面缓存+URL缓存+对象缓存
- 页面静态化，前后端分离
- 静态资源优化
- CDN优化

## 页面缓存

不是让系统帮我们渲染，而是先从缓存中拿，缓存中没有再渲染。这就需要我们手动渲染模板了，查阅文档，是使用 thymeleafViewResolver 进行渲染的。

GoosKey --> 商品页面缓存。

![image-20220215192735684](C:\development\Code\note\CodeNotes\Project\img\image-20220215192735684.png)

## URL 缓存

和页面缓存其实一样。只是商品有不同的编号，我用 Goods:1:xxx 缓存1号商品的页面，用 Goods:2:xxx 缓存2号商品的页面。

## 对象缓存

将用户信息缓存在 redis 中。每次取用户信息就取缓存中的，存在则拿，不存在则查数据库再存入缓存。

## 页面静态化

- 前后端分离，只传动态的数据，减少数据的发送量，减轻服务器压力.
- GET POST的区别:
    - HTTP协议并未规定GET\POST数据的传输量,只是浏览器厂商这么做.
    - GET请求是幂等的,POST不是幂等的.
    - `<a href="/delete?id=13">` 如果是 GET,搜索引擎在搜索页面的时候,会遍历页面中的链接,会执行这些链接.
- 除了前后端分离，还可以通过 cache-controll 告诉浏览器缓存这个页面，下次查询的时候直接查浏览器缓存。
    - Pragma ，HTTP1.0 可用
    - Expire ，HTTP1.1/1.0 可用，带时区的
    - Cache-Control ，HTTP1.1/1.0 可用 `cache-control:max-age 3600`

## 超卖

update 的 sql 语句会加行锁。update xx xxx xx where count>1; 利用数据库的唯一索引（用户id+goods id建立唯一索引），避免重复下单。

生成订单的时候，把订单写到缓存里，然后就不需要查数据库了，查缓存就行。

解决超卖用的 SQL 和唯一索引。有没有其他办法。

## 静态资源优化

- JS/CSS 压缩，减少流量
- 多个JS/CSS组合，减少连接数。由服务器实现->Tengine.
- CND 就近访问，加速数据请求。

# 接口优化

- Redis 预减库存减少数据库访问
- 内存标记减少 Redis 访问
- 请求先入对缓冲，异步下单，增强用户体验
- RabbitMQ 安装与 Spring Boot 集成
- Nginx 水平扩展
- 压测

## 秒杀接口优化

思路：减少数据库访问

- 1.系统初始化，把商品库存数量加载到 Redis
- 2.收到请求，Redis 预减库存，库存不足，直接返回，否则进入3
- 3.请求入队，立即返回排队中（不知道请求成功还是失败，Redis只是做了一个预减）
- 4.请求出队，生成订单，减少库存
- 5.收到排队中的消息后，客户端会轮询，是否秒杀成功

## 集成RabbitMQ

- 安装 erlang

![image-20220303194445424](C:\development\Code\note\CodeNotes\Project\img\image-20220303194445424.png)

- 安装 MQ

![image-20220303194516492](C:\development\Code\note\CodeNotes\Project\img\image-20220303194516492.png)

![image-20220303194525786](C:\development\Code\note\CodeNotes\Project\img\image-20220303194525786.png)

## Spring Boot集成

- 添加依赖 spring-boot-starter-amqp
- 创建消息接收者
- 创建消息发送者

```java
// 消息发送者
@Service
public class MQSender{
    @Autowired
    AmqtTemplate amqtTemplate;
    
    public void send(Object message){
        String msg = message.toString();
        amqtTemplate.convertAndSend(MQConfig.QUEUE,msg);
    }
}

// 消息接收者
@Service
public class MQReceiver{
    @RabbitListener(queues=MQConfig.QUEUE);
    public void receive(String message){
    	System.out.println(message);
    }
}

// 配置
@Configuration
public class MQConfig{
    private final static String QUEUE = "queue";
    @Bean
    public Queue queue(Object message){
        // 把 message 转成 字符串。
        return new Queue(QUEUE,true,msg)
    }
}
```

![image-20220303201501638](C:\development\Code\note\CodeNotes\Project\img\image-20220303201501638.png)

## 模式

- Direct 模式，交换机 Exchange。先把数据发送到交换机上，交换机再把数据发送到队列上，做了一个路由。
- Topic 模式，

# 接口幂等性

幂等性原本是数学上的概念，用在接口上就可以理解为：**同一个接口，多次发出同一个请求，必须保证操作只执行一次。** 调用接口发生异常并且重复尝试时，总是会造成系统所无法承受的损失，所以必须阻止这种现象的发生。

## 问题

- 网络波动, 可能会引起重复请求
- 用户重复操作,用户在操作时候可能会无意触发多次下单交易,甚至没有响应而有意触发多次交易应用
- 使用了失效或超时重试机制(Nginx重试、RPC重试或业务层重试等)
- 页面重复刷新
- 使用浏览器后退按钮重复之前的操作,导致重复提交表单
- 使用浏览器历史记录重复提交表单
- 浏览器重复的HTTP请求
- 定时任务重复执行
- 用户双击提交按钮

## 方案一

使用 token 机制。生成唯一ID 放入 redis，要执行操作前先查下 redis 里是否存在，如果相同的 key 已经放过了，则提示不允许此操作。如果是限定了，一定时间内不允许多次点击，redis 中可以设置内容的过期时间。

## 方案二

利用数据库唯一索引机制,当数据重复时,插入数据库会抛出异常,保证不会出现脏数据。
