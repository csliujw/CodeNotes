# 概述

应对大并发：

- 如何利用缓存
- 如何使用异步
- 优雅编写代码

> 秒杀

- 分布式会话
- 商品列表页
- 商品详情页
- 订单详情页
- 系统压测
- 缓存优化：先写数据库还是先写缓存。
- 消息队列：RabbitMQ 异步下单。
- 接口安全

## 整体流程

- Spring Boot 环境搭建
    - 继承 thymeleaf（后期改成layui），Result 结果封装
    - 继承 MyBatis + Druid
    - 继承 Jedis + Redis 安装 + 通用缓存 key 封装。
- 实现登录
    - 数据库设计
    - 明文密码两次 MD5
    - JSR303参数校验 + 全局异常处理器
    - 分布式 Session
- 实现秒杀
    - 数据库设计
    - 商品列表页
    - 商品详情页
    - 订单详情页
- JMeter 压测
    - JMeter 入门
    - 自定义变量模拟多用户
    - JMeter命令行使用
    - Spring Boot 打 war 包
- 页面优化技术
    - 页面缓存 + URL缓存 + 对象缓存（减少对数据库的访问）
    - 页面静态化，前后端分离
    - 静态资源优化
    - CDN优化
- 接口优化
    - Redis预减库存减少数据库访问
    - 内存标记减少 Redis 访问
    - RabbitMQ队列缓冲，异步下单，增强用户体验
    - 访问 Nginx 水平扩展
    - 压测
- 安全优化
    - 秒杀接口地址隐藏
    - 数学公式验证码（拉长访问时间）
    - 接口防刷

# 准备工作

## 数据库

![image-20220214114241349](img\image-20220214114241349.png)

## 引入依赖

# 登录功能

## 密码加密

- 两次 MD5 做加密。加密的大致流程如下：
    - 用户端：Pass = MD5（明文+固定salt）
    - 服务端：Pass = MD5（用户输入+随机salt），为每个用户生成一个随机 salt
- 具体做法：
    - 用户在注册时，输入自己的信息和密码。密码在传输过程中做一次加密。MD5（明文+固定salt）
    - 服务器端接收到用户注册信息后，为这个用户生成一个随机的 salt，继续做一次加密 MD5（传输过来的+随机生成的salt），然后将用户信息和 salt 一起写入数据库。
    - 后面用户登录的时候，先查询一次用户信息，查询到 salt，在服务端做个判断 MD5（密码+salt） == 数据库存储的密码。





![image-20220214115419732](img\image-20220214115419732.png)

引入MD5 依赖。

![image-20220214120511746](img\image-20220214120511746.png)

## JSR 303校验

在 Controller 里写代码校验参数太麻烦了，这里我们采用 JSR303 进行参数校验。我们希望校验下手机号是否正确，JSR303并未提供，我们可以自己定义一个校验规则。

- 定义注解。定义的方式，抄 JSR303 注解就行
-  定义一个注解解析器。也是参考 JSR303 的实现。

jsr303 校验依赖

![image-20220214130753808](img\image-20220214130753808.png)

## 全局异常处理器

- `@ControllerAdvice` 注解 + `@ResponseBody` 注解。操作出现异常的时候，直接抛出异常。抛出异常时，全局处理器会拦截这个异常。

```java
public boolean login(){
    if(xxx){
        throw new GlobalException(CodeMessage.XXX);
    }
    return true;
}
```

## 分布式Session

- 用户登录成功后，为用户生成 Session ID 标识用户，然后写入 cookie 传给客户端，并把用户信息（session id--用户信息）存入一个三方缓存中。客户端每次请求用户的信息时，携带这个UUID给服务器，服务器就可以通过这个 Session ID 查询到用户的信息。
    - 有些手机客户端，不会把 token 放到 cookie 里传过来，而是放到参数里传过来。

- 延迟 cookie 有效期，可以使用 SpringMVC 的内容协商来简化用户信息的获取和 cookie 的延长。

# 压测

JMeter 压测

Redis 压测
![image-20220215180830670](C:\development\Code\note\CodeNotes\Project\img\image-20220215180830670.png)

# 打包

![image-20220215180954494](C:\development\Code\note\CodeNotes\Project\img\image-20220215180954494.png)

![image-20220215181332400](C:\development\Code\note\CodeNotes\Project\img\image-20220215181332400.png)

![image-20220215192735684](C:\development\Code\note\CodeNotes\Project\img\image-20220215192735684.png)

把页面缓存在客户端

# 接口幂等性

幂等性原本是数学上的概念，用在接口上就可以理解为：**同一个接口，多次发出同一个请求，必须保证操作只执行一次。** 调用接口发生异常并且重复尝试时，总是会造成系统所无法承受的损失，所以必须阻止这种现象的发生。

## 问题

- 网络波动, 可能会引起重复请求
- 用户重复操作,用户在操作时候可能会无意触发多次下单交易,甚至没有响应而有意触发多次交易应用
- 使用了失效或超时重试机制(Nginx重试、RPC重试或业务层重试等)
- 页面重复刷新
- 使用浏览器后退按钮重复之前的操作,导致重复提交表单
- 使用浏览器历史记录重复提交表单
- 浏览器重复的HTTP请求
- 定时任务重复执行
- 用户双击提交按钮

## 方案一

使用 token 机制。生成唯一ID 放入 redis，要执行操作前先查下 redis 里是否存在，如果相同的 key 已经放过了，则提示不允许此操作。如果是限定了，一定时间内不允许多次点击，redis 中可以设置内容的过期时间。

## 方案二

利用数据库唯一索引机制,当数据重复时,插入数据库会抛出异常,保证不会出现脏数据。
