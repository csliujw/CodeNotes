# 概述

应对大并发：

- 如何利用缓存
- 如何使用异步
- 优雅编写代码

> 秒杀

- 分布式会话
- 商品列表页
- 商品详情页
- 订单详情页
- 系统压测
- 缓存优化：先写数据库还是先写缓存。
- 消息队列：RabbitMQ 异步下单。
- 接口安全

## 整体流程

- Spring Boot 环境搭建
    - 继承 thymeleaf（后期改成layui），Result 结果封装
    - 继承 MyBatis + Druid
    - 继承 Jedis + Redis 安装 + 通用缓存 key 封装。
- 实现登录
    - 数据库设计
    - 明文密码两次 MD5
    - JSR303参数校验 + 全局异常处理器
    - 分布式 Session
- 实现秒杀
    - 数据库设计
    - 商品列表页
    - 商品详情页
    - 订单详情页
- JMeter 压测
    - JMeter 入门
    - 自定义变量模拟多用户
    - JMeter命令行使用
    - Spring Boot 打 war 包
- 页面优化技术
    - 页面缓存 + URL缓存 + 对象缓存（减少对数据库的访问）
    - 页面静态化，前后端分离
    - 静态资源优化
    - CDN优化
- 接口优化
    - Redis预减库存减少数据库访问
    - 内存标记减少 Redis 访问
    - RabbitMQ队列缓冲，异步下单，增强用户体验
    - 访问 Nginx 水平扩展
    - 压测
- 安全优化
    - 秒杀接口地址隐藏
    - 数学公式验证码（拉长访问时间）
    - 接口防刷

# 准备工作

## 数据库

```mysql
use miaosha;

/*
Navicat MySQL Data Transfer

Source Server         : miaosha
Source Server Version : 50562
Source Host           : localhost:3306
Source Database       : miaosha

Target Server Type    : MYSQL
Target Server Version : 50562
File Encoding         : 65001

Date: 2019-01-11 22:14:46
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for goods
-- ----------------------------
DROP TABLE IF EXISTS `goods`;
CREATE TABLE `goods` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '商品ID',
  `goods_name` varchar(16) DEFAULT NULL COMMENT '商品名称',
  `goods_title` varchar(64) DEFAULT NULL COMMENT '商品标题',
  `goods_img` varchar(64) DEFAULT NULL COMMENT '商品的图片',
  `goods_detail` longtext COMMENT '商品的详情介绍',
  `goods_price` decimal(10,2) DEFAULT '0.00' COMMENT '商品单价',
  `goods_stock` int(11) DEFAULT '0' COMMENT '商品库存，-1表示没有限制',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of goods
-- ----------------------------
INSERT INTO `goods` VALUES ('1', 'iphoneX', 'Apple iPhone X (A1865) 64GB 银色 移动联通电信4G手机', '/img/iphonex.png', 'Apple iPhone X (A1865) 64GB 银色 移动联通电信4G手机', '8765.00', '10000');
INSERT INTO `goods` VALUES ('2', '华为Meta9', '华为 Mate 9 4GB+32GB版 月光银 移动联通电信4G手机 双卡双待', '/img/meta10.png', '华为 Mate 9 4GB+32GB版 月光银 移动联通电信4G手机 双卡双待', '3212.00', '-1');
INSERT INTO `goods` VALUES ('3', 'iphone8', 'Apple iPhone 8 (A1865) 64GB 银色 移动联通电信4G手机', '/img/iphone8.png', 'Apple iPhone 8 (A1865) 64GB 银色 移动联通电信4G手机', '5589.00', '10000');
INSERT INTO `goods` VALUES ('4', '小米6', '小米6 4GB+32GB版 月光银 移动联通电信4G手机 双卡双待', '/img/mi6.png', '小米6 4GB+32GB版 月光银 移动联通电信4G手机 双卡双待', '3212.00', '10000');

-- ----------------------------
-- Table structure for miaosha_goods
-- ----------------------------
DROP TABLE IF EXISTS `miaosha_goods`;
CREATE TABLE `miaosha_goods` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '秒杀的商品表',
  `goods_id` bigint(20) DEFAULT NULL COMMENT '商品Id',
  `miaosha_price` decimal(10,2) DEFAULT '0.00' COMMENT '秒杀价',
  `stock_count` int(11) DEFAULT NULL COMMENT '库存数量',
  `start_date` datetime DEFAULT NULL COMMENT '秒杀开始时间',
  `end_date` datetime DEFAULT NULL COMMENT '秒杀结束时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of miaosha_goods
-- ----------------------------
INSERT INTO `miaosha_goods` VALUES ('1', '1', '0.01', '9', '2017-12-04 21:51:23', '2017-12-31 21:51:27');
INSERT INTO `miaosha_goods` VALUES ('2', '2', '0.01', '9', '2017-12-04 21:40:14', '2017-12-31 14:00:24');
INSERT INTO `miaosha_goods` VALUES ('3', '3', '0.01', '9', '2017-12-04 21:40:14', '2017-12-31 14:00:24');
INSERT INTO `miaosha_goods` VALUES ('4', '4', '0.01', '9', '2017-12-04 21:40:14', '2017-12-31 14:00:24');

-- ----------------------------
-- Table structure for miaosha_message
-- ----------------------------
DROP TABLE IF EXISTS `miaosha_message`;
CREATE TABLE `miaosha_message` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '消息主键',
  `messageid` bigint(20) NOT NULL COMMENT '分布式id',
  `content` text COMMENT '消息内容',
  `create_time` date DEFAULT NULL COMMENT '创建时间',
  `status` int(1) NOT NULL COMMENT '1 有效 2 失效 ',
  `over_time` datetime DEFAULT NULL COMMENT '结束时间',
  `message_type` int(1) DEFAULT '3' COMMENT '0 秒杀消息 1 购买消息 2 推送消息',
  `send_type` int(1) DEFAULT '3' COMMENT '发送类型 0 app 1 pc 2 ios',
  `good_name` varchar(50) DEFAULT '' COMMENT '商品名称',
  `price` decimal(10,2) DEFAULT '0.00' COMMENT '商品价格',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of miaosha_message
-- ----------------------------
INSERT INTO `miaosha_message` VALUES ('1', '533324506110885888', '尊敬的用户你好，你已经成功注册！', null, '0', null, null, '0', null, null);
INSERT INTO `miaosha_message` VALUES ('2', '533324506110885888', '尊敬的用户你好，你已经成功注册！', null, '0', null, null, '0', null, null);
INSERT INTO `miaosha_message` VALUES ('3', '533324506110885888', '尊敬的用户你好，你已经成功注册！', '2019-01-11', '0', null, null, '0', null, null);
INSERT INTO `miaosha_message` VALUES ('4', '533324506110885888', '尊敬的用户你好，你已经成功注册！', '2019-01-11', '0', null, null, '0', null, null);

-- ----------------------------
-- Table structure for miaosha_message_user
-- ----------------------------
DROP TABLE IF EXISTS `miaosha_message_user`;
CREATE TABLE `miaosha_message_user` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `userid` bigint(20) NOT NULL,
  `messageid` bigint(50) NOT NULL,
  `goodid` int(20) DEFAULT NULL,
  `orderid` int(20) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of miaosha_message_user
-- ----------------------------
INSERT INTO `miaosha_message_user` VALUES ('1', '1', '222', '22', '2');
INSERT INTO `miaosha_message_user` VALUES ('11', '22', '533324506110885888', null, null);
INSERT INTO `miaosha_message_user` VALUES ('12', '22', '533324506110885888', null, null);
INSERT INTO `miaosha_message_user` VALUES ('13', '22', '533324506110885888', null, null);
INSERT INTO `miaosha_message_user` VALUES ('14', '22', '533324506110885888', null, null);

-- ----------------------------
-- Table structure for miaosha_order
-- ----------------------------
DROP TABLE IF EXISTS `miaosha_order`;
CREATE TABLE `miaosha_order` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) DEFAULT NULL COMMENT '用户ID',
  `order_id` bigint(20) DEFAULT NULL COMMENT '订单ID',
  `goods_id` bigint(20) DEFAULT NULL COMMENT '商品ID',
  PRIMARY KEY (`id`),
  UNIQUE KEY `u_uid_gid` (`user_id`,`goods_id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1551 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of miaosha_order
-- ----------------------------
INSERT INTO `miaosha_order` VALUES ('1547', '18912341234', '1561', '1');
INSERT INTO `miaosha_order` VALUES ('1548', '18912341234', '1562', '2');
INSERT INTO `miaosha_order` VALUES ('1549', '18912341234', '1563', '4');
INSERT INTO `miaosha_order` VALUES ('1550', '18912341234', '1564', '3');

-- ----------------------------
-- Table structure for miaosha_user
-- ----------------------------
DROP TABLE IF EXISTS `miaosha_user`;
CREATE TABLE `miaosha_user` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '用户ID，手机号码',
  `nickname` varchar(255) NOT NULL,
  `password` varchar(32) DEFAULT NULL COMMENT 'MD5(MD5(pass明文+固定salt) + salt)',
  `salt` varchar(10) DEFAULT NULL,
  `head` varchar(128) DEFAULT NULL COMMENT '头像，云存储的ID',
  `register_date` datetime DEFAULT NULL COMMENT '注册时间',
  `last_login_date` datetime DEFAULT NULL COMMENT '上蔟登录时间',
  `login_count` int(11) DEFAULT '0' COMMENT '登录次数',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=18912341246 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of miaosha_user
-- ----------------------------
INSERT INTO `miaosha_user` VALUES ('18912341238', '18612766138', 'b7797cce01b4b131b433b6acf4add449', '1a2b3c4d', null, '2019-01-09 17:08:16', null, '0');
INSERT INTO `miaosha_user` VALUES ('18912341239', '18612766139', 'b7797cce01b4b131b433b6acf4add449', '1a2b3c4d', null, '2019-01-09 17:17:21', null, '0');
INSERT INTO `miaosha_user` VALUES ('18912341240', '18612766139', 'b7797cce01b4b131b433b6acf4add449', '1a2b3c4d', null, '2019-01-11 11:35:39', null, '0');
INSERT INTO `miaosha_user` VALUES ('18912341241', '18612766141', 'b7797cce01b4b131b433b6acf4add449', '1a2b3c4d', null, '2019-01-11 11:36:23', null, '0');
INSERT INTO `miaosha_user` VALUES ('18912341242', '18612766145', 'b7797cce01b4b131b433b6acf4add449', '1a2b3c4d', null, '2019-01-11 11:38:29', null, '0');
INSERT INTO `miaosha_user` VALUES ('18912341243', '18612766122', 'b7797cce01b4b131b433b6acf4add449', '1a2b3c4d', null, '2019-01-11 11:41:52', null, '0');
INSERT INTO `miaosha_user` VALUES ('18912341244', '18612766133', 'b7797cce01b4b131b433b6acf4add449', '1a2b3c4d', null, '2019-01-11 11:43:24', null, '0');
INSERT INTO `miaosha_user` VALUES ('18912341245', '18612766444', 'b7797cce01b4b131b433b6acf4add449', '1a2b3c4d', null, '2019-01-11 13:44:29', null, '0');

-- ----------------------------
-- Table structure for order_info
-- ----------------------------
DROP TABLE IF EXISTS `order_info`;
CREATE TABLE `order_info` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) DEFAULT NULL COMMENT '用户ID',
  `goods_id` bigint(20) DEFAULT NULL COMMENT '商品ID',
  `delivery_addr_id` bigint(20) DEFAULT NULL COMMENT '收获地址ID',
  `goods_name` varchar(16) DEFAULT NULL COMMENT '冗余过来的商品名称',
  `goods_count` int(11) DEFAULT '0' COMMENT '商品数量',
  `goods_price` decimal(10,2) DEFAULT '0.00' COMMENT '商品单价',
  `order_channel` tinyint(4) DEFAULT '0' COMMENT '1pc，2android，3ios',
  `status` tinyint(4) DEFAULT '0' COMMENT '订单状态，0新建未支付，1已支付，2已发货，3已收货，4已退款，5已完成',
  `create_date` datetime DEFAULT NULL COMMENT '订单的创建时间',
  `pay_date` datetime DEFAULT NULL COMMENT '支付时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1565 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of order_info
-- ----------------------------
INSERT INTO `order_info` VALUES ('1561', '18912341234', '1', null, 'iphoneX', '1', '0.01', '1', '0', '2017-12-14 22:49:10', null);
INSERT INTO `order_info` VALUES ('1562', '18912341234', '2', null, '华为Meta9', '1', '0.01', '1', '0', '2017-12-14 22:55:42', null);
INSERT INTO `order_info` VALUES ('1563', '18912341234', '4', null, '小米6', '1', '0.01', '1', '0', '2017-12-16 16:19:23', null);
INSERT INTO `order_info` VALUES ('1564', '18912341234', '3', null, 'iphone8', '1', '0.01', '1', '0', '2017-12-16 16:35:20', null);

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(10) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES ('1', 'Joshua');
```

## 引入依赖

## Redis



# 登录功能

## 密码加密

- 两次 MD5 做加密。加密的大致流程如下：
    - 用户端：Pass = MD5（明文+固定salt）
    - 服务端：Pass = MD5（用户输入+随机salt），为每个用户生成一个随机 salt
- 具体做法：
    - 用户在注册时，输入自己的信息和密码。密码在传输过程中做一次加密。MD5（明文+固定salt）
    - 服务器端接收到用户注册信息后，为这个用户生成一个随机的 salt，继续做一次加密 MD5（传输过来的+随机生成的salt），然后将用户信息和 salt 一起写入数据库。
    - 后面用户登录的时候，先查询一次用户信息，查询到 salt，在服务端做个判断 MD5（密码+salt） == 数据库存储的密码。

引入MD5 依赖。

```xml
<dependency>
	<groupId>commons-codec</groupId>
    <artifactId>commons-codec</artifactId>
</dependency>
<dependency>
	<groupId>org.apache.commons</groupId>
    <artifactId>commons-lang3</artifactId>
    <version>3.6</version>
</dependency>
```

## JSR 303校验

在 Controller 里写代码校验参数太麻烦了，这里我们采用 JSR303 进行参数校验。我们希望校验下手机号是否正确，JSR303并未提供，我们可以自己定义一个校验规则。

- 定义注解。定义的方式，抄 JSR303 注解就行
-  定义一个注解解析器。也是参考 JSR303 的实现。

jsr303 校验依赖

```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

## 全局异常处理器

- `@ControllerAdvice` 注解 + `@ResponseBody` 注解。操作出现异常的时候，直接抛出异常。抛出异常时，全局处理器会拦截这个异常。

```java
public boolean login(){
    if(xxx){
        throw new GlobalException(CodeMessage.XXX);
    }
    return true;
}
```

## 分布式Session

- 用户登录成功后，为用户生成 Session ID 标识用户，然后写入 cookie 传给客户端，并把用户信息（session id--用户信息）存入一个三方缓存中。客户端每次请求用户的信息时，携带这个UUID给服务器，服务器就可以通过这个 Session ID 查询到用户的信息。
    - 有些手机客户端，不会把 token 放到 cookie 里传过来，而是放到参数里传过来。

- 延迟 cookie 有效期，可以使用 SpringMVC 的内容协商来简化用户信息的获取和 cookie 的延长。

# 秒杀功能

- 数据库设计
- 商品列表页
- 商品详情页
- 订单详情页

正常梳理业务流程，修改&写入数据库。

## 数据库设计

- 商品表（内容稳定）、秒杀商品表（临时选择）
- 订单表、秒杀订单表

# 压测

## JMeter 压测

- 入门
    - 设置中文界面。打开[apache](https://so.csdn.net/so/search?q=apache&spm=1001.2101.3001.7020)-jmeter-5.0\bin\jmeter.properties 文件修改language=zh_CN，重新打开就是中文界面了
- 自定义变量模拟多用户
    - 测试计划 -> 添加配置元件 -> CSV Data Set Config
    - 引用变量 `${}`
- JMeter 命令行使用

> 测试结果

- User 接口 QPS 高，测试发现 redis 连接数不够，调大 redis 连接数。Goods QPS 低，因为它读了缓存和数据库；User QPS 高，因为他只读了缓存。
- 出现了超卖。并发问题。

## Redis 压测

- redis-benchmark -h 127.0.0.1 -p 6379 -c 100 -n 100000   100个并发连接，100000个请求
- redis-benchmark -h 127.0.0.1 -p 6379 -q -d  100，存取大小为 100 字节的数据包

## 打包

<img src="img\image-20220215180954494.png">

![image-20220215181332400](C:\development\Code\note\CodeNotes\Project\img\image-20220215181332400.png)



# 页面优化

- 页面缓存+URL缓存+对象缓存
- 页面静态化，前后端分离
- 静态资源优化
- CDN优化

## 页面缓存

不是让系统帮我们渲染，而是先从缓存中拿，缓存中没有再渲染。这就需要我们手动渲染模板了，查阅文档，是使用 thymeleafViewResolver 进行渲染的。

GoosKey --> 商品页面缓存。

## URL 缓存

和页面缓存其实一样。只是商品有不同的编号，我用 Goods:1:xxx 缓存1号商品的页面，用 Goods:2:xxx 缓存2号商品的页面。

## 对象缓存

将用户信息缓存在 redis 中。每次取用户信息就取缓存中的，存在则拿，不存在则查数据库再存入缓存。

## 前后端分离

只传输需要变化的数据，减小服务器压力。

## 页面静态化

- 前后端分离，只传动态的数据，减少数据的发送量，减轻服务器压力.
- GET POST的区别:
    - HTTP协议并未规定GET\POST数据的传输量,只是浏览器厂商这么做.
    - GET请求是幂等的,POST不是幂等的.
    - `<a href="/delete?id=13">` 如果是 GET,搜索引擎在搜索页面的时候,会遍历页面中的链接,会执行这些链接.
- 除了前后端分离，还可以通过 cache-controll 告诉浏览器缓存这个页面，下次查询的时候直接查浏览器缓存。
    - Pragma ，HTTP1.0 可用
    - Expire ，HTTP1.1/1.0 可用，带时区的
    - Cache-Control ，HTTP1.1/1.0 可用 `cache-control:max-age 3600`

## 超卖

update 的 sql 语句会加行锁。update xx xxx xx where count>1; 利用数据库的唯一索引（用户id+goods id建立唯一索引），避免重复下单。

生成订单的时候，把订单写到缓存里，然后就不需要查数据库了，查缓存就行。

解决超卖用的 SQL 和唯一索引。有没有其他办法。

## 静态资源优化

- JS/CSS 压缩，减少流量
- 多个JS/CSS组合，减少连接数。由服务器实现->Tengine.
- CND 就近访问，加速数据请求。

# 接口优化

- Redis 预减库存减少数据库访问
- 内存标记减少 Redis 访问
- 请求先入对缓冲，异步下单，增强用户体验
- RabbitMQ 安装与 Spring Boot 集成
- Nginx 水平扩展
- 压测

## 秒杀接口优化

思路：减少数据库访问

- 1.系统初始化，把商品库存数量加载到 Redis
- 2.收到请求，Redis 预减库存，库存不足，直接返回，否则进入3
- 3.请求入队，立即返回排队中（不知道请求成功还是失败，Redis只是做了一个预减）
- 4.请求出队，生成订单，减少库存
- 5.收到排队中的消息后，客户端会轮询，是否秒杀成功

## 集成RabbitMQ

- 安装 MQ，直接用 docker 运行 rabbitmq。

## Spring Boot集成

- 添加依赖 spring-boot-starter-amqp
- 创建消息接收者
- 创建消息发送者

```java
// 消息发送者
@Service
public class MQSender{
    @Autowired
    AmqtTemplate amqtTemplate;
    
    public void send(Object message){
        String msg = message.toString();
        amqtTemplate.convertAndSend(MQConfig.QUEUE,msg);
    }
}

// 消息接收者
@Service
public class MQReceiver{
    @RabbitListener(queues=MQConfig.QUEUE);
    public void receive(String message){
    	System.out.println(message);
    }
}

// 配置
@Configuration
public class MQConfig{
    private final static String QUEUE = "queue";
    @Bean
    public Queue queue(Object message){
        // 把 message 转成 字符串。
        return new Queue(QUEUE,true,msg)
    }
}
```

## RabbitMQ消息传递模型

之前写的那QT个发消息的，用的就是类似消息队列的模式。生产者生成放数据，多个消费者消费数据（发送数据）。

一共有四种模式：direct、topic、headers、fanout。

### fanout

广播模式。一个生产者发送了数据，多个订阅了这个消息的消费者可以接收到。简单的讲，就是把交换机（Exchange）里的消息发送给所有绑定该交换机的[队列](https://so.csdn.net/so/search?q=队列&spm=1001.2101.3001.7020)，**忽略**[routingKey](https://blog.csdn.net/fakerswe/article/details/81455340#lct)。

```mermaid
graph LR
生产者生成消息--->交换机--->订阅了这个消费者的用户队列1
交换机--->订阅了这个消费者的用户队列2
交换机--->订阅了这个消费者的用户队列3
```

### Direct

直连交换机意思是此交换机需要绑定一个队列，要求**该消息与一个特定的路由键完全匹配**。简单点说就是一对一的，点对点的发送。

```mermaid
graph LR
Product--->direct-exchange==black==>queue1绑定的名称为black和green
direct-exchange==orange==>queue2绑定的名称为orange
direct-exchange==green==>queue1绑定的名称为black和green
```

```java
@Configuration
public class RabbtMQDirectConfig{
	// 队列在绑定交换机的时候，指定对应的 routingKey
    //（可以认为是Queue的名字，可以有多个）
    // 发送消息的时候，指定交换机和routingKey
    
    rabbitTemplate.converAndSend("exchangeName","black",message);
}
```

### topic

通配符匹配 routingKey。

## 模式

- Direct 模式，交换机 Exchange。先把数据发送到交换机上，交换机再把数据发送到队列上，做了一个路由。
- Topic 模式，

# 接口幂等性

幂等性原本是数学上的概念，用在接口上就可以理解为：**同一个接口，多次发出同一个请求，必须保证操作只执行一次。** 调用接口发生异常并且重复尝试时，总是会造成系统所无法承受的损失，所以必须阻止这种现象的发生。

## 问题

- 网络波动, 可能会引起重复请求
- 用户重复操作,用户在操作时候可能会无意触发多次下单交易,甚至没有响应而有意触发多次交易应用
- 使用了失效或超时重试机制(Nginx重试、RPC重试或业务层重试等)
- 页面重复刷新
- 使用浏览器后退按钮重复之前的操作,导致重复提交表单
- 使用浏览器历史记录重复提交表单
- 浏览器重复的HTTP请求
- 定时任务重复执行
- 用户双击提交按钮

## 方案一

使用 token 机制。生成唯一ID 放入 redis，要执行操作前先查下 redis 里是否存在，如果相同的 key 已经放过了，则提示不允许此操作。如果是限定了，一定时间内不允许多次点击，redis 中可以设置内容的过期时间。

## 方案二

利用数据库唯一索引机制,当数据重复时,插入数据库会抛出异常,保证不会出现脏数据。
