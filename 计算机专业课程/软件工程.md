# 杂记

高内聚：尽可能类的每个成员方法只完成一件事（最大限度的聚合）； 低耦合：减少类内部，一个成员方法调用另一个成员方法。

**降低耦合度的方法**

1、少使用类的继承，多用接口隐藏实现的细节。 Java面向对象编程引入接口除了支持多态外， 隐藏实现细节也是其中一个目的。

2、模块的功能化分尽可能的单一，道理也很简单，功能单一的模块供其它模块调用的机会就少。（其实这是高内聚的一种说法，高内聚低耦合一般同时出现）。

3、遵循一个定义只在一个地方出现。

4、少使用全局变量。

5、类属性和方法的声明少用public，多用private关键字。

6、多用设计模式，比如采用MVC的设计模式就可以降低界面与业务逻辑的耦合度。

7、尽量不用“硬编码”的方式写程序，同时也尽量避免直接用SQL语句操作数据库。

8、最后当然就是避免直接操作或调用其它模块或类（内容耦合）；如果模块间必须存在耦合，原则上尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，避免使用内容耦合。

**增强内聚度方法**

1、模块只对外暴露最小限度的接口，形成最低的依赖关系。

2、只要对外接口不变，模块内部的修改，就不得影响其他模块。

3、删除一个模块，应当只影响有依赖关系的其他模块，而不应该影响其他无关部分。

# 软件工程学概述

> **没有银弹**：一个典型的失败的产品：IBM 360 System

## 软件危机

> 软件维护工作以吃惊的比例耗费资源，许多程序的个体化特效使得它们最终成为不可维护的。==> 软件危机

软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重的问题。几乎所有软件都不同程度地存在危机。

软件危机包含下述两个方面：

- 如何开发软件，以满足对软件日益增长的需求。
- 如何维护数量不断膨胀的已有软件。

> **软件危机的典型表现**

- 对软件开发的成本和进度的估计常常不准确。【人和月是否可以交换？单纯的增加人数不一定可以提高开发效率，只有当这些功能模块相互独立，没有关联时，增加人手可以提高开发效率】【人是指开发人员；月是指软件开发的时间单位。一个工程师一个月的开发效率记为一个人月。】
- 用户对“已经完成”的软件系统不满意的现象经常发生。用户和开发人员直接的交流不充分，开发人员对用户要求只有模糊的了解【项目经理的作用？？】
- 软件产品的质量往往靠不住。【软件的质量保证技术不行，软件测试质量不过关，没有坚持软件测试】
- 
  - '=.;;.	QW	QWER	 '软件常常是不可维护的。【很多程序的错误是非常难改正1 ]\】
- 软件通常没有适当的文档资料。

> **产生软件危机的原因**

- 与软件本身的特性有关。
- 与软件开发与维护的方法不正确有关
  - 软件开发过程的进展情况较难衡量，软件质量也难以评估。
  - 规模大，程序的复杂性随着规模的增大呈指数上升。
  - 在规定时间内，由多人开发出一个高质量的大型软件系统，是一个很复杂的问题。涉及许多技术。如人员的分配，技术问题，分析，设计和版本的迭代。

程序只是完整软件的一部分。一个完整的软件产品，应包含程序，文档和数据等成分。不能只注重程序本身，还要重视其他的配置。同时，在不同的开发时期进行修改要付出的代价事不同的。早期引入的变动成本较小，越到后期引入变动成本越高。

由于软件产品的使用周期很长，且不会想硬件一样自然损耗，软件的维护也显得格外重要。在漫长的使用时间中，要能及时改正发现的错误。

## 软件工程

### 定义

软件工程事指导计算机软件开发和维护的一门工程学科。把经过时间验证而证明正确的管理技术和当前的优秀技术方法结合起来，以经济地开发出高质量地软件并有效地维护它【指导计算机软件开发和维护。用成熟地管理技术和当前优秀地技术方法，经济高效地开发出高质量的软件并有效维护它】

### 本质特性

- 关注大型程序的构造
- 中心课题事控制复杂性
- 软件经常变化，要考虑其可扩展性
- 开发效率和重要
- 和谐合作是关键
- 软件是为用户而制作的，需要可以有效的支持它的用户

### 软件工程方法学

> **在软件生命周期全过程中使用的一整套技术方法的集合称为方法学。**

软件工程方法学包括三个要素：方法、工具、过程

- 方法：完成软件开发的各项任务的技术方法，==回答怎样做==
- 工程：为运用方法而提供的自动的或半自动的软件工程支持环境
- 过程：为了获得高质量的软件所需要完成的一系列任务的框架，规定了完成各项任务的工作步骤。

**传统方法学**：使用结构化技术来完成软件开发的各项任务。【基本思想：把一个复杂问题的求解过程分阶段进行，而且这种分解是自顶向下，逐层分解，使得每个阶段处理的问题都控制在人们容易理解和处理的范围内。】

**面向对象方法学**：把面向对象的思想应用于软件开发过程中，指导开发活动的系统方法,对象是由数据和容许的操作组成的封装体，与客观实体有直接对应关系，一个对象类定义了具有相似性质的一组对象。【基本思想：尽可能模拟人类习惯的思维方式，使开发软件的方法与过程尽可能接近人类认识世界、解决问题的方法与过程, 也就是使描述问题的问题空间与实现解法的求解空间在结构上尽可能一致】

**对比**：

- 结构化方法的基本单位是模块。
- 面向对象方法的基本单位是对象。

----

## 软件生命周期

> **由软件定义，软件开发，运行维护三个时期组成**

### 软件定义

任务：确定软件开发工程必须完成的总目标；确定工程的可行性；系统必须完成的功能；估计完成工程需要的资源和成本，指定对于的进度表。

### 软件开发

任务：设计和实现前一时期定义的软件

**通常由四个阶段组成**：总体设计；详细设计；编码；单元测试；综合测试

### 运行维护

使软件持久地满足用户的需要。

### 软件生命周期阶段

#### 问题定义

要解决的问题是什么

#### 可行性研究

对于该问题是否有可行的解决办法

#### 需求分析

不具体地解决问题，而是准确地确定“为解决这个问题，目标系统必须做什么”，主要是确定目标系统必须具备那些功能。

#### 总体设计【概要设计】

该如何实现目标系统；设计程序的体系结构。确定程序由那些模块组成以及模块间的关系

#### 详细设计

把解决方法具体化；该如何具体地实现这个系统。详细设计也成为模块设计。在这个阶段详细地设计每个模块，确定实现模块功能所需要地算法和数据结构

#### 编码和单元测试

写出正确的容易理解的、容易维护的程序模块，并仔细测试编写出每一个模块。

#### 综合测试

通过各种类型的测试使软件达到预定的要求【集成测试；验收测试】

#### 软件维护

通过各种必要的维护活动使系统持久化地满足用户地需求

## 软件过程【开发模型】

### 概述

> **常见的软件过程模型**

- 瀑布模型
- 快速原型模型
- 增量模型
- 螺旋模型
- 边做边改模型
- 喷泉模型

### 瀑布模型

瀑布模型规定了各项软件工程活动，【包括：制定软件项目计划，进行需求分析和定义，软件设计，程序编码，测试及运行维护】并且规定了它们自上而下，相互衔接的固定次序，如同瀑布流水，逐级下落

#### 优点

可强迫开发人员采用规范地方法；严格的规定了每个阶段必须提交文档；要求每个阶段交出的所有产品都必须经过质量保证小组的仔细验证。

#### 缺点

在把软件交付给用户前，用户只能通过文档来了解产品。由于双方的交流存在偏差，会导致用户得不到满意的铲平。

### 快速原型模型

快速建立起可在计算机上运行的程序，让用户试用，再更具用户的试用反馈快速地修改原型系统。

#### 优点

可以得到比较良好的需求定义，容易适应需求的变化；有利于开发与培训的同步；费用低、开发周期短且对用户更友好。

#### 缺点

客户与开发者对原型理解不同； 准确的原型设计比较困难； 不利于开发人员的创新。

### 增量模型

把软件产品作为一系列的增量构建来设计、编码、集成和测试。

#### 优点

优点是人员分配灵活，刚开始不用投入大量人力资源；能在较短时间内向用户提交已完成的部分功能；且这样不断地给用户一小部分功能，可以给用户充足地时间学习和适用这个系统。

#### 缺点

并行开发构件有可能遇到不能集成的风险，软件必须具备开放式的体系结构；变化的能力大大优于瀑布模型和快速原型模型，但也很容易退化为边做边改模型，从而是软件过程的控制失去整体性

### 螺旋模型

使用原型及其他方法来尽量降低风险。

#### 优点

灵活性,可以在项目的各个阶段进行变更.计算变得简单容易；客户始终参与每个阶段的开发,保证了项目不偏离正确方向以及项目的可控性.

#### 缺点

需要具有相当丰富的风险评估经验和专门知识，在风险较大的项目开发中，如果未能够及时标识风险，势必造成重大损失；会增加开发成本，延迟提交时间。

#### 适用范围

螺旋模型只适合于大规模的软件项目。

# 可行性研究

## 概述

可行性分析的目的是为了确定问题是否值得去解决！

## 分类

- 技术可行性：使用现有技术可以实现这个系统吗？
- 经济可行性：这个系统的经济效益能够超过它的开发成本【应该说：这个系统带来的经济效益值得我去做吗】
- 操作可行性：系统的操作方式在这个用户组内行得通吗？【用户是否可以适应使用这个系统】

# 需求分析

## 概述

**了解用户需求，准确回答系统必须做什么！对目标系统提出完整，准确，清晰，具体的要求**

在可行性研究阶段，粗略地了解了用户的需求，甚至提出了一些可行的方案，但是忽略了许多细节，并没有准确回答系统必须做什么这个问题！因此不能替代需求分析！

## 确定对系统的综合要求

### 功能需求

系统必须提供的服务。通过需求分析，划分出系统必须完成的所有功能。

### 性能需求

系统必须满足的定时约束或容量约束。通常包括响应速度，信息量速率，主存容量，安全性等方面

### 可靠性和可用性需求

可靠性：如每月出错的次数不能太多。

可用性：确保系统绝大多数时间是可以正常运行的。

### 出错处理需求

系统出现错误时该如何处理，给用户怎样的反馈。

### 接口需求

描述应用系统与它的环境通信的格式。

### 约束

设计和实现系统时应遵守的限制条件

### 逆向需求

说明软件不应做什么

### 将来可能提出的要求

那些不属于当前系统的开发范畴，但是以后可能会提出这类要求，对系统进行扩展。

# 总体设计

## 概述   

概况地说，系统应该如何实现。

总体设计又称为概要设计或初步设计。可以站在全局高度上，花较少地成本，从较抽象地层次分析对比多种可能的实现方案和软件结构，从中选择出最佳方案和最合理的软件结构，从而用较低成本开发出质量较高的软件系统。【从全局的观点出发，对比各种可能的方案，选出最佳的最合理的软件结构，减少成本！】

## 设计过程

总体设计过程由**两个主要阶段组成**：**系统设计阶段**，确定系统的具体实现方案；**结构设计阶段**，确定软件结构。

### 步骤

- 设想供选择的方案
- 选取合理的方案
- 推荐最佳方案
- 功能分解
- 设计软件结构
- 设计数据库
- 制定测试计划
- 书写文档
- 审查和复审

# 详细设计

确定应该怎样具体地实现所要求地系统。经过这个阶段的设计工作，应该得出对目标系统得精确描述，从而在编码阶段可以把这个描述直接翻译称用某种程序设计语言书写得程序。【设计出程序的蓝图，程序员根据蓝图去书写程序】

# 实现

## 概述

实现包括编码和测试。测试应该横跨编码的整个时期，无论如何强调测试都不为过！

**编码**：把程序设计的结果变成代码。

**测试的重要性：**无论如何强调软件测试的重要性和它对软件可靠性的影响都不为过。

**测试的目的：**在软件投入生产性运行之前，尽可能多发现软件中的错误。软件测试是保证软件质量的关键步骤，是对软件规格说明，设计和编码的最后复审。

**软件测试占比：**软件测试的工作量往往占总工作量的40%以上！

**测试总结：**测试是为了发现软件的错误，最终目的还是为了保证开发的质量符合用户的要求！

## 编码

- 选择程序设计语言
- 确定编码风格
  - 统一编码风格，便于阅读和维护。

谈谈个人理解吧，个人认为书上写的不是很好懂。

首先，选择合适的语言来开发系统。不同的语言擅长的场景是不一样的，开发效率也不一样。选择一门合适的语言即可减少开发难度，又可以提升编码效率。

其次，规定编码风格。统一编码风格可以让整个系统看起来想一个人写的，风格统一，便于后期的阅读，修复和扩展功能。

再者，为代码添加恰当的注释，程序的开发一般周期性较长，即便是自己写的代码，长时间不去看也会很陌生。为代码添加恰当的注释可有效避免这种问题。

避免复杂逻辑的书写，尽量将其拆分为多个简单逻辑，有利于阅读和调试。

输入输出是进行数据的合法校验，避免被攻击。

## 软件测试基础

软件测试，竭力证明程序中有错误，从而完善程序，满足用户需求。软件测试应从小规模开始，这样方便定位错误！

### 软测目标

发现程序中的错误。

成功的测试是发现程序中未被发现过的错误。

### 软测准则

所有测试都应该追溯到用户需求【为用户的需求而服务】

应在测试之前就制定出测试计划

把`pareto`原理应用到软件测试中

​	软件测试-Pareto法则（8：2）

`pareto`含义：【这和计组的那个RISC & CISR一样！！！】

- 80%的软件缺陷生存在软件20%的空间里

- 20%的缺陷消耗80%的维护费用

- 20%的原因导致80%的缺陷

应该先从小规模测试开始，并逐步进行大规模测试。

**穷举测试是不可能的。**把执行路径都检查一遍的测试是不可能的。即便是中等规模的程序，其执行路径的排列数，输入数据的各种组合，也十分庞大。受限于时间、人力以及其他资源的限制，不可能执行每个可能的路径。【==只能证明程序中有错误，无法证明无错误==】

**为达到最佳测试效果**应雇佣专业的测试人员进行测试！程序员自己对自己写的程序有谜之自信，很难发现那些错误。【我写代码的时候，你看起来是密密麻麻的代码，实际上满屏幕只有两个字，**自信**】

### 测试方法

#### **黑盒测试**

> **测试每个功能是否都能正常使用**

将程序看成不能打开的黑盒子，不考虑程序内部结构和特性的基础上通过程序接口进行测试。**黑盒测试又称为功能测试**

#### 白盒测试【要会代码】

> **知道内部工作过程，可以通过测试来检验产品内部动作是否按照规格说明书的规定正常运行**

白盒测试下，软件程序被看做是一个打开的盒子，测试者完全知道程序的结构和处理算法。测试者按照程序内部的逻辑测试程序，检测程序中的主要执行通路是否都能按预定要求正确工作。

### 测试步骤

> **直接测试一个完整的系统是不切实际的，测试过程应分步骤进行。**

- **模块测试**：对于独立的，与其他模块无依赖关系的模块，可作为一个单独的实体来进行测试。模块测试又称为单元测试，保证每个模块作为一个单元都能正常运行。**这个测试步骤中所能发现的往往是编码和详细设计的错误。**
- **子系统测试**：把经过单元测试的模块放在一起形成一个子系统来测试。**模块相互间的协调和通信是这个测试过程中的主要问题。**
- **系统测试**：把经过测试的子系统装配成一个完整的系统来测试。这个过程中不仅应该发现设计和编码的错误，还应该验证系统确实能提供需求说明中的功能。**这个测试步骤发现的往往是软件设计中的错误，也可能发现需求说明中的错误。**
- **验收测试**：把软件系统作为单一的实体进行测试。确保系统的确可以满足用户需求。**这个步骤发现的往往是系统需求说明书中的错误**。**也称为确认测试**
- **平行运行**：如果有旧系统的花，比较新开发出的系统和旧系统的处理结果。可以让用户有一段熟悉新系统的时间。

## 单元测试

## 集成测试

## 确认测试

## 白盒测试技术

## 黑盒测试技术

# 维护

# 软件项目管理

# UML

## 用例视图--静态建模

定义了系统的外部行为，是最终用户、分析人员和测试人员所关心。该视图定义了系统**的需求。**

**执行者：**描述与系统交互的人或物，代表外部实体【如用户或其他软件系统】

用例的粒度能粗就不要细。

**执行者之间的关系：**

- 泛化关系【一般和特殊的关系。符号化表示为 特殊执行者指向一般执行者】

**用例之间的关系：**

- 关联关系：可以1对1，1对多等

- 包含关系：一个基本行为包含另一个基本行为。

- 扩展关系：不允许随便扩展，只能在指定的扩展点进行扩展。【扩展的指向基本的】

- 泛化关系：


## 类图对象图--静态建模

### 类图

表达类与类之间的静态关系

属性的可见性：公有（+） 私有（-） 保护（#）

### 对象图

### 包

## 设计视图

描述了支持用例视图中规定的功能需求的逻辑结构。

## 实现视图

描述构造系统的物理组件

## 进程视图

包括形成关于并发和同步机制的进程和线程

## 部署视图

部署视图描述物理组件如何在系统运行的实践环境中分布【这个组件在系统的那个硬件上运行】

# 常见设计模式

## 单例模式：

> **保证一个类仅有一个实例，并提供一个访问它的全局访问点。**

这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

### 注意：

1、单例类只能有一个实例。

2、单例类必须自己创建自己的唯一实例。

3、单例类必须给所有其他对象提供这一实例。

### 优点：

- 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。
- 避免对资源的多重占用（比如写文件操作）。

### 缺点：

- 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。

### 几种实现

**第一种方式（饿汉式线程安全）：**

```java
/**
 * 饿汉式
 * 类加载到内存后，就实例化一个单例，JVM保证线程安全
 * 简单实用，推荐使用！
 * 唯一缺点：不管用到与否，类装载时就完成实例化
 * Class.forName("")
 * （话说你不用的，你装载它干啥）
 */
public class Mgr01 {
	//定义一个静态实例
    private static final Mgr01 INSTANCE = new Mgr01();

	//这一步很重要，设置成私有的，别人不能调用
    private Mgr01() {};
	
	//如果别人想用只能调用getInstance方法
    public static Mgr01 getInstance() {
        return INSTANCE;
    }

    public void m() {
        System.out.println("m");
    }

    public static void main(String[] args) {
        Mgr01 m1 = Mgr01.getInstance();
        Mgr01 m2 = Mgr01.getInstance();
        System.out.println(m1 == m2);java
    }
}
```

**第二种方式（懒汉式线程不安全）：**

```java
/**
 * lazy loading
 * 懒汉式
 * 虽然达到了按需初始化的目的，但却带来线程不安全的问题 
 */
public class Mgr03 {
	// 不初始化INSTANCE
    private static Mgr03 INSTANCE;
    
	// 不初始化就new不出来
    private Mgr03() {
    }
    
	// 进行判断，为null了，在初始化 
    public static Mgr03 getInstance() {
        if (INSTANCE == null) {
			try {
            	Thread.sleep(1);
        	} catch (InterruptedException e) {
            	e.printStackTrace();
        	}
            INSTANCE = new Mgr03();
        } 
        return INSTANCE;
    }

    public void m() {
        System.out.println("m");
    }

    public static void main(String[] args) {
        for(int i=0; i<100; i++) {
			//"->":这是lambda表达式,一种语法,可以简化代码,从java8开始支持lambda表达式
            new Thread(()->
                System.out.println(Mgr03.getInstance().hashCode())
            ).start();
        }java
    }
}
```

**执行过程：**

- 多线程的时候，执行到if判断时，第一根线程在判断中，这是另一线程进来了，他比第一根快，他也进行判断，因为还没有new Mgr03，所以为null，这是他继续向下执行，执行到INSTANCE = new Mgr03();他new了一个Myr03，这时第一根线程执行完了，他也new了一个Myr03，这时就有两个INSTANCE对象，所以带来了更大的问题，怎么判断是否有两个呢，Mgr03.getInstance().hashCode()，每一个hashCode的码值是不一样的这里我们循环了100个，结果不一样就说明new出了多个INSTANCE，一样就没有，因为在执行的时候睡了1毫秒，码值就乱了，所以执行结果是不一样的

  ![在这里插入图片描述](http://mashibing.com/html/img/20190618174111115.jpg)

我们来看第三种方式怎么解决的

**第三种方式（懒汉式线程安全&双检锁）：**

```java
/**
 * lazy loading
 * 懒汉式
 * 虽然达到了按需初始化的目的，但却带来线程不安全的问题
 * 可以通过synchronized解决，但也带来效率下降
 * 这是目前好的解决方法之一
 */
public class Mgr06 {
    private static volatile Mgr06 INSTANCE; //JIT

    private Mgr06() {
    }

    public static Mgr06 getInstance() {
        if (INSTANCE == null) {
            //双重检查
            synchronized (Mgr06.class) {
				//拿到锁之后如果还为空那就不执行了，为空执行不下去了
                if(INSTANCE == null) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    INSTANCE = new Mgr06();
                }
            }
        }
        return INSTANCE;
    }

    public void m() {
        System.out.println("m");
    }

    public static void main(String[] args) {
        for(int i=0; i<100; i++) {
            new Thread(()->{
                System.out.println(Mgr06.getInstance().hashCode());
            }).start();
        }
    }
}
```

**第四种方式（静态内部类）：**

```java
/**
 * 静态内部类方式(JVM帮我们保证线程安全)
 * JVM保证单例
 * 加载外部类时不会加载内部类，这样可以实现懒加载
 */
public class Mgr07 {

    private Mgr07() {
        
    }

    private static class Mgr07Holder {
        private final static Mgr07 INSTANCE = new Mgr07();
    }

    public static Mgr07 getInstance() {
        return Mgr07Holder.INSTANCE;
    }

    public void m() {
        System.out.println("m");
    }

    public static void main(String[] args) {
        for(int i=0; i<100; i++) {
            new Thread(()->{
                System.out.println(Mgr07.getInstance().hashCode());
            }).start();
        }
    }
}
```

**第五种方式（枚举）：**

```java
/**
 * 枚举单例（完美的单例模式）
 * 不用担心线程安全问题
 * 不仅可以解决线程同步，还可以防止反序列化。
 */
public enum Mgr08 {
	//唯一的取值，下面的调用只能调用这一个，没有争议
    INSTANCE;

	//剩下的都是业务方法
    public void m() {}

    public static void main(String[] args) {
        for(int i=0; i<100; i++) {
            new Thread(()->{
                System.out.println(Mgr08.INSTANCE.hashCode());
            }).start();
        }
    }
}
```

## 策略模式

> **把对象本身和运算规则区分开来。**

### 策略模式优点

- 我们之前在选择出行方式的时候，往往会使用if-else语句，也就是用户不选择A那么就选择B这样的一种情况。这种情况耦合性太高了，而且代码臃肿，有了策略模式我们就可以避免这种现象，策略模式遵循开闭原则，实现代码的解耦合。扩展新的方法时也比较方便，只需要继承策略接口就好了上面列出的这两点算是策略模式的优点了
- 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。策略模式会出现很多的策略类。context在使用这些策略类的时候，这些策略类由于继承了策略接口，所以有些数据可能用不到，但是依然初始化了。2、与其他模式的区别？

### 与状态模式的区别

策略模式只是条件选择方法，只执行一次方法，而状态模式是随着状态的改变不停地更改执行方法。举个例子，就好比我们旅游，对于策略模式我们只需要选择其中一种出行方法就好了，但是状态模式不一样，可能我们到了A地点选择的是火车，到了B地点又选择飞机，根据不同的状态选择不同的出行方式。

### 与工厂模式的区别

工厂模式是创建型模式 ，它关注对象创建，提供创建对象的接口，让对象的创建与具体的使用客户无关。 策略模式是对象行为型模式 ，它关注行为和算法的封装 。再举个例子，还是我们出去旅游，对于策略模式我们只需要选择其中一种出行方法就好，但是工厂模式不同，工厂模式是你决定哪种旅行方案后，由工厂代替你去构建具体方案（工厂代替你去买火车票）。

### 使用场景是什么？

说实话，对于设计模式来说，使用场景仅仅只是举一两个例子。如果你能够理解我们出去旅游的这个案例，基本上你也就能在自己遇到这种情况的时候自动的去选择它。这里就不说了。

OK，策略模式还是比较简单的。一句话说明白就是一个问题有好几种解法，我们选择其中一种就可以了。

客户端必须知道所有的策略类，并自行决定使用哪一个策略类。策略模式会出现很多的策略类。

----

## 工厂模式

> **任何可以产生对象的方法或类，都可以称之为工厂。所以单例也是一种工厂。**

工厂模式把原来new对象的方式，换成了用工厂来实现。为什么有了new之后，还要有工厂？是为了灵活控制生产过程，还可以控制对象访问权限，给对象添加修饰和日志等。

工厂系列的设计模式有：

- 简单工厂
- 静态工厂
- 工厂方法
- 抽象工厂

## 迭代器模式

> **Iterator是专用的容器遍历设计模式。**

> **传统的遍历方式，只能对一种容器遍历。如果我想做到通用的遍历方式，就要用到Iterator**

定义Iterator接口。

定义集合接口

集合接口中添加Iterator方法

具体的集合实现集合接口。

集合中实现一个内部类，内部类实现Iterotor接口。调用这个内部类进行迭代数据。

----

> 自己的事给别人做
