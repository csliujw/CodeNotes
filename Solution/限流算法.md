# 常见限流算法

[高并发系统限流-漏桶算法和令牌桶算法 - 秦羽的思考 - 博客园 (cnblogs.com)](https://www.cnblogs.com/xuwc/p/9123078.html)

[漏桶算法和令牌桶算法，区别到底在哪里？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/433041001)

[漏桶算法和令牌桶算法，区别到底在哪里？_漏桶算法_华仔_InfoQ写作社区](https://xie.infoq.cn/article/4a0acdd12a0f6dd4a53e0472c)

## 简要介绍

- 计数器：统计指定时间段内的访问次数，会有临界值问题，所有请求都出现在两个时间段的交界处。
- 滑动窗口：对计数器的改进，将计数器的时间段分为多个窗口进行计数。各个窗口有一个单独的阈值，不会出现所有请求都打在时间段交界处的情况。
- 漏桶：请求先进入到漏桶里（可以是任意速率流入），漏桶以一定的速度出水，当水流入速度过大会直接溢出，能强行限制数据的传输速率。更适合“瞬时高并发”的场景（比如持续好几分钟的高访问量，为了用户体验和业务尽量少受损，优先采取的不是丢弃大量请求，而是缓存请求，避免系统出现雪崩效应）
- 令牌桶：固定速率生成 token，用户需要得到 token 才可以进行访问。用户消费的速度可以是突发性消费，只要桶中有令牌即可；可以应对突发流量的情况，但是要注意，即使有突发流量来了，系统自己或者下游系统要真的能够处理的过来这样才能保护系统。

漏桶和令牌桶都有保护作用，但漏桶的保护是尽量缓存请求（缓存不下才丢），令牌桶的保护主要是丢弃请求（即使系统还能处理，只要超过指定的速率就丢弃，除非此时动态提高速率）。

## Coding

详细分析各种策略的使用场景并给出示例代码。

### 计数器

主要用来限制总并发数，比如数据库连接池、线程池、秒杀的并发数；只要全局总请求数或者一定时间段的总请求数设定的阀值则进行限流，是简单粗暴的总数量限流，而不是平均速率限流。

### 滑动窗口

### 漏桶

漏桶作为计量工具（The Leaky Bucket Algorithm as a Meter）时，可以用于流量整形（Traffic Shaping）和流量控制（TrafficPolicing），漏桶算法的描述如下：

- 一个固定容量的漏桶，按照常量固定速率流出水滴；
- 如果桶是空的，则不需流出水滴；
- 可以以任意速率流入水滴到漏桶；
- 如果流入水滴超出了桶的容量，则流入的水滴溢出了（被丢弃），而漏桶容量是不变的。

<b>技术本质</b>

控制总量；桶容量的设计是关键，桶越大，可缓存的请求越多。

<b>优缺点</b>

桶大小动态调整比较困难。例如 Java BlockingQueue ;

无法精确控制流出速度(处理速度) ;

突发流量时丢弃的请求较少（会缓存下来）。

<b>应用场景</b>

瞬时高并发流量，如 0 点签到，整点秒杀。这些场景为了照顾用户体验，不会直接丢弃请求而是优先缓存，缓存不下了再考虑丢弃。

### 令牌桶

令牌桶算法是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌。令牌桶算法的描述如下：

- 假设限制 20/s（令牌产生的速度是设计关键），则按照 50 毫秒的固定速率往桶中添加令牌；
- 桶中最多存放 b 个令牌，当桶满时，新添加的令牌被丢弃或拒绝；
- 当一个 n 个字节大小的数据包到达，将从桶中删除 n 个令牌，接着数据包被发送到网络上；
- 如果桶中的令牌不足 n 个，则不会删除令牌，且该数据包将被限流（要么丢弃，要么缓冲区等待）。

<b>技术本质</b>

速率控制，令牌产生的速度是设计关键。要确保服务器可以处理这么多令牌数的请求。

<b>优缺点</b>

可以动态调整处理速度

突发流量的时候可能丢弃很多请求;

实现相对复杂。

<b>应用场景</b>

控制访问第三方服务的速度，防止把下游压垮:

控制自己的处理速度，防止过载

### 漏桶 VS 令牌桶

漏桶算法的请求进入的速率是任意的，但是消费过程的速度是一定的，不会超出某个阈值。令牌桶算法生成 token 的速率是固定的，但是消费的速度可以是任意的，只要桶中还有令牌；可以用来应对一些突发情况。

<b>对系统的保护</b>

漏桶和令牌桶都可以用于保护自己也可以保护下游，而不是说保护自己用令牌桶，保护别人用漏桶。

令牌桶就是一个速率控制，你可以用来控制自己的处理速度，也可以控制请求别人的处理速度，都可以起到保护作用；漏桶也可以既保护自己又保护下游，因为请求太多的时候把请求先缓存到漏桶里面了，漏桶放不下就丢弃新的请求，下游按照自己的处理速度来漏桶里面拿任务就可以了，这也是保护机制。

<b>漏桶的本质是总量控制，令牌桶的本质是速率控制</b>

令牌桶是通过控制令牌的产生速度来实现速率控制的。有令牌，才可以进行消费从而控制速率。

<b>适用场景分析</b>

令牌桶的算法原本是用于网络设备控制传输速度的，而且它控制的目的是保证一段时间内的平均速率控制，之所以说令牌桶适合突发流量，是指在网络传输的时候，可以允许某段时间内（一般就几秒）超过平均传输速率，这在网络环境下常见的情况就是“网络抖动”，但这个短时间的突发流量是不会导致雪崩效应，网络设备也能够处理得过来。对应到令牌桶应用到业务处理的场景，就要求即使有突发流量来了，系统自己或者下游系统要真的能够处理的过来，否则令牌桶允许突发流量进来，结果系统或者下游处理不了，那还是会被压垮。

而我说漏桶算法更适合“瞬时高并发”，是指秒杀、抢购、整点打卡签到、微博热点事件这种业务高并发场景，它不是由于“XX抖动”引起的，而是由业务场景引起的，并且持续的事件可能是几分钟甚至几十分钟，这种业务场景为了用户体验和业务尽量少受损，优先采取的不是丢弃大量请求，而是缓存请求，避免系统出现雪崩效应。因此我们会看到，漏桶和令牌桶都有保护作用，但漏桶的保护是尽量缓存请求（缓存不下才丢），令牌桶的保护主要是丢弃请求（即使系统还能处理，只要超过指定的速率就丢弃，除非此时动态提高速率）。

所以如果在秒杀、抢购、整点打卡签到、微博热点事件这些业务场景用令牌桶的话，会出现大量用户访问出错，因为请求被直接丢弃了；而用漏桶的话，处理可能只是会慢一些，用户体验会更好一些，所以认为漏桶更适合“突发流量”。

在实际落地的时候，令牌桶的桶大小不能像漏桶那样设计很大，需要根据系统的处理能力来进行仔细的估算。例如，漏桶算法的桶容量可以设计为100万，但是一个每秒30 TPS的令牌桶，桶的容量可能只能设计成40左右。举个例子：海外有的银行给移动钱包提供的接口TPS上限是30，压测到了40就真的挂了。

<b>具体实现</b>

谷歌的 Guava 开发包里面的 RateLimiter 就是一个具体的令牌桶实现