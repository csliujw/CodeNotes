# 引言

## 内容简介

此笔记的参考书籍未高洪岩的 Java多线程编程核心技术（第二版）

开篇会介绍每节的主要内容。具体内容以原理+代码+个人理解的方式给出。代码会放在我的github上。开头会给出代码地址。

这本书给我的感觉很一般，不建议买来看。

# 第一章 Java多线程技能

## 本章主要内容

- 进程线程的概念
- 多线程的基本使用
  - 启动
  - 暂停
  - 优先级
  - 安全问题

## 进程和线程的概念

### 概念介绍

进程的概念没有统一的说法，这里我用“汤子瀛”老师《操作系统概念》一书中的一段话：进程是程序的一次执行；进程是一个程序及其数据在处理机顺序执行时所发送的活动；........

总而言之：进程是进程实体的运行过程，**是系统进行资源分配和调度的一个独立单位**，我们所关注的是资源分配和调度，而非抽象的概念。

线程：轻量级的进程。

### 对比

没有线程的话，进程是资源分配和调度的基本单位，是资源分配的最小单位。

有线程的话，线程是调度的最小单位。【注意区分最小和基本】

进程与进程的切换开销大，需要`CPU`重新分配资源。

线程与线程的切换整体开销小，如果是同一个进程内的线程切换，是不需要为线程重新分配资源的，只有不同进程之间的线程切换才需要重新分配资源。

### 优势

多线程的优势上面已经提到了一些，整体的资源开销小。

一个进程中的多个线程争抢CUP资源，也可以保证该进程尽可能多的争抢到CPU资源【如：1个人抢苹果和3个人抢苹果】。

可以保证CPU繁忙，充分利用CPU资源。线程1用完了，释放了CPU资源，其他线程进行争夺。

### 使用场景

- 不要为了使用多线程而使用。场景适合使用时才用多线程
- 如果A，B两个任务之间没有关联（如对同一个数据进行加减），A阻塞了则可以对B使用多线程，确保B可以正常运行，不因A的阻塞而停止。

## 创建线程的两种方式（传统）

> **创建线程的方式一共有4种，传统方式有2种。**

### 继承Thread类

```java
package com.baobaoxuxu.chapter1.thread01;

/**
 * @author payphone
 * @date 2020/6/12 16:57
 * @Description
 */
public class MyThread extends Thread{
    public static void main(String[] args) {
        MyThread th1 = new MyThread();
        th1.start();
        // th1.start(); 多次调用start是会报错的 【面试题，可否多次调用start，why！】
        System.out.println("123");
    }

    /**
     * out put
     * 123
     * Thread-0
     */

    public void run(){
        System.out.println(this.currentThread().getName());
    }
}
```

**调用start，start再调用run。调用start 是异步执行。直接调用run，则是同步执行，是同一个线程噢！**

start方法的执行很耗时！所以多数情况下先输出123！start的执行流程如下：

- 通过jvm告诉OS创建Thread
- 调用windows SDK中的createThread()创建线程对象
- OS对线程进行调度，确定执行时机
- 线程被成功执行

main方法的线程执行的时候，不一定是按main方法里的代码顺序进行执行的。

- 此处含有两个线程，一个名为main的线程，一个名为Thread-0的线程。
- 执行到`new MyThread().start();` 开启了创建Thread-0线程的操作，但是main线程执行start方法时不必等四步都执行完毕，可先运行后面的代码。

#### 【面试题】

**可否多次调用start，why！**

`jdk源码中，只要当前线程的状态不是以0状态进行调用start，都会抛出IllegalThreadStateException异常`

`0表示NEW。`

```java
public synchronized void start() {
    if (this.threadStatus != 0) {
        throw new IllegalThreadStateException();
    } else {
        this.group.add(this);
        boolean started = false;

        try {
            this.start0();
            started = true;
        } finally {
            try {
                if (!started) {
                    this.group.threadStartFailed(this);
                }
            } catch (Throwable var8) {
            }

        }

    }
}


// 线程状态的枚举类
public static enum State {
    NEW,
    RUNNABLE,
    BLOCKED,
    WAITING,
    TIMED_WAITING,
    TERMINATED;

    private State() {
    }
}
```

#### 线程的随机性

<p style="font-size:18px">
    假设OS采用的时间片轮转，每个得到cpu资源的进程/线程，都可占用cpu xxms。<br />
    假设这是一个进程中的多个线程,且只有一个单核CPU：进程是资源分配的基本单位。cpu资源也是资源。同一个进程中的线程交替获得cpu资源，交替执行。所以RandomThread线程和main线程交替执行，输出结果也是交替执行。<br />
	假设是这两个线程都是来自于不同的进程，且计算机为多核CPU，每个线程同时要到了CPU，他们都想在控制台打印。但是控制台打印这是一个临界资源，每次也只允许一个进程/线程进行打印操作，得到打印权限的线程可以进行输出，没得到权限的线程只能进行等待，所以也是打印这个操作也是交替执行的【执行次数尽可能的大，CPU计算能力太强，次数太少看不到效果】<br />
    <span style="color:red">进程是否可同时占用多个CPU未知，以上仅为假设！</span>
</p>

```java
package com.baobaoxuxu.chapter1.thread01;

/**
 * @author payphone
 * @date 2020/6/12 17:29
 * @Description 线程随机性的展示
 */
public class RandomThread {
    public static void main(String[] args) {
        RandomThreadTest th1 = new RandomThreadTest();
        th1.setName("RandomThread");
        th1.start();
        for (int i = 0; i <1000 ; i++) {
            System.out.println(Thread.currentThread().getName());
        }
    }
}

class RandomThreadTest extends Thread{
    public void run(){
        for (int i = 0; i <1000 ; i++) {
            System.out.println(this.currentThread().getName());
        }
    }
}
```

### 实现Runnable接口

<p style="font-size:18px;">start方法只能调用一次，但是run方法可调用多次<br/>继承Runnable的写法查看Thread的构造方法即可。</p>

```java
/**
 * @author payphone
 * @date 2020/6/12 17:52
 * @Description
 */
public class MyRunnableThread implements Runnable {
    public static void main(String[] args) {
        Thread thread = new Thread(new MyRunnableThread());
        thread.run();
        thread.start();
        thread.run();
        thread.run();
    }
    @Override
    public void run() {
        System.out.println("I implements Runnable interface");
    }
}
```

```java
 public Thread() {
        this((ThreadGroup)null, (Runnable)null, "Thread-" + nextThreadNum(), 0L);
    }

public Thread(Runnable target) {
    this((ThreadGroup)null, target, "Thread-" + nextThreadNum(), 0L);
}

Thread(Runnable target, AccessControlContext acc) {
    this((ThreadGroup)null, target, "Thread-" + nextThreadNum(), 0L, acc, false);
}

public Thread(ThreadGroup group, Runnable target) {
    this(group, target, "Thread-" + nextThreadNum(), 0L);
}

public Thread(String name) {
    this((ThreadGroup)null, (Runnable)null, name, 0L);
}

public Thread(ThreadGroup group, String name) {
    this(group, (Runnable)null, name, 0L);
}

public Thread(Runnable target, String name) {
    this((ThreadGroup)null, target, name, 0L);
}

public Thread(ThreadGroup group, Runnable target, String name) {
    this(group, target, name, 0L);
}

public Thread(ThreadGroup group, Runnable target, String name, long stackSize) {
    this(group, target, name, stackSize, (AccessControlContext)null, true);
}

public Thread(ThreadGroup group, Runnable target, String name, long stackSize, boolean inheritThreadLocals) {
    this(group, target, name, stackSize, (AccessControlContext)null, inheritThreadLocals);
}

```

#### 非共享变量示例

我用的继承Thread，也可用实现Runnable的方式

```java

/**
 * @author payphone
 * @date 2020/6/12 18:18
 * @Description 多线程 非共享变量操作
 */
public class UnShareVariable {
    public static void main(String[] args) {
        Thread thread1 = new Thread(new UnShareThread(), "A");
        thread1.start();
        Thread thread2 = new Thread(new UnShareThread(), "B");
        thread2.start();
        Thread thread3 = new Thread(new UnShareThread(), "C");
        thread3.start();
        Thread thread4 = new Thread(new UnShareThread(), "D");
        thread4.start();

    }
}

class UnShareThread extends Thread {
    private int count = 10;

    @Override
    public void run() {
        while (count > 0) {
            count--;
            System.out.println(Thread.currentThread().getName() + "===" + count);
        }
    }
}
```

#### 共享变量示例

```java
// 非线程安全

import java.util.ArrayList;
import java.util.List;

/**
 * @author payphone
 * @date 2020/6/12 18:18
 * @Description 多线程 共享变量操作 多个线程 操作一个类即可实现
 */
public class ShareVariable {
    public static void main(String[] args) {
        ShareThread shareThread = new ShareThread();
        Thread a = new Thread(shareThread, "A");
        Thread b = new Thread(shareThread, "B");
        Thread c = new Thread(shareThread, "C");
        Thread d = new Thread(shareThread, "D");

        a.start();
        b.start();
        c.start();
        d.start();
    }
}

class ShareThread extends Thread {
    private int count = 100000;
    public static List<Integer> list = new ArrayList<>();
    @Override
    public void run() {
        while (true) {
            if (count > 0) {
                list.add(count--);
                System.out.println(Thread.currentThread().getName() + "===" + count);
            }else{
                System.out.println(list.size());
                return;
            }
        }

    }
}
```

#### 变为线程安全

同步方法run上加上synchronized即可。

PS：`synchronized`被不断的优化了，性能很好了！

## println的安全问题

```java
/**
 * @author payphone
 * @date 2020/6/12 19:15
 * @Description system.out.println()
 */
public class Other {
    public static void main(String[] args) {
        int i = 10;
        // 非线程安全 只会打印方法，i自减这个操作不在锁的范围内
        System.out.println(--i);
        // 非线程安全 先进入打印方法，i自减这个操作不在锁的范围内
        System.out.println(i--);
    }
}

// System.out.println源码
public void println(int x) {
    synchronized(this) {
        this.print(x);
        this.newLine();
    }
}
```



## 常用基本API

**就不贴API了，没意思。**

### start与run的区别

- start是异步调用，是另外一个线程执行噢，start内部会调用run方法，但是run的调用时机未知。
- run是同步调用，是同一个线程执行噢。

```java
// 调用start
/**
 * @author payphone
 * @date 2020/6/12 19:33
 * @Description
 */
public class StartAndRun {
    public static void main(String[] args) {
        StartAndRunThread startAndRunThread = new StartAndRunThread();
        Thread thread = new Thread(startAndRunThread);
        thread.start();
    }
}

class StartAndRunThread implements Runnable{

    @Override
    public void run() {
        System.out.println("I am run!");
        System.out.println("当前线程为："+Thread.currentThread().getName());
    }
}

// out put
I am run!
当前线程为：Thread-0

// 调用run 将上述代码xxx.start()改成xxx.run()即可
I am run!
当前线程为：main

```



 ### `getName()`分析

- `Thread.currentThread().getName(）`获取当前正在运行的线程的name
- `this.getName()`获取当前对象的名字（这个对象继承了Thread类，有自己的名字！）

`Thread.currentThread().getName()与this.getName()的区别分析`

先看一个例子

```java
public class DistinguishGetName {
    public static void main(String[] args) {
        DistinguishThread name = new DistinguishThread();
        name.start();
    }
}

class DistinguishThread extends Thread{

    @Override
    public void run(){
        System.out.println("this.getName():"+this.getName());
        System.out.println("Thread.currentThread().getName():"+Thread.currentThread().getName());
    }

}
// out put
this.getName():Thread-0
Thread.currentThread().getName():Thread-0
```

```java
public class DistinguishGetName {
    public static void main(String[] args) {
        DistinguishThread name = new DistinguishThread();
        Thread thread = new Thread(name);
        thread.setName("new name");
        thread.start();
    }
}

class DistinguishThread extends Thread{

    @Override
    public void run(){
        System.out.println("this.getName():"+this.getName());
        System.out.println("Thread.currentThread().getName():"+Thread.currentThread().getName());
    }

}

// out put   name不一样！！！原因是什么？
this.getName():Thread-0 
Thread.currentThread().getName():new name
```

`this.getName`获得的是当前对象的name，默认为Thread-number

`Thread.currentThread.getName`获得的是执行线程的name thread是执行线程，thread.setName("new name");

简而言之：this是当前对象，Thread.currentThread是当前线程！

要想修改this线程的名字 这样即可【注意需要继承Thread才可！实现Runnable不行，因为没有get/setName方法】

```java
public class DistinguishGetName {
    public static void main(String[] args) {
        DistinguishThread name = new DistinguishThread("new name");
        Thread thread = new Thread(name);
        thread.setName("new name");
        thread.start();
    }
}

class DistinguishThread extends Thread{
    public DistinguishThread(String threadName){
        super(threadName);
    }

    @Override
    public void run(){
        System.out.println("this.getName():"+this.getName());
        System.out.println("Thread.currentThread().getName():"+Thread.currentThread().getName());
    }

}
// out put  
this.getName():new name
Thread.currentThread().getName():new name
```

### 其他API

```java
isAlive() ==== 是否存活
sleep(long millis) ==== 休眠指定毫秒
sleep(long millis, int nanos) ==== 休眠指定毫秒+纳秒    
```

### 停止线程

- 退出标志
- stop强行停止，不推荐
- interrupt中断线程【非立即中断】
- <span style="color:red">在一个线程中调用另一个线程的interrupt()方法，即会向那个线程发出信号——线程中断状态已被设置。至于那个线程何去何从，由具体的代码实现决定。</span>

```java
// interrupt示例 不好测。。cpu太快了
// 测试内容解释：
run方法里打印数据是为了证明，我调用了interrupt中断线程，线程仍会运行，仍会继续打印数据i。
我们重写了interrupt方法，在里面输出了一句话也是为了告诉自己，已经调用了中断方法。通过这两种输出结果的
顺序，推断是否是立即中断。
public class Interrupt {
    public static void main(String[] args) throws InterruptedException {
        InterruptThread th1 = new InterruptThread();
        th1.start();
        th1.interrupt();
    }
}

class InterruptThread extends Thread {
    @Override
    public void interrupt(){
        super.interrupt();
        System.out.println("interrupt 执行了======================");
    }
    @Override
    public void run() {
        for (int i = 0; i < 200000; i++) {
            System.out.println("i=" + (i + 1));
        }
    }
}
```

result

```text
interrupt 执行了====================== 调用interrupt线程并未停止！
i=138008
i=138009
i=138010
i=138011
i=138012
i=138013
i=138014
........
i=199998
i=199999
i=200000

Process finished with exit code 0
```

#### 如何判断线程是否中止？

查看Java Thread类源码可知有如下两种方法

- 静态方法 interrupted，因为是静态的，所以判断的是`currentThread，`即当前线程是否被标记为中断状态！
- 非静态 `isInterrupted`，判断的是运行 `this.isInterrupted` 这个方法的线程是否停止

```java
public static boolean interrupted() {
    return currentThread().isInterrupted(true);
}

public boolean isInterrupted() {
    return this.isInterrupted(false);
}
```

测试代码及解释

```java
/**
 * @author payphone
 * @date 2020/6/14 16:46
 * @Description
 */
public class JugeInterrupted {

    public static void main(String[] args) throws InterruptedException {
        System.out.println(Thread.currentThread().getId()); // main线程的id是1
        JugeThread thread = new JugeInterrupted().new JugeThread();
        thread.start();
        Thread.sleep(800);
        thread.interrupt(); // 中断线程，中断的是thread类 运行run方法的那个线程，即中断的id为14的线程。
        System.out.println("over");
        System.out.println(thread.interrupted());
        System.out.println(thread.interrupted());
    }
    class JugeThread extends Thread{
        @Override
        public void run(){
            for (int i = 0; i <200000 ; i++) {
                // Thread-0线程的id是14
                System.out.println(i+":"+this.isInterrupted()+":"+this.getId());
            }
        }
    }

}
```

输出结果分析

```java
thread.interrupt(); // 中断线程，将中断状态标记为true，可通过代码测试
System.out.println("over"); // 随意打印一句话
System.out.println(thread.interrupted()); // 查看中断状态 返回true，同时将状态设置为false
171644:false:14
171645:false:14
over
false
171646:true:14
false
171647:true:14
171648:true:14
    
// 源码
public static boolean interrupted() {
    return currentThread().isInterrupted(true);
}
```

`thread.interrupt()`中断的是运行thread run方法的那个线程，可以从输出结果看出。调用前后的输出结果为

`171645:false:14`
`over`
`false`
`171646:true:14`
`false`
`171647:true:14`

`thread.interrupted()`查看的是当前线程是否被中断，查看源码

```java
// 源码
public static boolean interrupted() {
return currentThread().isInterrupted(true);
}
// 我们的代码
public static void main(String[] args) throws InterruptedException {
    System.out.println(Thread.currentThread().getId()); // main线程的id是1
    JugeThread thread = new JugeInterrupted().new JugeThread();
    thread.start();
    Thread.sleep(800);
    thread.interrupt(); 
    System.out.println("over");
    System.out.println(thread.interrupted());//false
    System.out.println(thread.interrupted());//false
}
// 当前线程是main线程 我们并未对main线程进行状态标记，所以输出结果是false false
// 再看下面的代码
class JugeThread extends Thread{
    @Override
    public void run(){
        for (int i = 0; i <200000 ; i++) {
            // Thread-0线程的id是14 这块的输出结果改变了！因为这里的当前线程是Thread-0
            System.out.println(i+":"+this.isInterrupted()+":"+this.getId());
        }
    }
}

171645:false:14
171646:true:14
false
171647:true:14
```

<span style="color:red">总而言之，`this.isInterrupted()`是判断this所在的类对象，运行这个对象的线程是否已经标记为中断。</span>

#### 如何终止线程？

上面判断线程是否终止给了我们提示，我们可以在run方法中获取“是否需要被中断”，来决定是否停止线程。停止线程可采用抛出异常的方法进行终止！

可以用return，但是抛出异常的写法，方便统一管理日志！

```java
public class StopThread extends Thread {
    public static void main(String[] args) throws InterruptedException {
        System.out.println(Thread.currentThread().getName()); // 当前线程为main线程
        StopThread stopThread = new StopThread();
        stopThread.start();
        // 设置休眠 让run方法运行一会，中断方法晚一点执行
        Thread.sleep(200);
        // 设置为中断状态
        stopThread.interrupt();
    }

    @Override
    public void run() {
        // 当前线程为 Thread-0线程
        System.out.println(this.getName());
        try {
            for (int i = 0; i < 200000; i++) {
                System.out.println("hello!");
                if (this.isInterrupted()) {
                    throw new InterruptedException();
                }
            }
        } catch (InterruptedException e) {
            System.out.println("終於結束了！");
            e.printStackTrace();
        }
    }
}
```

#### 到底该怎样终止线程？

* stop方法可暴力终止线程，但是可能会使一些清理性工作无法完成！造成数据不完整！
* 而interrupt可以在run中进行逻辑判断，需要中断了，在抛出中断异常之前，把扫尾工作完成！
* 总而言之 推荐 interrupt + throw excetion的组合方式

### 暂停线程

- 暂停线程用 `suspend()`
- 恢复线程用`resume()`

都是独占资源的，可能会导致死锁。都是过期方法，不推荐使用。线程的暂停恢复推荐使用：

- `wait`
- `notify`
- `notifyAll`

```java
public class Suspend extends Thread {
    public static int number = 100;

    public static void main(String[] args) throws InterruptedException {
        Suspend suspend = new Suspend();
        suspend.start();
        // 线程挂起
        Thread.sleep(200);
        suspend.suspend();
        // system.out的out是静态final 成员 唯一的。所以对象是唯一的。println需要取得这个对象的锁才可以。
        // main方法的的System.out.printl和run方法的System.out.printl都是同一个out对象的pringln方法。
        // 要用同一把锁。suspend挂起来，锁资源被抢走了，且无法释放，造成了死锁，无法输出end方法
        System.out.println("end!");
    }

    @Override
    public void run() {
        while (true) {
            number++;
            System.out.println(number);
        }
    }
}
```

书里面说的suspend() resume()造成的数据不完整【得不到正确的数据】其实是并发处理不得当。

### 放弃CPU资源

- yield方法让当前线程放弃cpu资源

满足xx条件，调用yield方法放弃cpu资源。【放弃的时间不确定】

```java
public class Yield extends Thread {
    static long i = 0;
    static long count = 0;
    public static void main(String[] args) {
        new Yield().start();
    }

    @Override
    public void run() {
        super.run();
        long start = System.currentTimeMillis();
        for (i = 0; i < 10000; i++){
            for (int j =0;j<100;j++){
                Thread.yield(); // 加了这句话，运行时间明显变长
                count++;
            }
        }
        long end = System.currentTimeMillis();
        System.out.println(end - start);
    }
}
```



## 线程的优先级

高优先级的线程获得的CPU资源往往更多，会优先把资源给高优先级的线程【但是不绝对，不一定是高优先级的执行的时间长，高优先级的先完成。只是倾向于把CPU资源给他！】

## 守护线程

守护守护，就是守护其他线程的。

当进程中不存在非守护线程了，则守护线程自动销毁【没有需要守护的线程了！使命结束了！】

典型的守护线程有 Java的垃圾回收线程。当所有线程结束了，也不需要垃圾回收了，垃圾回收线程【守护进程】就销毁了！

```java
public class Daemon extends Thread {
    public static void main(String[] args) throws InterruptedException {
        Daemon daemon = new Daemon();
        // 这句话的意思是 设置daemon对象 运行run方法的线程为守护线程 即 Thread-0为守护线程
        daemon.setDaemon(true);
        daemon.start();
        Thread.sleep(5000);
        // 当over 输出完毕后【非守护线程运行完毕 后 运行run方法的线程就会销毁，不会再打印数字了！】
        System.out.println("over!!");
        System.out.println("over!!");
        System.out.println("over!!");
    }

    @Override
    public void run() {
        super.run();
        int i = 0;
        while (true) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
            }
            System.out.println("i=" + i++);
        }
    }
}
```



----

# 第二章 对象及变量访问

## 本章主要内容

- synchronized介绍及其原理剖析【字节码层面】
- 非线程安全问题
- volatile主要作用
- volatile和synchronized的区别

**主要内容总结：（预览）**

synchronized关键字的主要作用是保证同一时刻，只有一个线程可以执行某一个方法，或是某一代码块，synchronized可以修饰方法及代码块。JDK1.5还是1.6后synchronized的效率得到了极大的提升【JVM优化了这个关键字】

**synchronized的特征：**

- 可见性：synchronized可以，volatile也可以确保变量可见【可见性就是，被那两个修饰的变量，会强制从公共内存读取变量的值。】
- 原子性：被同步的代码块在同一时间只有一个线程在执行
- 禁止代码重排序：synchronized可以，volatile也可以

**使用场景总结：**

- 想要变量的值被修改时，让其他线程能取到最新的值时，就要对变量使用volatile
- 多个线程操作一个实例对象时，想要确保线程安全，可使用synchronized关键字

## synchronized同步方法

### 线程不安全例子

并发访问可能会造成数据的“脏读”【读不到期待的数据】

共享的数据可能会有线程安全问题，非共享的数据不会出现线程安全问题！

如：一个实例对象的成员变量被多个线程访问，这样可能会出现线程安全问题。 

```java
// 要多试几次，不容易出错误结果！
public class UnSafeDemo extends Thread {
    public static int ticket = 100;

    public static void main(String[] args) {
        UnSafeDemo unSafeDemo = new UnSafeDemo();
        Thread th1 = new Thread(unSafeDemo);
        Thread th2 = new Thread(unSafeDemo);
        Thread th3 = new Thread(unSafeDemo);
        Thread th4 = new Thread(unSafeDemo);
        th1.start();
        th2.start();
        th3.start();
        th4.start();
    }

    @Override
    public void run() {
        while (true) {
            if (ticket > 0) {
                try {
                    Thread.sleep(50);
                    System.out.println("还剩" + ticket-- + "张票");
                } catch (InterruptedException e) {
                }
            } else {
                return;
            }
        }
    }
}

// out put
还剩2张票
还剩-1张票
还剩1张票
还剩0张票
```

### synchronized原理

synchronized锁的是当前对象，或字节码对象！

<span style="color:red">方法级别的锁，采用了flag标记ACC_SYNCHRONIZED。如果方法设置了ACC_SYNCHRONIZED标记则执行线程先持有同步锁，再执行方法，方法完成时再释放锁！</span>

```java
 public static synchronized void say();
    descriptor: ()V
    flags: (0x0029) ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED
    Code:
      stack=0, locals=0, args_size=0
         0: return
      LineNumberTable:
        line 11: 0
```

<span style="color:red">同步代码块的锁。使用的时monitorenter和monitorexit指令进行同步处理</span>

```java
public static void hello();
    descriptor: ()V
    flags: (0x0009) ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=2, args_size=0
         0: new           #2                  // class java/lang/Object
         3: dup
         4: invokespecial #1                  // Method java/lang/Object."<init>":()V
         7: dup
         8: astore_0
         9: monitorenter
        10: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
        13: ldc           #4                  // String hello
        15: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        18: aload_0
        19: monitorexit
        20: goto          28
        23: astore_1
        24: aload_0
        25: monitorexit // 有两个exit是怕 第一个无法退出！
        26: aload_1
        27: athrow  // 这边抛出异常了
        28: return
      Exception table:
         from    to  target type
            10    20    23   any
            23    26    23   any
      .......
```

### 多个线程多个锁

多个对象多个锁，不同锁的线程互不影响噢！

### 带锁和不带锁的

不带synchronized方法的运行不受带synchronized方法的影响！【两者是异步的！不必一前一后！不会因为A的阻塞，导致B无法运行】

带锁的和不带锁的他们之间的运行是异步的。带锁的方法在运行，突然带锁的方法CPU时间到了，给不带锁的方法了！这个不带锁的可以正常运行！因为他的运行不需要拿锁！请看代码！

```java
public class LockAndUnLock {

    static class Demo1 extends Thread {
        private LockAndUnLock obj;

        public Demo1(LockAndUnLock obj) {
            this.obj = obj;
        }

        @Override
        public void run() {
            super.run();
            obj.lock();
        }
    }

    static class Demo2 extends Thread {
        private LockAndUnLock obj;

        public Demo2(LockAndUnLock obj) {
            this.obj = obj;
        }

        @Override
        public void run() {
            super.run();
            obj.unlock();
        }
    }

    private synchronized void lock() {
        try {
            System.out.println("I am lock");
            Thread.sleep(5000);
            System.out.println("I am lock！ I am over！");
        } catch (InterruptedException e) {
        }
    }

    private void unlock() {
        System.out.println("I am unlock");
    }

    public static void main(String[] args) {
        LockAndUnLock lock = new LockAndUnLock();
        // 传入的同一个对象 要锁的话 也是锁这个传入的对象
        Demo1 demo1 = new Demo1(lock);
        Demo2 demo2 = new Demo2(lock);
        demo1.start();
        demo2.start();
    }
}

// out put
I am lock
I am unlock
I am lock！ I am over！
并不干扰不加锁方法的运行！
```

都有synchronized关键字的话

```java
// unlock方法进行修改 加synchronized
private synchronized void unlock() {
    System.out.println("I am unlock");
}

// out put 有先后顺序！ 先执行lock内的所有语句 再执行unlock的！
I am lock
I am lock！ I am over！
I am unlock
```

### 小结

- A线程先持有obj对象的Lock锁，B线程可异步调用obj对象的非synchronized方法
- A线程先持有obj对象的Lock锁，B线程调用obj对象的synchronized方法，需要等待，等到A线程释放锁，B拿到锁了才可以运行！这就是同步！
- **方法声明处添加synchronized锁的不是方法而是当前类的对象！**
- 静态方法声明处加了锁的话，锁的是字节码对象！【简而言之，这个类的所有实例用的都是同一把锁！】

### 脏读

在读取变量时，此值被其他线程更改过了！

### synchronized锁重入

锁重入？啥意思？

意思就是：有obj对象有A B C三个加锁修饰的方法。A内部调用了B方法，B内部调用了C方法，C B A这三个方法都可以正常执行。因为A拿到了锁，这个锁可以给B用【可重入】，B拿到了A的锁，这个锁又可以给C用！【编译原理，方法调用？参数传递？】

```java
public class Resynchronized {
    private synchronized void one(){
        System.out.println("one");
        two();
    }

    private synchronized void two(){
        System.out.println("two");
        three();
    }

    private synchronized void three(){
        System.out.println("three");
    }

    public static void main(String[] args) {
        new Thread(()->{new Resynchronized().one();}).start();
    }

}
```

### 锁重入支持继承的环境

子类的锁声明方法可以调用父类锁声明的方法，调用过程中不会出现阻塞！

### 出现异常锁自动释放

synchronized方法调用过程中出现异常，是会释放锁的

注意：sleep()方法和suspend()方法被调用后不释放锁【这句话我不太明白什么意思？】

```java
//  线程挂起的demo，不会释放锁！
public class ReleaseLock extends Thread {

    public synchronized void say() {
        while (true) {
            System.out.println("say~~~~~~~~");
        }
    }

    public synchronized void hello() {
        System.out.println("hello~~~~~~~~~");

    }

    public static void main(String[] args) throws InterruptedException {
        ReleaseLock releaseLock = new ReleaseLock();
        
        Thread thread1 = new Thread(() -> {
            releaseLock.say();
        });
        
        thread1.start();
        Thread.sleep(2000);
        thread1.suspend();

        Thread thread2 = new Thread(() -> {
            releaseLock.hello();
        });
        thread2.start();
    }
}
```

### 重写方法不使用synchronized

子类重写父类的synchronized方法，但是重写后的方法不用synchronized修饰，则重写后的方法调用时不用获取锁。简而言之，子类的重写方法无synchronized关键字，就不是同步方法！

```java
/**
 * @author payphone
 * @date 2020/6/16 16:35
 * @Description 子类重写父类的synchronized方法
 */
public class OverrideDemo {
    public static void main(String[] args) throws InterruptedException {
        // 多个线程操作同一个对象，如果有锁，则会顺序执行！
        Son son = new Son();
        Thread th1 = new Thread(() -> {
            son.say();
        });
        Thread th2 = new Thread(() -> {
            son.say();

        });

        th1.start();
        Thread.sleep(500);
        th2.start();
    }
}

class Father {
    public synchronized void say() {
    }
}

class Son extends Father {
    @Override
    public void say() {
        try {
            System.out.println(Thread.currentThread().getName()+":son");
            Thread.sleep(5000);
            System.out.println(Thread.currentThread().getName()+":over");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

// out put
Thread-0:son
Thread-1:son
Thread-0:over
Thread-1:over
```

输出结果时0和1交替运行，并不是得0运行完毕1才可运行。不是同步得。==>重写得方法不带synchronized就不是同步方法！当然，如果内部调用了相同的同步方法，则那个被调用的同步方法还是需要同步执行的，请看如下代码！

```java
public class OverrideDemo {
    public static void main(String[] args) throws InterruptedException {
        // 多个线程操作同一个对象，如果有锁，则会顺序执行！
        Son son = new Son();
        Thread th1 = new Thread(() -> {
            son.say();
        });
        Thread th2 = new Thread(() -> {
            son.say();

        });

        th1.start();
        Thread.sleep(500);
        th2.start();
    }
}

class Father {
    public synchronized void say() {
        try {
            System.out.println("I am your father："+Thread.currentThread().getName());
            Thread.sleep(10000);
            System.out.println("You need wait me finish："+Thread.currentThread().getName());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

class Son extends Father {
    @Override
    public void say() {
        super.say();
        try {
            System.out.println(Thread.currentThread().getName()+":son");
            Thread.sleep(5000);
            System.out.println(Thread.currentThread().getName()+":over");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

// out put 先只执行完Thread0的再执行完Thread-1的。
I am your father：Thread-0
You need wait me finish：Thread-0
I am your father：Thread-1
Thread-0:son
Thread-0:over
You need wait me finish：Thread-1
```

## synchronized同步语句块

### synchronized方法的弊端

方法内的代码需要执行的时间越长，锁的时间就越长，其他同步方法等待的时间就越久！【缩减同步方法的大小，只对必要的操作进行加锁！】若，多个操作都需要加锁，加多次锁不如只加一次大范围的锁。频繁的加锁解锁也会导致性能低下。

**可用同步代码块来替代synchronized方法！**

==同步代码块中的方法同步执行，非同步代码块中的方法异步执行！==

```java
public class LongCode {
    private int count = 100;

    public static void main(String[] args) {
        LongCode longCode = new LongCode();
        Thread th1 = new Thread(() -> {
            longCode.increase();
        });
        Thread th2 = new Thread(() -> {
            longCode.decrease();
            ;
        });
        Thread th3 = new Thread(() -> {
            longCode.decrease();
        });
        th1.start();
        th2.start();
        th3.start();
    }

    private void increase() {
        print();
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
        }
        synchronized (this) {
            System.out.println(Thread.currentThread().getName() + ":" + count++);
        }
        print();
    }

    private void decrease() {
        print();
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
        }
        synchronized (this) {
            System.out.println(Thread.currentThread().getName() + ":" + count++);
        }
        print();

    }

    public void print() {
        System.out.println("*******"+Thread.currentThread().getName()+"*******");
        System.out.println("*******"+Thread.currentThread().getName()+"*******");
    }
}
```

### synchronized同步代码块的一些细节

- synchronized使用的对象监视器是同一个，即使用的锁是同一个！

- synchronized(this)中的this是当前对象！

- 也可以使用任意的对象作为(obj)，只要保证对象是一致的就可以了。
- 方法之间的锁不同的话，它们之间的调用是异步的。

## 何时需要同步?

当多线程调用的方法之间有严格的执行顺序，则需要进行同步操作。

操作需要一气呵成，不能被其他程序插入执行的时候，需要锁住他！

## synchronized各方面的比较

### this与obj.class

```java
synchronized(this) 是把当前对象当锁来用
synchronized(Obj.class) 是把字节码对象当锁来用。

    this!= obj.class
        

public class ThisAndClass {

    public static void main(String[] args) {
        Object o1 = new Object();
        Object o2 = new Object();
        System.out.println(o1==o1.getClass()); // false
        System.out.println(o2==o2.getClass()); // false
        System.out.println(o1.getClass()==o2.getClass()); // true
        System.out.println(Object.class==o1.getClass()); // true
    }
}

```

### synchronized（this）

锁的是当前实例对象的方法。

### synchronized(obj.class)

锁的是Obj字节码对象的方法。与this 不是同一把锁。

`obj.class`可以被多个实例对象使用。即，这个类的多个实例对象，都用字节码对象这把锁，多个对象共用一把锁。

### 静态与非静态修饰

```java
public static synchronized void say(){} // 这个是把字节码对象当锁【有static关键字】
public synchronized void say(){} // 这个是把当前实例对象当锁【普通方法】
```

## volatile关键字

**用volatile声明的变量**

- 可确保其他线程可见
  - JVM分线程工作内存和OS内存，把数据从OS内存读到线程工作内存后再操作变量，操作完后的某个时间（这个要看字节码指令的顺序），再把变量写回OS内存！这样会导致数据无法及时同步【A线程把数据拷贝到了工作内存，B线程也拷贝了一份，并且修改了，同步到了OS内存，但是A线程读的还是工作内存中的值，没有及时获得新的值！】，即其他线程无法立即得知数据是否改变！
  - 用volatile声明的，操作完数据后，会立即将数据写入OS内存，其他线程在要读取的时候可以立即得知数据是否变动了！
- 禁止指令重排序。
  - 多流水线技术，为了提高程序的并发运行的效率，内部会对字节码指令的顺序进行重排序，让代码高效运行。具体内容请自行看计算机组成原理流水线部分。

- 不能保证操对变量的操作是原子性操作！如：
  - volatile int i = 0； i++
    - 并非原子性操作
    - 读取变量到工作内存
    - 执行加一操作
    - 将数据重新写回OS内存
    - 有三步，这种非一气呵成的操作，是可能出现并发安全问题的

### 数据不同步造成的死锁

我用IDEA Java11 测试的是会出现死循环。g如果不出现死循环，在JVM中添加运行参数！

VM argument/option里添加-server

```java
public class DeadLock extends Thread{
    private boolean isRunning = true;

    public boolean isRunning(){
        return isRunning;
    }

    public void setRunning(boolean isRunning){
        this.isRunning = isRunning;
    }

    @Override
    public void run() {
        super.run();
        System.out.println("线程开始了！");
        //while里面不能有任何代码 不知道原因，反正不能有代码
        // System.out.print这个IO操作让主线程能获取最新的isRunning
        while (isRunning){
        }
        System.out.println("线程停止了！");
    }

    // 解释。有两个线程 main线程和Thread-0线程。main线程修改了Thread-0线程的isRunning的值。
    // 修改的是OS内存中的那个值。Thread-0读取的是自己工作内存中的值【非OS内存中的】，所以仍然
    // 为trun，继续保持死循环。
    public static void main(String[] args) throws InterruptedException {
        DeadLock deadLock = new DeadLock();
        deadLock.start();
        Thread.sleep(1000);
        deadLock.setRunning(false);
        System.out.println("main线程的最后一句输出");
    }
}
// out put
线程开始了！
main线程的最后一句输出
```

### 用volatile解决上述死锁

```java
public class DeadLock extends Thread{
    private volatile boolean  isRunning = true;

    public boolean isRunning(){
        return isRunning;
    }

    public void setRunning(boolean isRunning){
        this.isRunning = isRunning;
    }

    @Override
    public void run() {
        super.run();
        System.out.println("线程开始了！");
        while (isRunning){
        }
        System.out.println("线程停止了！");
    }

    public static void main(String[] args) throws InterruptedException {
        DeadLock deadLock = new DeadLock();
        deadLock.start();
        Thread.sleep(1000);
        deadLock.setRunning(false);
        System.out.println("main线程的最后一句输出");
    }
}
// out put
线程开始了！
main线程的最后一句输出
线程停止了！
```

### synchronized即可同步又可保证可见性

synchronized修饰的代码，里面的变量即可保证可见性，又可保证同步！

### volatile与重排序

volatile修饰的变量

- volatile前面的代码不可重排序到它后面
- volatile后面的代码不可重排序到它前面
- 用数据结构排序中的一句话来概括，将代码分成三部分前，volatile，后，这三部分是稳定的。

### 为什么单例要用volatile

volatile可以防止指令重排序。防止对象的初始化赋值 重排序，先给对象赋值，再初始化对象这种操作，导致对象不为空，非synchronized方法判断它不会空可以获取了，实际上对象的值还没初始化！拿到的数据不正确！volatile可以避免这种现象！

但是一般不会写饿汉式，，除非你真的在乎这一个对象的内存！

**PS：volatile修饰引用，引用指向的对象中的值改变了是不能立即察觉的！**

## 锁优化

- 减小锁粒度：竞争不激烈时，尽量减少锁粒度。
- 增加锁粒度：锁竞争激烈，意思就是很多小锁，频繁的加锁解锁很消耗资源，可以考虑将锁粗化。

## CAS（Compare and Swap)

凡是Atomic开头的都是用CAS来保证线程安全的

CAS是CPU级别的原语，一气呵成，不能被中断！



sync(Object)

`markword` 记录这个线程ID（偏向锁）只记录ID，也没申请锁，所以效率很高。

如果有线程争用：升级为 自旋锁

10次后，升级为重量级锁

`Atomicl` 用的lock，而lock用的基本就是自旋锁。是在用户态解决问题，不是在系统态，没有状态切换的开销。

占用CPU时间短的用自旋锁好（就算时间短，太多的线程自旋也不好）；而占用CPU时间长的（执行时间长的）用系统锁（OS锁）。

执行时间短（加锁代码），线程数少，用自旋

执行时间长，线程数多，用系统锁。

Integer 中的值一旦发送改变，就会产生一个新对象！所以也别用他当syn的锁对象

# 第三章 线程间通信

## 本章主要内容

- 如何使用wait/notify实现线程间的通信
- 生产者/消费者模式的实现
- `ThreadLocal`类的使用

## wait/notify机制

线程是OS中独立的个体，个体不经过特殊处理不能成为整体。线程间的通信可以让这些个体变成整体

### 不使用wait/notify通信

```java
/**
 * @author payphone
 * @date 2020/6/20 0:48
 * @Description 两个线程 一个添加元素 一个监控，达到5时退出
 */
public class SimpleDemo {
    public static void main(String[] args) {
        MyList myList = new MyList();
        Thread th1 = new Thread(() -> {
            try {
                for (int i = 0; i < 10; i++) {
                    // 会有线程安全问题，添加了 还没来得及更新size，有添加了一次，size只加1 需要对add方法进行加锁
                    //size访问的时候，也可能add了，size没来的更新就获取了size
                    // 所以 最好是 add和size方法都进行加锁处理
                    myList.add();
                    System.out.println("线程" + Thread.currentThread().getName() + "添加了" + i + "个元素!");
                    TimeUnit.SECONDS.sleep(1);
                }
            } catch (Exception e) {
            }
        });

        Thread th2 = new Thread(() -> {
            while (true) {
                if (myList.size() == 5) {
                    System.out.println("==5了，线程" + Thread.currentThread().getName() + "要退出了");
                    return;
                }
            }
        });

        th1.start();
        th2.start();
    }
}

// 资源操作类
class MyList {
    // 需要加关键字 volatile 保证其他线程获取到的是最新的值！
    private volatile List list = new ArrayList();

    public void add() {
        list.add("ljw");
    }

    public int size() {
        return list.size();
    }
}
```

### wait/notify机制

共享变量实现的进程通信，需要CPU一直轮询，浪费CPU资源，而w n机制 是通过获取/释放 CPU资源来实现的进程通信！==wait方法执行后会立即释放资源，notify不会立即释放锁，需要等待notify所在的syn代码块执行完毕后才释放锁。==

> **拥有相同锁的线程才可以实现wait/notify机制**

notify和wait都只能在`synchronzied`修饰的代码中使用。且在使用前都必须要保证已经获取到锁！获取到了锁才能执行notify/wait方法

wait（）使当前指向wait()方法的线程等待！在wait所在的代码行处暂停执行并释放锁。直到接到通知或被中断。

notify释放锁需要执行完synchronized修饰的代码才会释放锁！

`notifyAll`  唤醒线程的顺序未知！

```java
// 同一把锁内 才可以实现wait/notify相互通信。简而言之，只能唤醒和暂停统一把锁内的线程，不同锁的线程的暂停唤醒互不影响！
public class WaitAndNotify {
    public static void main(String[] args) {
        Object lock = new Object();
        Thread th1 = new Thread(() -> {
            synchronized (lock) {
                try {
                    System.out.println(Thread.currentThread().getName() + "wait start");
                    lock.wait();
                    System.out.println(Thread.currentThread().getName() + "wait end");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "th1");

        Thread th2 = new Thread(() -> {
            synchronized (lock) {
                try {
                    System.out.println(Thread.currentThread().getName() + "wait start");
                    lock.wait();
                    System.out.println(Thread.currentThread().getName() + "wait end");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }, "th2");

        Thread th3 = new Thread(() -> {
            synchronized (lock) {
                try {
                    System.out.println(Thread.currentThread().getName() + "notify start");
                    lock.notify();
                    System.out.println(Thread.currentThread().getName() + "notify end");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }, "th3");
        th1.start();
        th2.start();
        th3.start();
    }
}
// out put notify的唤醒顺序就是先进先出【队列！】
th1wait start
th3notify start
th3notify end
th2wait start
th1wait end
```

### wait(long)方法

等待long这么长的时间，在继续执行。注意，wait(long)也是会释放锁的，在过来long时间后，它想继续执行需要重新获得锁，才可以。

```java
/*
th1，放弃锁，并想在5秒后重新获得锁。
此时锁被th2拿到了，只能等th2运行10s后，th1才能拿到锁继续执行。
*/
public class WaitTime {
    public static void main(String[] args) throws InterruptedException {
        Object lock = new Object();

        Thread th1 = new Thread(() -> {
            try {
                synchronized (lock) {
                    System.out.println("wait long start. It need spend 10s");
                    lock.wait(5000);
                    System.out.println("wait long end");
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        Thread th2 = new Thread(() -> {
            synchronized (lock) {
                try {
                    System.out.println("other thread");
                    Thread.sleep(10000);
                    System.out.println("other thread end");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        th1.start();
        TimeUnit.SECONDS.sleep(1);
        th2.start();
    }
}
```

## wait/notify的应用

### 单生产单消费

一个生产者一个消费者。

- 生产者类
- 消费者类
- 资源类
- main方法

```java

```



### 一生产多消费

### 多生产一消费

### 多生产多消费



## join

- `x.join`,x在main线程中调用的。调用了x.join需要等线程执行完毕，x.join后面的代码才会执行
- `x.join(long)`,在main线程中调用的。main等待x调用了long毫秒后就不等了。

## join的使用
join把xx线程加入当前线程
```java
public static void main(String[] args) throws InterruptedException {
    Thread one = new Thread(new JoinOne(), "one");
    Thread two = new Thread(new JoinOne(), "two");
    System.out.println("main start");
    // 顺序调用方法 one.join发现 one需要cpu，所以等one结束后才把cpu给下一个线程。
    one.start(); // 把one线程加入main线程中进行执行。
    two.start();
    one.join();
    two.join();
    System.out.println("main finished");
}
```
join方法可以让线程排队运行！

join方法内部使用的wait方法进行等待

## join(long)
线程A.join(long) 线程A占有cpu资源long毫秒
```java
public static void main(String[] args) throws InterruptedException {
    Thread one = new Thread(new JoinTwo(), "one");
    System.out.println("main start");
    // 顺序调用方法 one.join发现 one需要cpu，所以等one结束后才把cpu给下一个线程。
    one.start();
    // one 占有cpu资源 5000毫秒
    one.join(5000);
    System.out.println("main finished");
}
```

## join(long) 和sleep(long)的区别
x.join(long)方法的内部用的是wait来实现的。当线程x执行完long毫秒后，会调用wait释放锁。<br/>
sleep则是通过synchronized来实现的，不会释放锁。

这个可以深究一下
```java
// 网上的解释 是 this 指的是main线程。传入参数为0时，main线程不断放弃锁，想办法让one执行
public final synchronized void join(long millis) throws InterruptedException {
    long base = System.currentTimeMillis();
    long now = 0L;
    if (millis < 0L) {
        throw new IllegalArgumentException("timeout value is negative");
    } else {
        if (millis == 0L) {
            // 如果this所在的线程如果Alive 则一直释放锁，让其他线程执行
            while(this.isAlive()) {
                this.wait(0L); //理解释放锁？
            }
        } else {
            while(this.isAlive()) {
                long delay = millis - now;
                if (delay <= 0L) {
                    break;
                }
                this.wait(delay); // 等待 delay毫秒后释放锁
                now = System.currentTimeMillis() - base;
            }
        }
    }
}
```



## ThreadLocal

**让每个线程都拥有自己变量。**

### ThreadLocal的使用

```java
public class ThreadLocalDemo1 {
    public static void main(String[] args) {
        ThreadLocal<Object> tl = new ThreadLocal<>();
        tl.set(1);
        tl.set(2);
        Object o = tl.get();
        Object o1 = tl.get();
        // 2:2 每个线程似乎只能存一个值
        System.out.println(o + ":" + o1);
    }
}
```

### ThreadLocal源码分析

**ThreadLocal类结构一览**

![](..\pics\ThreadLocal01.png)



![](..\pics\ThreadLocal02.png)

`ThreadLocal`有两个内部类 `ThreadLocalMap`和`SuppliedThreadLocal`。S开头那个是为了迎合lambda表达式。

`ThreadLocalMap`是一个静态类。用户多个`ThreadLocal`对象共享这个map

```java
ThreadLocalMap的成员变量
	    private static final int INITIAL_CAPACITY = 16; // 初始化容量
        private ThreadLocal.ThreadLocalMap.Entry[] table; // 
        private int size = 0;
        private int threshold;
```



- **set方法**

```java
public void set(T value) {
    // 获得当前线程
    Thread t = Thread.currentThread();
    // 获得当前线程的map
    ThreadLocal.ThreadLocalMap map = this.getMap(t);
    // map不为空 就set值，key为当前对象
    if (map != null) {
        // this是当前的ThreadLocal对象
        map.set(this, value);
    } else {
        this.createMap(t, value);
    }
}
```







# 第四章 各种JUC同步锁

## 概述

- `ReentrantLock`
- `CountDownLatch`
- `CyclicBarrier`
- `Phaser`
- `ReadWriteLock`
- `Semaphore`：限流
- `Exchanger`：交换两个线程的数据
- `LockSupport`

## CountDownLatch

计数。初始化数值为多少。然后根据条件进行countDown()

调用await方法，只要计数不是0， await这个栓就会锁着。知道计数为0，这个拴才会解锁。

等待多少线程结束，线程结束后做await后面的代码。

## CyclicBarrier

回环屏障

满足条件就运行

```java
public class CyclicBarrier {
    public static void main(String[] args) {

        // await了20个线程后，执行run方法，这里用的lambda表达式！
        java.util.concurrent.CyclicBarrier barrier = new java.util.concurrent.CyclicBarrier(20, () -> System.out.println("满人"));

        for (int i = 0; i < 100; i++) {
            new Thread(() -> {
                // 输出20个start后，输出了满人
                System.out.println("start");
                try {
                    barrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}
```

## 分阶段执行

```java
public class T08_TestPhaser {
    static Random r = new Random();
    static MarriagePhaser phaser = new MarriagePhaser();

    static void milliSleep(int milli) {
        try {
            TimeUnit.MILLISECONDS.sleep(milli);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {

        phaser.bulkRegister(5);

        for(int i=0; i<5; i++) {
            final int nameIndex = i;
            new Thread(()->{

                Person p = new Person("person " + nameIndex);
                p.arrive();
                phaser.arriveAndAwaitAdvance();

                p.eat();
                phaser.arriveAndAwaitAdvance();

                p.leave();
                phaser.arriveAndAwaitAdvance();
            }).start();
        }

    }

    static class MarriagePhaser extends Phaser {
        @Override
        protected boolean onAdvance(int phase, int registeredParties) {

            switch (phase) {
                case 0:
                    System.out.println("所有人到齐了！");
                    return false;
                case 1:
                    System.out.println("所有人吃完了！");
                    return false;
                case 2:
                    System.out.println("所有人离开了！");
                    System.out.println("婚礼结束！");
                    return true;
                default:
                    return true;
            }
        }
    }

    static class Person {
        String name;

        public Person(String name) {
            this.name = name;
        }

        public void arrive() {
            milliSleep(r.nextInt(1000));
            System.out.printf("%s 到达现场！\n", name);
        }

        public void eat() {
            milliSleep(r.nextInt(1000));
            System.out.printf("%s 吃完!\n", name);
        }

        public void leave() {
            milliSleep(r.nextInt(1000));
            System.out.printf("%s 离开！\n", name);
        }

    }
}
```

## 读写锁

读：共享锁

写：排他锁

读频繁，写不频繁，读写锁好！

```java
ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
ReadLock readLock = lock.readLock();
WriteLock writeLock = lock.writeLock();
```

## 信号量

可用来限流。

```java
 Semaphore s = new Semaphore(2, true);
```

AQS  AbstractQueueSynchronizer

## 交换

```java
Exchanger<String> objectExchanger = new Exchanger<>();
不同线程进行交换数据【两个线程之间的数据交换】
    public class Exchange {
        static Exchanger<String> exchanger = new Exchanger<>();

        public static void main(String[] args) {
            new Thread(()->{
                String s = "T1";
                try {
                    s = exchanger.exchange(s);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + " " + s);
            }, "t1").start();


            new Thread(()->{
                String s = "T2";
                try {
                    s = exchanger.exchange(s);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + " " + s);

            }, "t2").start();
        }
    }

```



