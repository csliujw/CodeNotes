# 网络

自顶向下；看书补充

> OSI开发式互联参考模型

![image-20211112142152898](D:\Code\note\JavaEE-Study\interview\img\image-20211112142152898.png)

# 数据库

## 如何设计一个关系型数据库

![image-20211112142709180](D:\Code\note\JavaEE-Study\interview\img\image-20211112142709180.png)

## 索引模块

### 为什么要使用索引

- 加快数据的检索。

> 什么信息可以作为索引

# Redis

> Redis 如何实现分布式锁

不知道网上是怎么实现的，这里给出一个我个人的想法：

- Redis 是一个高性能的单线程非关系型数据库，单线程也意味着没有并发操作，Redis 内部的操作都是线程安全的。
- 我们可以在 Redis 中设置某些标记作为分布式锁的标记；多个服务器同时向 Redis 发送请求。
- 比如：此时 10 台服务器争抢分布式锁，这 10 台服务器同时向 Redis 发送一个设置 key 的命令，第一个设置成功的就是拿到分布式锁的，没设置成功的就是没拿到分布式锁的。
- 拿到了锁，又如何释放呢？
    - 法一：拿到锁的服务器，再发送一次 设置 key 的命令，将锁状态置为未加锁。
    - 法而：直接给 key 设置过期时间，过期了就表示锁被释放了，可以重新竞争

> Redis 如何实现异步消息队列

用 `Redis` 的 list 数据结构先进先出的特点，可以实现一个消息队列，`rpush` 生产消息，`lpop` 消费消息。

- 当 `lpop` 没拿到消息，说明没有消息了；没有等待队列有值就直接消费
- 可以通过在应用层加入 sleep 机制去调用 `lpop` 重试。也可以 `blpop` 阻塞直到队列有消息或者超时。
- 缺点：每个消息只能供一个消费者消费。

`Redis` 的 pub/sub 模式可以实现一对多的消费队列。

- 发送者（pub）发送消息，订阅者（sub）接收消息
- 订阅者可以订阅任意数量的频道
- 缺点：消息的发布是无状态的，无法保证可达。

![image-20211112150351084](D:\Code\note\JavaEE-Study\interview\img\image-20211112150351084.png)

> Redis 持久化

RDB（快照）持久化：保存某个时间点的全量数据快照。

```shell
save 900 1 # 900s 有一条写入 就备份
save 300 10 # 300s 有十条写入 就备份
save 60 10000 # 60s 有一万条写入 就备份 多个配置是怕数据的写入不规律，为了平衡性能和数据安全。

stop-writes-on-bgsave-error yes # 如果备份出现错误，主线程就停止接收新的写入操作

rdbcompression yes # 先压缩，再备份。一般我们是选择 no
```

> Redis 集群原理

- 分片：按照某种规则去划分数据，分散存储在多个节点上。
- 常规的按照哈希划分无法实现节点的动态增减（当增加或减少一个节点时，会造成大量的 key 无法被命中）
- 一致性哈希算法：对 2^32 取模。将哈希值空间组织成虚拟的圆环。

将多台服务器，计算 hash 值后，分布在这个哈希环中。数据也进行 hash 计算，看数据顺时针走，将数据存储在距离最近的服务器上。这样会有一个问题，可能大量的数据都堆积在了一台服务器上。这种情况，为每台服务器设置多个 node 节点即可。

> Redis 的 Pipeline

- Pipeline 和 Linux 的管道类似；批量执行成千上万的命令。
- `Redis` 基于请求\响应模型，单个请求处理需要一一应答
- Pipeline 批量执行指令，节省多次 IO 往返时间（就是，批量发送多条命令，最后将批量的结果返回）
- 有顺序依赖的指令建议分批发送。

> Redis 的同步机制

**主动同步原理**

- 一个 Master 写，多个 Slave 读。数据之间是弱一致性的，但是最终会趋于同步（最终一致性）。
- 全量同步
    - Salve 发送 sync 命令到 Master
    - Master 启动一个后台进程，将 Redis 中的数据快照保存到文件中
    - Master 将保存数据快照期间接收到的写命令缓存起来（就是缓存增量数据）
    - Master 完成写文件操作后，将该文件发送给 Salve
    - 使用新的 AOF 文件替换旧的 AOF 文件。
    - Master 将这期间收集的增量写命令发送给 Salve 端
- 增量同步过程
    - Master 接收到用户的操作指令，判断是否需要传播到 Slave
    - 将操作记录追加到 AOF 文件
    - 将操作传播到其他 Slave：1、对齐主从库；2、往响应缓存写入指令
    - 将缓存中的数据发送给 Slave
- Redis Sentinel：解决主从同步 Master 宕机后的主从切换问题，发现 Master 宕机后可以进行自动切换
    - 监控：检查主从服务器是否运行正常
    - 提醒：通过 API 向管理员或者其他应用程序发送故障通知
    - 自动故障迁移：主从切换，将一个从服务器升级为主服务器；将原来的 Slave 改为复制新的 Master；当集群试图连接宕机的主服务器时，会返回一个新的 Master 给他。
- 流言协议 Gossip：在杂乱无章中寻求一致
    - 每个节点都随机地与对方通信，最终所有节点的状态达成一致。
    - 种子阶段定期随机向其他节点发送节点列表以及需要传播的消息。
    - 不保证信息一定会传递给所有节点，但是最终会趋于一致。

# Linux

## Linux的体系结构

![image-20211112160732407](D:\Code\note\JavaEE-Study\interview\img\image-20211112160732407.png)

## 指令

- `man 2 syscalls` 查看所有的系统调用
- `which ls` 查看 ls 所在的位置
- `less 文件` 查看部分文件
- `cat /etc/shells` 查看支持哪些 shells 版本
- `chsh -s shell 路径`，切换为某个 shell

> 查找文件

`find path [options] params` 在指定目录查找文件

```bash
find -name "target.java" # 当前目录为根目录进行搜索

find / -name "target.java" # 全局搜索  / 表示根目录

find ~ -name "target*" # 当前用户 home 目录 以 target 打头的文件

find ~ -iname "target*" # 不区分文件大小写查找
```

> 检索文件内容

`grep [options] pattern file`

- 全称：Global Regular Expression Print
- 作用：查找文件里符合条件的字符串，只会筛选目标字符所在的行。

```bash
grep "moo" target* # 在 target 开头的文件中 查找 moo；默认在当前目录查找
```

![image-20211112163956476](D:\Code\note\JavaEE-Study\interview\img\image-20211112163956476.png)

![image-20211112164040624](D:\Code\note\JavaEE-Study\interview\img\image-20211112164040624.png)

> 管道操作符 |

- 可将指令连接起来，前一个指令的输出作为后一个指令的输入；只处理前一个命令的正确输出，不处理错误输出。

- 如：查找文件中，文件名包含 h 的文件

    ![image-20211112164545343](D:\Code\note\JavaEE-Study\interview\img\image-20211112164545343.png)

- 从日志中筛选信息
- `grep 'demo\[true\]' de.log` 从日志中筛选 demo[true] 的数据 
- `grep -o 'engine\[[0-9a-z]*\]'` 筛选出正则表达式中的内容
- `grep -v 'grep'` 过滤掉包含 `grep` 的内容

> 对文件内容做统计

`awk [option] 'cmd' file`

- 一次读取一行文件，按输入分隔符进行切片，切成多个组成部分
- 将切片直接保存在内建的变量中，`$1$2...（$0表示行的全部）`
- 支持对单个切片的判断，支持循环判断，默认分隔符为空格

```bash
# 查看 demo.txt 中 第一列 和 第三列的信息
awk '{print $1,$3}' demo.txt

# 打印第一列等于 TCP，第三列等于 sf 的第0列的信息
awk '$1=="tcp" && $3=="sf" {print $0}' demo.txt 

# 对内容逐行做统计操作
```

> 批量替换文本内容

`sed [option] 'sed command' filename`

- 全名 stream editor，流编辑器
- 适合用于对文本内容进行处理

```bash
# 将 replace.java 中的 Str 开头的替换为 String，默认时把替换的结果输出到控制台
sed 's/^Str/String/' replace.java

# -i 则会将文本中的内容替换
sed -i 's/^Str/String/' replace.java

# 筛选出 . 结尾的行，并将 . 替换为 ;
sed -i 's/\.$/\;/' replace.java

# 筛选出包含 Jack 的字符串行，并将 Jack 替换为 me g表示全局替换，即所有的 Jack 都替换为 me
sed -i 's/Jack/me/g' replace.java

# 删除文本中的 Integer 所在的行
sed -i '/Integer/d' replace.java
```

# Java SE

## Java 的理解

- 平台无关
    - Java 代码 --> 字节码 --> 不同OS的JVM进行解析；用的同一套解析规则 --> JVM 将字节码转成具体平台上的机器指令
- GC
- 语言特性
    - 泛型、反射、lambda
- 面向对象
    - 继承、封装、多态
- 类库
    - 集合、JUC、IO、NIO
- 异常处理

## `ArrayList` 扩容规则

- 扩容是懒惰式的，即没有添加元素前，即时指定了容量，也不会真正创建数组。
- add(Object o) 首次扩容为10，再次扩容为上次容量的 1.5 倍
- addAll(Collection c) 首次扩容为 Math.max(10, 实际元素个数)
- addAll(Collection c) 再次扩容（有元素时）为 Math.max(原容量 1.5 倍, 实际元素个数)
    - 举例：容量为10，已有10个元素，addAll(三个)，最后回在13 和 15 之间选个最大值。（coding）
- fail-fast 与 fail-safe
    - ArrayList 是 fail-fast 的典型代表，遍历的同时不能修改，尽快失败
    - CopyOnWriteArrayList 是 fail-safe 的典型代表，遍历的同时可以修改，原理是读写分离。

### 迭代遍历

Iterator FailFast FailSafe

- fail-fast 一旦发现遍历的同时其他人来修改，则立刻抛异常。【ArrayList 演示】
- fail-safe 发现遍历的同时其它人来修改，应当能有对应策略，例如牺牲一致性来让整个遍历运行完成。【CopyOnWriteArrayList 演示】

通过判断循环开始时和循环遍历过程中，数组的修改次数是否一致，不一致说明被修改了，抛出并发修改异常。

### fail-fast 的实现

ArrayList 内部维护了一个 modCount，记录了 ArrayList 被操作了多少次。Iterator 内部也维护了一个 expectedModCount，初始值为 modCount。如果迭代的过程中发现 expectedModCount 和 modCount 不一样，说明被修改了，抛出并发修改异常。

### fail-safe 的实现

遍历的同时可以修改，实现原理是读写分离；遍历是一个数组，添加又是另一个数组。（CopyOnWriter）

## LinkedList

### ArrayList vs LinkedList

- ArrayList
    - 基于数组，需要连续内存
    - 随机访问快
    - 尾部插入、删除性能可以；其他部分插入、删除都会移动数据，性能低
    - 可以利用 CPU 缓存，局部性原理
- LinkedList
    - 基于双向链表，无需内存连续
    - 随机访问慢（要沿着链表遍历）
    - 头尾插入删除性能高
    - 占用内存多

## HashMap

### 创建题

> 底层数据结构，1.7 & 1.8

- 1.7：数组+链表
- 1.8：数组+（链表 | 红黑树）

> 为何要用红黑树，为何一上来不树化，树化阈值为何是8，何时被树化，何时会退化为链表？

**树化意义**

* 红黑树用来避免 DoS 攻击，防止链表超长时性能下降，树化应当是偶然情况，是保底策略
* hash 表的查找，更新的时间复杂度是 $O(1)$，而红黑树的查找，更新的时间复杂度是 $O(log_2⁡n )$，TreeNode 占用空间也比普通 Node 的大，如非必要，尽量还是使用链表
* hash 值如果足够随机，则在 hash 表内按泊松分布，在负载因子 0.75 的情况下，长度超过 8 的链表出现概率是 0.00000006，树化阈值选择 8 就是为了让树化几率足够小

**树化规则**

* 当链表长度超过树化阈值 8 时，先尝试扩容来减少链表长度，如果数组容量已经 >=64，才会进行树化

**退化规则**

* 情况1：在扩容时如果拆分树时，树元素个数 <= 6 则会退化链表
* 情况2：remove 树节点时，若 root、root.left、root.right、root.left.left 有一个为 null ，也会退化为链表



# 并发编程



#  框架

## ApplicationContext refresh 流程

ApplicationContext 只是一个外部的容器，核心功能还是要交给  BeanFactory 容器。

### 概述

一共分为 12 个步骤

- 准备工作
    - prepareRefresh
- 创建和准备 BeanFactory  对象
    - obtainFreshBeanFactory
    - prepareBeanFactory
    - postProcessBeanFactory
    - invokeBeanFactoryPostProcessors
    - registerBeanPostProcessors
- 准备 ApplicationContext
    - initMessageSource
    - initApplicationEventMulticaster
    - onRefresh
    - registerListeners
    - **finishBeanFactoryInitialization**  创建单例对象
    - finishRefresh

### 每步的功能

- prepareRefresh -- 做好准备工作：创建一个 Eventivorment 对象，为 Spring 后续的运行准备键值信息。
- obtainFreshBeanFactory -- 创建或获取 BeanFactory：
- prepareBeanFactory -- 准备 BeanFactory：为 BeanFactory 准备各个成员变量，如 EL 表达式的解析器，类型转换器，内置的 BeanPostProcessor
- postProcessBeanFactory -- 子类扩展 BeanFactory
- invokeBeanFactoryPostProcessors -- 后处理器扩展 BeanFactory，比较重要的有 ConfigurationClassPostProcessor 可以解析各种配置信息的注解。
- registerBeanPostProcessors -- 准备 Bean 后处理器，常见的有 解析 Autowired 注解的，解析 Resource 注解的，创建代理类的。
- initMessageSource -- 为 ApplicationContext 提供国际化功能
- initApplicationEventMulticaster -- 为 ApplicationContext  提供事件发布器
- onRefresh -- 留给子类扩展
- registerListeners -- 为 ApplicationContext  准备监听器
- **finishBeanFactoryInitialization**  -- 初始化所有非延迟单例 Bean，执行 Bean 后处理器扩展
- finishRefresh -- 准备生命周期管理器，发布 ContextRefreshed 事件。

```java
@Override
// 用到了模板方法。定义流程规则，具体实现由子类实现。
public void refresh() throws BeansException, IllegalStateException {
   synchronized (this.startupShutdownMonitor) {
      // Prepare this context for refreshing.
      prepareRefresh();

      // Tell the subclass to refresh the internal bean factory.
      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

      // Prepare the bean factory for use in this context.
      prepareBeanFactory(beanFactory);

      try {
         // Allows post-processing of the bean factory in context subclasses.
         postProcessBeanFactory(beanFactory);

         // Invoke factory processors registered as beans in the context.
         invokeBeanFactoryPostProcessors(beanFactory);

         // Register bean processors that intercept bean creation.
         registerBeanPostProcessors(beanFactory);

         // Initialize message source for this context.
         initMessageSource();

         // Initialize event multicaster for this context.
         initApplicationEventMulticaster();

         // Initialize other special beans in specific context subclasses.
         onRefresh();

         // Check for listener beans and register them.
         registerListeners();

         // Instantiate all remaining (non-lazy-init) singletons.
         finishBeanFactoryInitialization(beanFactory);

         // Last step: publish corresponding event.
         finishRefresh();
      }

      catch (BeansException ex) {
         if (logger.isWarnEnabled()) {
            logger.warn("Exception encountered during context initialization - " +
                  "cancelling refresh attempt: " + ex);
         }

         // Destroy already created singletons to avoid dangling resources.
         destroyBeans();

         // Reset 'active' flag.
         cancelRefresh(ex);

         // Propagate exception to caller.
         throw ex;
      }

      finally {
         // Reset common introspection caches in Spring's core, since we
         // might not ever need metadata for singleton beans anymore...
         resetCommonCaches();
      }
   }
}
```

### prepareRefresh

- 创建和准备 Environment 对象
- 理解 Environment 对象的作用
    - 提供一些键值信息，管理各种键值信息。
    - systemProperties
    - systemEnvironment
    - 自定义 PropertySource

Environment  的作用之一就是为后续@Value，值注入时提供键值。

### obtainFreshBeanFactory

- 获取（或创建）BeanFactory
- 理解 BeanFactory 的作用
- 理解 BeanDefinition 的作用
- BeanDefinition 从何而来

BeanFactory 会包含这几个信息

- beanDefinitionMap - 初始化了
- beanExpressionResolver
- propertyEditorRegistrars
- resolvableDependencies
- beanPostProcessors
- conversionService
- embeddedValueResolvers
- singletonObjects

BeanFactory 负责 bean 的创建、依赖注入和初始化。

BeanDefinition 作为 bean  的设计蓝图，规定了 bean 的特征，如单例多例、依赖关系、初始销毁方法等

BeanDefinition 的来源多种多样，可以是通过 xml 获得、通过配置类获得、通过组件扫描获得，也可以是编程添加。

###  prepareBeanFactory

准备 bean 工厂。即把成员变量初始化好。

- 完善 BeanFactory
- 了解谁来解析 SpEL：beanExpressionResolver 来解析
- 了解谁来执行类型转换：propertyEditorRegistrars 注册类型转换器
- 了解特殊 bean 的注入：resolvableDependencies 管理特殊的对象（如 ApplicationContext），用来依赖注入
- 两个内置的 BeanPostProcessor 的作用：beanPostProcessors，对 bean 做扩展。

### postProcessBeanFactory

- 空方法，留给子类扩展
- 用到了模板方法设计模式
- 一般 Web 环境的  ApplicationContext 都要利用它注册新的 Scope，完善 Web 下的  BeanFactory

### invokeBeanFactoryPostProcessors

- 理解 beanFactory 后处理器的作用
- 掌握常见的 beanFactory 后处理器

----

- beanFactory 后处理器，充当 beanFactory 的扩展点，可以用来补充或修改 BeanDefinition
- ConfigurationClassPostProcessor - 解析 @Configuration、@Bean、@Import\@PropertySource 等
- PropertySourcePlaeHolderConfigurer - 替换 BeanDefinition 中的 `${}`

### registerBeanPostProcessors

对 bean 做后处理增强。就是那些需要增强的对象。这些 bean 后处理器都是在 beanDefinitionMap 中搜索，看看有没有人实现了 beanPostProcessors 接口。有的话就创建出来，加入到 beanPostProcessors 集合中。bean 创建时就需要用到这些  bean 后置处理器了。

- 默认的 BeanFactory 是没有这么多功能的。如：没有处理依赖的功能，没有切面增强的功能，需要我们加入后置处理器。
- bean 后处理器，充当 bean 的扩展点，可以工作在 bean 的实例化、依赖注入、初始化阶段
- AutowiredAnnotationBeanPostProcessor 功能有：解析 @Autowired，@Value 注解
- CommonAnnotationBeanPostProcessor 功能有：解析 @Resource，@PostConstruct，@PreDestroy
- AnnotationAwareAspectJAutoProxyCreator 功能有：为符合切点的目标 bean 自动创建代理，从而进行功能增强。
- 在 bean 创建的过程中，才会使用到这些后置处理器。

###  initMessageSource

- 给 MessageSourc 赋值。（国际化用的）

### initApplicationEventMulticaster

收发事件。Multicaster用来发事件。监听器负责收事件。也是先到 beanDefinitionMap 中找，有就拿，没有就创建一个默认的。

- 用来发布事件给监听器
- 可以从容器中找名为 applicationEventMulticaster 的 bean 作为事件广播器，若没有，也会新建默认的事件广播器
- 可以调用 ApplicationContext.publishEvent(事件对象) 来发布事件。

### onRefresh

- 空实现，留给子类扩展
- Spring Boot 中有很多内嵌的 web 容器，其实就是扩展了 onRefresh 这个方法。创建了一些 内嵌web 容器

### registerListeners

- 监听器对象。用来接收事件
- 一部分监听器是事先编程添加的、另一部分监听器来自容器中的 bean、还有一份部分来自于 `@EventListener` 的解析
- 实现 ApplicationListener 接口，重写其中的 onApplicationEvent(E e) 方法即可。

### finishBeanFactoryInitialization

- 包含三个内容：conversionService、embeddedValueResolvers、singletonObjects
- 把 beanFactory 剩余的几个部分补充完整。
- 作为 propertyEditor 的补充。
- conversionService 也是一套转换机制，作为对 PropertyEditor 的补充。
- 内嵌值解析器用来解析 @Value 中的 `${}` ，借用的是 Environment 的功能。
- 单例池用来缓存所有单例对象，对象的创建都分为三个阶段，每一阶段都有不同的 bean 后处理器参与进来，扩展功能。

### finishRefresh

- 用来控制容器内需要生命周期管理的 bean。
- 如果容器中有 lifecycleProcessor 的 bean 就用它，否则创建默认的生命周期管理器。
- 调用 context 的 start，即可出发所有实现 LifeCycle 接口 bean 的 start
- 调用 context 的 stop，即可出发所有实现 LifeCycle 接口 bean 的 stop

## Spring Bean 的生命周期

Bean 从创建到销毁主要做了那些事情。

```java
protected <T> T doGetBean(
    String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly)
```

- 阶段1：处理名称，检查缓存

- 阶段2：检查父工厂

- 阶段3：检查 DependsOn

- 阶段4：按 Scope 创建 Bean

    - 创建 singleton
    - 创建 prototype
    - 创建其他 scope

- 阶段5：创建 bean

    - 

- 阶段6：

- 阶段7：

    